<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"alan20210202.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="不务正业高中生一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="Chengyuan Ma&#39;s Blog">
<meta property="og:url" content="https://alan20210202.github.io/index.html">
<meta property="og:site_name" content="Chengyuan Ma&#39;s Blog">
<meta property="og:description" content="不务正业高中生一枚">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chengyuan Ma">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://alan20210202.github.io/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.css" integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbggqjHJeyzx88I3rfwjS38WJag/ihH7lzuGlGHpDBymLirZQ==" crossorigin="anonymous" />
<title>Chengyuan Ma's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-65HSG5NCY6"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-65HSG5NCY6');
      }
    </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Chengyuan Ma's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-pagedewarp"><a href="/dewarp/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>PageDewarp</a></li>
        <li class="menu-item menu-item-english"><a href="/english/" rel="section"><i class="fa fa-globe-americas fa-fw"></i>English</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chengyuan Ma"
      src="/avatar.png">
  <p class="site-author-name" itemprop="name">Chengyuan Ma</p>
  <div class="site-description" itemprop="description">不务正业高中生一枚</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">87</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://kalasearch.cn/" title="https:&#x2F;&#x2F;kalasearch.cn&#x2F;" rel="noopener" target="_blank">卡拉搜索</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/03/17/MITAdmitted/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/17/MITAdmitted/" class="post-title-link" itemprop="url">被MIT录取——申请中的大起大落</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-17 20:44:31" itemprop="dateCreated datePublished" datetime="2021-03-17T20:44:31+08:00">2021-03-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-26 16:33:51" itemprop="dateModified" datetime="2021-03-26T16:33:51+08:00">2021-03-26</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>3月15日清晨6:30分</p>
<p>某人迷迷糊糊地刚刚从被窝里爬出来</p>
<p>迷迷糊糊地唤醒一夜没关的电脑</p>
<p>迷迷糊糊地点进MIT的portal</p>
<p>啊，果然status更新了呢，虽然不该抱什么期待的</p>
<p>自己这个水平申请纯属做分母哦，大概一定是thank you for applying to MIT这种套路话罢（确信）</p>
<p>为了彻底让自己死心点了进去并开始阅读</p>
<blockquote>
<p>On behalf of the Admissions Committee, it is my pleasure to offer you admission to the MIT Class of 2025! You stood out ...</p>
</blockquote>
<p>嗯？（要素察觉）</p>
<p><img src="地铁老人手机.jpg" alt="地铁老人手机" /></p>
<p><strong>嗯？！？！？</strong></p>
<p><img src="这场面我真没见过.jpg" alt="这场面我真没见过" /></p>
<p>千言万语在早晨上学的急忙中汇成一句话</p>
<blockquote>
<p>草，居然录了？</p>
</blockquote>
<p>然后简单地发了个朋友圈，吃完饭，开开心心上学去了。</p>
<p>学校申请的竞争是残酷的，所谓成王败寇莫不如是。抢救性写感言，各路学弟开始问经验，然后我其实一时半会并答不出来。另一方面，我在学姐的帮助下倒是在一个小时内就找到了组织见到了前几届MIT的学长，然后发现群里面个个都是集训队级别的大佬，区区国铜瑟瑟发抖。</p>
<p>一切都引向了一个我必须思考的问题：</p>
<blockquote>
<p>我这么菜，为啥会被MIT看上呢？</p>
</blockquote>
<p><img src="反复分析.jpg" alt="反复分析" /></p>
<p>论标化，自己的标化成绩在国内传统认知内对于MIT的申请只能称得上是堪堪够用。</p>
<p>论文书，因为自己原本对MIT的申请不抱特别大的希望，文书写的是中规中矩，没有特别多的灵光一现和奇妙构思。</p>
<p>论活动，自己没有上过许多国内奉为圭臬的夏校。没有辩论，没有模联，没有特别多社会活动。</p>
<p>论竞赛，自己国铜的最高水准大概只到了最低线？</p>
<p>论申请策略，自己直接说喜欢EECS的直球做法在许多人看来也是头铁。</p>
<p>那是为什么呢？</p>
<p>转了一圈，思绪回到1月6号申请最后一天在电脑前的奋笔疾书。</p>
<p>是了，原来如此，答案或许见诸于MIT申请系统的首页：</p>
<blockquote>
<p>The key is to be yourself.</p>
</blockquote>
<p>我在最后一天才意识到MIT的申请居然允许递交一份maker portfolio，那时的兴奋是无以言表的。</p>
<p>自己就把自己平时乱搞的小项目连简介带Github链接填了上去，填了九个，简介写了一千多个词，自己从未如此畅快。</p>
<p>想必让招生官高看我一眼的，大概就是这么多乱搞项目当中体现出来的对<del>摸鱼</del>计算机的一种热情？（暴论）</p>
<p>记得自己曾经做第一个小项目的时候，一方面是觉得自己开心，另一方面为未尝没有“如果项目牛逼了会不会被人赏识”的小功利心和小幻想。做了那么多小项目，快乐是总有的，但牛逼的项目是没有的，所以在高中的几年觉得大学申请愈发迫近也曾焦虑迷茫过，尝试过竞赛，但也难以完全投入精力，最终屈服于自己强大的摸鱼欲之下重操旧业。也不止一次地心中有“自己摸鱼做项目的时间是不是浪费了呢？”的疑问。</p>
<p>但是现实证明，所有的努力都不会被辜负。</p>
<p>当然，这也可以理解为是某人摸鱼主义哲学的大胜利（大雾）。</p>
<p><img src="image-20210326162803734.png" alt="image-20210326162803734" /></p>
<p><del>上图：当你摸鱼的contribution都状似摸鱼，你就达成了二阶摸鱼的至高境界，物极必反，这是MIT的隐藏通道</del></p>
<p>人啊，还是要有理想的，有理想地摸鱼，这就达成了一组矛盾的对立统一，矛盾摸鱼，乃摸鱼之大境界。</p>
<p>最后还是要说一句，<del>Cornell你拒的好啊！</del></p>
<p>录了技校，人很开心，加上之前录了剑桥，所以现在就是一个去Cambridge还是去Cambridge读书的问题了，我选择去Cambridge。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/03/13/LaTeX%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/13/LaTeX%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">LaTeX小技巧整理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-13 18:24:21" itemprop="dateCreated datePublished" datetime="2021-03-13T18:24:21+08:00">2021-03-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-16 17:21:52" itemprop="dateModified" datetime="2021-03-16T17:21:52+08:00">2021-03-16</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这篇文章是在经历<span class="math inline">\(\LaTeX\)</span>改格式改得死去活来后对于以后可能经常会用到的格式调整小技巧的一个汇总。许多片段的来源是TeX StackExchange, 源链接就不一一表明了。这些技巧在XeTeX上编译通过，对于其他的引擎尚未测试。</p>
<p>该列表预计会随着我被<span class="math inline">\(\LaTeX\)</span>虐的次数增加而不断更新。</p>
<h1 id="页边距设置">页边距设置</h1>
<p>使用<code>geometry</code>宏包：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;geometry&#125;
\geometry&#123;a4paper, top = 34.4mm, bottom = 45mm, left = 23mm, right = 23mm&#125;</code></pre>
<p>更高级的用途可以参阅其官方文档。</p>
<h1 id="字体设置">字体设置</h1>
<h2 id="times-new-roman">Times New Roman</h2>
<p>为了全局设置Times New Roman字体，我们需要<code>fontspec</code>宏包：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;fontspec&#125;
\setmainfont&#123;Times New Roman&#125;</code></pre>
<p>如果希望数学公式的字体也使用Times New Roman，可以使用<code>newtx</code>宏包：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;newtxmath&#125;</code></pre>
<p>注：<code>newtx</code>宏包下还有<code>newtxtext</code>可以代替<code>fontspec</code>和<code>setmainfont</code>的功能，但是不知为何在Windows的XeTeX上编译错误。归根结底，XeTeX以及LuaTeX的一个设计理念就是使用户可以直接调用系统字体而不用拘泥于宏包，因此我个人还是偏向于<code>setmainfont</code>的解决方案。</p>
<h2 id="宋体粗体">宋体粗体</h2>
<p>CTeX在Windows系统下宋体采用的是中易的字库，而不幸的是中易的宋体并不包括粗体。Word之所以可以给中易宋体加粗，是因为它有在标准字重基础之上自动加粗的算法。而高贵的<span class="math inline">\(\LaTeX\)</span>显然是不屑于用这种歪门邪道加粗字体的，所以你惊喜地发现在Windows下你似乎无论怎么<code>\textbf</code>/<code>\bfseries</code>都得不到加粗的宋体（于是CTeX就机智地把黑体作为粗体时的字体）。如果因为种种原因迫不得已一定要使用粗体，CTeX给出了两个解决方案：</p>
<ol type="1">
<li>伪粗体：通过对于一个汉字堆叠若干个微距平移标准字号的宋体实现视觉上的粗体效果。这种伪粗体效果肯定不如专门的宋体效果好，而且在PDF内选词的时候偶尔会遇到问题，因此我是没有使用过。</li>
<li>使用带有粗体的宋体：可以使用<code>\setCJKmainfont</code>命令转而使用例如思源黑体等设计时考虑粗体的字体。这在Windows下其实也不简单。最傻瓜的做法是在<code>\documentclass&#123;ctexart&#125;</code>前加上<code>[fontset = fandol]</code>选项，使得CTeX采用Fandol的字库。这家的字库可以在GPL协议下自由使用，但是缺点是缺的字不少。</li>
<li>不是解决办法的办法：装一台Ubuntu的虚拟机，Ubuntu下的默认宋体是带有粗字号的，问题直接解决。</li>
</ol>
<h1 id="标题格式的修改">标题格式的修改</h1>
<p>一般来说，LaTeX内修改标题格式最合适的宏包是<a target="_blank" rel="noopener" href="https://www.ctan.org/pkg/titlesec"><code>titlesec</code></a>。<code>titlesec</code>的文档相当详细，SE上也有非常多的教程，所以在这类就不多赘述了。我想记一笔的是CTeX内部自带的格式设置功能：这个功能在CTeX的<a target="_blank" rel="noopener" href="https://www.ctan.org/pkg/titlesec">官方手册</a>上确有记载，但是在网上却不是很好找。个人认为用法比<code>titlesec</code>简洁明了，对于一般的中文文档已是相当够用了。这里举一个例子：</p>
<pre class="line-numbers"><code class="language-latex">\ctexset&#123;
    section/format = \songti\sffamily\zihao&#123;-4&#125;\bfseries, % 中文宋体，英文无衬线体，字号小四，加粗
    section/afterskip = 0pt, % 标题下方不留空，直接接段落，更紧凑
    subsection/format = \songti\sffamily\zihao&#123;5&#125;\bfseries, % 中文宋体，英文无衬线体，字号五号，加粗
    subsection/beforeskip = 0pt, % 标题上方不留空，直接在上一段下方，更紧凑
    subsection/afterskip = 0pt, % 标题上方不留空
    subsubsection/format = \songti\sffamily\zihao&#123;5&#125;\bfseries, % 中文宋体，英文无衬线体，字号五号，加粗
    subsubsection/beforeskip = 0pt,
    subsubsection/afterskip = 0pt   
&#125;</code></pre>
<h1 id="参考文献标题格式的修改">“参考文献”标题格式的修改</h1>
<p>和上节相同，只需要在<code>\thebibliography</code>之前修改<code>section</code>的格式就行了（如果还有附录的话不要忘记改回来）。</p>
<p>如果要修改“参考文献”这四个字本身，CTeX提供了<code>refname</code>选项。</p>
<h1 id="自动引号配对">自动引号配对</h1>
<p>使用<code>csquotes</code>宏包：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage[autostyle=false, style=english]&#123;csquotes&#125;
\MakeOuterQuote&#123;&quot;&#125;</code></pre>
<h1 id="中文的定理环境">中文的定理环境</h1>
<p>CTeX会自动将<code>amsthm</code>包当中的证明环境从“Proof”改成“证明”，但在<code>ctexart</code>类型下不会对定理，引理，定义等环境进行汉化，因此需要手动加入如下代码：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;amsthm&#125;
\newtheorem&#123;theorem&#125;&#123;定理&#125;[section]
\newtheorem&#123;definition&#125;&#123;定义&#125;[section]
\newtheorem&#123;corollary&#125;&#123;推论&#125;[section]
\newtheorem*&#123;remark&#125;&#123;注&#125;
\newtheorem&#123;lemma&#125;&#123;引理&#125;[section]</code></pre>
<h1 id="列表环境下的间距">列表环境下的间距</h1>
<h2 id="一般列表去除间距">一般列表去除间距</h2>
<p>使用<code>enumitem</code>宏包的<code>nosep</code>选项让<code>enumerate</code>和<code>itemize</code>中相邻项之间的垂直间距为0：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;enumitem&#125;

\begin&#123;enumerate&#125;[nosep]

\end&#123;enumerate&#125;</code></pre>
<h2 id="文献列表去除间距">文献列表去除间距</h2>
<p>通过以下代码去除文献列表中相邻项的垂直间距：</p>
<pre class="line-numbers"><code class="language-latex">% 去除参考文献一节文献项之间过大的间隙
\let\OLDthebibliography\thebibliography
\renewcommand\thebibliography[1]&#123;
    \OLDthebibliography&#123; #1 &#125;
    \setlength&#123;\parskip&#125;&#123;0pt&#125;
    \setlength&#123;\itemsep&#125;&#123;0pt plus 0.3ex&#125;
&#125;</code></pre>
<h1 id="图注格式修改">图注格式修改</h1>
<p>最为通用，最为灵活的方法：</p>
<pre class="line-numbers"><code class="language-latex">% 宋体五号粗体，#1#2#3分别是“图xxx”，“：”，以及图注文字本身
\DeclareCaptionFormat&#123;mycaptionformat&#125;&#123;\songti\zihao&#123;-5&#125;\bfseries#1#2#3\par&#125;
\captionsetup&#123;format = univchem&#125;</code></pre>
<h1 id="页眉页脚相关">页眉页脚相关</h1>
<h2 id="首页特殊">首页特殊</h2>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;fancyhdr&#125;
\fancypagestyle&#123;firststyle&#125;&#123;
    \fancyhf&#123;&#125;
    \renewcommand&#123;\headrule&#125;&#123;\hrule height 0.5pt \vspace&#123;0.8pt&#125;\hrule height 0.5pt&#125;
    \renewcommand&#123;\footrule&#125;&#123;\hrule height 0.5pt width 0.3\textwidth&#125;
    ...
&#125;

% 在\begin&#123;document&#125;之后
\thispagestyle&#123;firststyle&#125;</code></pre>
<h2 id="装饰线">装饰线</h2>
<pre class="line-numbers"><code class="language-latex">% 页眉双线
\renewcommand&#123;\headrule&#125;&#123;\hrule height 0.5pt \vspace&#123;0.8pt&#125;\hrule height 0.5pt&#125;
% 页脚部分装饰线
\renewcommand&#123;\footrule&#125;&#123;\hrule height 0.5pt width 0.3\textwidth&#125;</code></pre>
<p>参数可以视情况自行调整；可以写在<code>\fancypagestyle</code>内部。</p>
<h1 id="在一行内同时包括左中右对齐的文本">在一行内同时包括左中右对齐的文本</h1>
<pre class="line-numbers"><code class="language-latex">\newcommand&#123;\headerline&#125;[3]&#123;
    \par\medskip\noindent
    \makebox[\textwidth][s]&#123;\rlap&#123;#1&#125;\hfill#2\hfill\llap&#123;#3&#125;&#125;%
    \par\medskip
&#125;
% 用例：
\headerline&#123;•栏目•&#125;&#123;doi: 10.3866/PKU.DXHX20xxxxxxx&#125;&#123;www.dxhx.pku.edu.cn&#125;</code></pre>
<h1 id="在表格环境内改变表线宽度">在表格环境内改变表线宽度</h1>
<p>鉴于许多办法可能不适用于除<code>tabular</code>之外的环境，这里提供一个简单粗暴的办法：</p>
<pre class="line-numbers"><code class="language-latex">\setlength&#123;\doublerulesep&#125;&#123;0pt&#125;
...

\hline\hline % 两倍标准线宽</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/02/02/KCP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/02/KCP/" class="post-title-link" itemprop="url">Rust实现带BBR的高效魔改KCP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-02-02 21:18:31 / 修改时间：21:21:01" itemprop="dateCreated datePublished" datetime="2021-02-02T21:18:31+08:00">2021-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>完整的代码<a target="_blank" rel="noopener" href="https://github.com/alan20210202/ekho/blob/e2c24b4504/src/kcp.rs">在此</a>。</p>
<h1 id="背景">背景</h1>
<p>最近我在用Rust写一个ICMP隧道，因为ICMP包本身是不可靠的，于是需要在ICMP之上写一个可靠协议。一个完整的TCP协议栈显然过于臃肿了（何况也并没有现成的无IO的轮子），所以我就看上了skywind3000大佬的<a target="_blank" rel="noopener" href="https://github.com/skywind3000/kcp">KCP协议</a>——轻量、简洁、代码连我这种网路萌新都看得懂，实在是再好不过了。</p>
<p>一开始是我直接使用原版的C实现+FFI封装，在不开流控的情况下效果不错，但可惜原版的拥塞控制用的是最朴素的TCP Tahoe（作者也表明出于简洁性考虑不准备在标准实现当中使用复杂的流控算法），其在国际网络环境下的表现实在差强人意。想改进，但自己对于自己C的编程水平实在是不抱信心。既然Rust也是性能一流的系统编程语言，我最终还是决定用Rust再写了一个实现。本实现具有以下特点：</p>
<ul>
<li>相较于C实现进行了架构上的些许调整。</li>
<li>在C实现的基础之上，使用链表+滚动数组优化大窗口下的发送性能。</li>
<li>在C实现的基础之上，使用小根堆优化RTO计时器的效率，提升重传性能。</li>
<li>将著名的BBR拥塞控制算法进行一定修改后试验性地运用到KCP中。</li>
</ul>
<h1 id="依赖的包">依赖的包</h1>
<p>为了使编写更加简便，我们的实现依赖以下Rust crates：</p>
<ul>
<li><code>bytes</code>——简便的字节处理（代替原来C实现当中的<code>encode_xxx</code>/<code>decode_xxx</code>）。</li>
<li><code>num_enum</code>——简化Rust枚举与字节的互相转换。</li>
<li><code>derivative</code>——简化一些trait的实现。</li>
<li><code>thiserror</code>——简化错误类型的定义。</li>
<li><code>rand</code>——用于BBR随机相位初始化。</li>
</ul>
<h1 id="架构上的调整">架构上的调整</h1>
<h2 id="常量与配置">常量与配置</h2>
<p>相对于C实现，本实现大幅减少了常量的数量。最后仅剩的常量有五：</p>
<pre class="line-numbers"><code class="language-rust">/// KCP包头大小
const OVERHEAD: u32 = 24;
/// 最大分段
const MAX_FRAGMENTS: u16 = 128;
/// KCP段类型
#[derive(Debug, Clone, Copy, TryFromPrimitive, IntoPrimitive)]
#[repr(u8)]
enum Command &#123;
    Push = 81,
    Ack = 82,
    AskWnd = 83,
    TellWnd = 84,
&#125;
/// BBR各阶段的增益
const BBR_GAIN_CYCLE: [usize; 8] = [5, 3, 4, 4, 4, 4, 4, 4];
/// BDP增益的分母，见后文
const BDP_GAIN_DEN: usize = 1024;</code></pre>
<p>常量少了，变量自然就多了，原来C实现的常量在本实现中成为可配置项：</p>
<pre class="line-numbers"><code class="language-rust">/// 大部分配置的意思如字面
#[derive(Clone, Debug, Deserialize, Derivative)]
#[derivative(Default)]
pub struct Config &#123;
    #[derivative(Default(value = &quot;536&quot;))]
    pub mtu: u32,
    #[derivative(Default(value = &quot;200&quot;))]
    pub rto_default: u32,
    #[derivative(Default(value = &quot;100&quot;))]
    pub rto_min: u32,
    #[derivative(Default(value = &quot;6000&quot;))]
    pub rto_max: u32,
    #[derivative(Default(value = &quot;7000&quot;))]
    pub probe_min: u32,
    #[derivative(Default(value = &quot;120000&quot;))]
    pub probe_max: u32,
    #[derivative(Default(value = &quot;1024&quot;))]
    pub send_wnd: u16,
    #[derivative(Default(value = &quot;1024&quot;))]
    pub recv_wnd: u16,
    #[derivative(Default(value = &quot;40&quot;))]
    pub interval: u32,
    /// 若一个包重传dead_link_thres次后依然失败，则视作底层链路失效。
    #[derivative(Default(value = &quot;20&quot;))]
    pub dead_link_thres: u32,
    /// nodelay模式下, rto_min = 0且rto在重传失败后不指数增长。
    #[derivative(Default(value = &quot;false&quot;))]
    pub nodelay: bool,
    /// stream模式下, 多个数据包可以被合并在同一段内从而减少开销。
    #[derivative(Default(value = &quot;false&quot;))]
    pub stream: bool,
    /// 如果指定，则一个包在fast_resend_thres个在其之后的包ACK之后会直接重传
    #[derivative(Default(value = &quot;None&quot;))]
    pub fast_resend_thres: Option&lt;u32&gt;,
    /// 快速重传的次数上限
    #[derivative(Default(value = &quot;None&quot;))]
    pub fast_resend_limit: Option&lt;u32&gt;,
    /// 是否启用BBR控制算法
    #[derivative(Default(value = &quot;false&quot;))]
    pub bbr: bool,
    /// BBR中RTprop（往返时间）滑动窗口的时间长度（单位：毫秒）
    #[derivative(Default(value = &quot;10000&quot;))]
    pub rt_prop_wnd: u32,
    /// BBR中BtlBw（瓶颈带宽）滑动串口的长度（单位：RTT）
    #[derivative(Default(value = &quot;10&quot;))]
    pub btl_bw_wnd: u32,
    /// BBR中一次RTT/RTprop探测的时间（单位：RTT），减少该值可以减轻RTT探测对于流量的影响。
    #[derivative(Default(value = &quot;200&quot;))]
    pub probe_rtt_time: u32,
    /// BDP增益，见后文
    #[derivative(Default(value = &quot;1024&quot;))]
    pub bdp_gain: usize,
&#125;

impl Config &#123;
    pub fn mss(&amp;self) -&gt; usize &#123;
        (self.mtu - OVERHEAD) as usize
    &#125;
&#125;

impl ControlBlock &#123;
    pub fn new(conv: u32, config: Config) -&gt; ControlBlock &#123;
        ...
    &#125;
&#125;</code></pre>
<h2 id="异常类型">异常类型</h2>
<p>KCP原本的C实现仅使用负数表达异常值，虽简介但其含义并不明晰，在本实现中我们对于异常进行了清晰定义：</p>
<pre class="line-numbers"><code class="language-rust">#[derive(Debug, Error)]
pub enum Error &#123;
    #[error(&quot;packet to be sent too large to be fragmented&quot;)]
    OversizePacket,
    #[error(&quot;incomplete KCP packet&quot;)]
    IncompletePacket,
    #[error(&quot;invalid KCP command: &#123;0&#125;&quot;)]
    InvalidCommand(u8),
    #[error(&quot;empty queue (try again later)&quot;)]
    NotAvailable,
    #[error(&quot;wrong conv. (expected &#123;expected&#125;, found &#123;found&#125;)&quot;)]
    WrongConv &#123; expected: u32, found: u32 &#125;,
&#125;

pub type Result&lt;T&gt; = std::result::Result&lt;T, Error&gt;;</code></pre>
<p>以上异常类型还有更精确的空间，但是目前应该已经堪堪够用了。</p>
<h2 id="发包方式">发包方式</h2>
<p>在原来的C实现在发包时直接调用callback，其优点是简洁，但其缺点在于callback的运行时间不定以及异常处理不明对运行产生的影响。<del>何况在Rust当中安全存储callback需要和borrow checker拼命。</del>在本实现中，我们将flush出去的包暂存在一个队列中，然后通过外部不断poll的方式拉出去。一方面，主动poll的方式和底层收到包时的push呼应；另一方面，这有助于分离底层发包和KCP逻辑本身，是“<a target="_blank" rel="noopener" href="https://sans-io.readthedocs.io/">无IO/Sans IO</a>”理念的一种体现。缺点是缓存队列可能会膨胀得厉害。当中tradeoff见仁见智。</p>
<pre class="line-numbers"><code class="language-rust">impl ControlBlock &#123;
    ...
    /// 底层收包push
    pub fn input(&amp;mut self, mut data: &amp;[u8]) -&gt; Result&lt;usize&gt; &#123; ... &#125;
    /// 底层发包poll
    pub fn output(&amp;mut self) -&gt; Option&lt;Vec&lt;u8&gt;&gt; &#123; ... &#125;
&#125;</code></pre>
<h2 id="去除check和update">去除<code>check</code>和<code>update</code></h2>
<p>这是一个比较大胆的改动，未必适合所有情形。去除的原因是在数据结构的优化下计算重传、更新发送窗口的开销大幅度减小，已经可以在每一次调用<code>input</code>和<code>send</code>的时候进行一次，没有必要去不断<code>check</code>再<code>update</code>。上层只需要按照固定的时间间隔调用<code>flush</code>就行了。我进行这样的设计是为了简化上层的代码，而且我的应用情形恰好是高流量的反正都要一直<code>flush</code>，也无所谓。</p>
<p><code>flush</code>的代码也其实很简单：</p>
<pre class="line-numbers"><code class="language-rust">pub fn flush(&amp;mut self) &#123;
    self.sync_now(); // 更新now
    self.flush_probe(); // 更新窗口探测
    self.flush_push(); // 计算重传以及更新发送窗口
    self.flush_ack(); // 发ACK
    if !self.buffer.is_empty() &#123;
        let mut new_buf = Vec::with_capacity(self.config.mtu as usize);
        std::mem::swap(&amp;mut self.buffer, &amp;mut new_buf);
        self.output.push_back(new_buf);
    &#125;
&#125;</code></pre>
<p>既然<code>sync_now</code>、<code>flush_push</code>在<code>input</code>和<code>send</code>当中都可以廉价地调用，那为什么还需要不断<code>check</code>再<code>update</code>呢？直接调用<code>flush</code>了事。</p>
<p>如果要参考有<code>check</code>和<code>update</code>的实现，可以参照<a target="_blank" rel="noopener" href="https://github.com/alan20210202/ekho/blob/caaeb5f55d/src/kcp.rs">早些时候的commit</a>。</p>
<h1 id="窗口数据结构的改进">窗口数据结构的改进</h1>
<p>KCP原版的实现中发送/接收的队列/窗口全部使用队列作为数据结构，这固然使得代码变简单了，但也一定程度上降低了性能：在队列中查找KCP段最差需要线性时间，这在某些情形下未必是最优的。在本实现中，我们优化数据结构，以最优的复杂度实现发送/接受窗口需要的若干操作：</p>
<ul>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>以分段的序号为键查找分段。</li>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>插入分段。</li>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>以分段的序号为键查找分段。</li>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>以分段的序号为键删除分段。</li>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>查询/弹出最早插入的分段（在发送窗口中，最早插入的分段自然是序号最小的分段）。</li>
<li><span class="math inline">\(\mathcal{O}(k)\)</span>遍历以插入顺序为序，某分段的所有<span class="math inline">\(k\)</span>个前驱（在发送窗口中，分段插入顺序即序号顺序，因此该操作可直接用于快速重传的计算）。</li>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>查询大小。</li>
</ul>
<p>考虑到任何时刻窗口内分段序号之差不会大于窗口大小这一常数，符合上述要求的数据结构就可以用链表+滚动数组高效实现。代码不长，百行左右：</p>
<pre class="line-numbers"><code class="language-rust">struct Element&lt;T&gt; &#123;
    /// 前驱下标
    prev: usize,
    /// 后继下标
    next: usize,
    data: T,
&#125;

pub struct Window&lt;T&gt; &#123;
    size: usize,
    entry: Vec&lt;Option&lt;Element&lt;T&gt;&gt;&gt;,
    end: Option&lt;usize&gt;,
    len: usize,
&#125;

impl&lt;T&gt; Window&lt;T&gt; &#123;
    pub fn with_size(size: usize) -&gt; Self &#123;
        Self &#123;
            size,
            entry: (0..size).map(|_| None).collect(),
            end: None,
            len: 0,
        &#125;
    &#125;

    pub fn is_empty(&amp;self) -&gt; bool &#123;
        self.end.is_none()
    &#125;

    pub fn get_mut(&amp;mut self, index: usize) -&gt; Option&lt;&amp;mut T&gt; &#123;
        match self.entry[index % self.size].as_mut() &#123;
            Some(elem) =&gt; Some(&amp;mut elem.data),
            None =&gt; None,
        &#125;
    &#125;

    pub fn push(&amp;mut self, index: usize, data: T) &#123;
        let index = index % self.size;
        if self.entry[index].is_some() &#123;
            return;
        &#125;
        self.entry[index] = Some(match self.end &#123;
            Some(prev) =&gt; &#123;
                let prev_elem = self.entry[prev].as_mut().unwrap();
                let next = prev_elem.next;
                prev_elem.next = index;
                self.entry[next].as_mut().unwrap().prev = index;
                Element &#123; prev, next, data &#125;
            &#125;
            None =&gt; Element &#123; prev: index, next: index, data &#125;,
        &#125;);
        self.end = Some(index);
        self.len += 1;
    &#125;

    pub fn remove(&amp;mut self, index: usize) -&gt; Option&lt;T&gt; &#123;
        let index = index % self.size;
        let elem = self.entry[index].take()?;
        let (prev, next) = (elem.prev, elem.next);
        self.entry[index] = None;
        self.len -= 1;
        if index == self.end.unwrap() &#123;
            if prev == index &#123;
                self.end = None;
                return Some(elem.data);
            &#125; else &#123;
                self.end = Some(prev);
            &#125;
        &#125;
        self.entry[prev].as_mut().unwrap().next = next;
        self.entry[next].as_mut().unwrap().prev = prev;
        Some(elem.data)
    &#125;

    pub fn front(&amp;self) -&gt; Option&lt;&amp;T&gt; &#123;
        self.end.map(|end| &#123;
            let head = self.entry[end].as_ref().unwrap().next;
            &amp;self.entry[head].as_ref().unwrap().data
        &#125;)
    &#125;

    pub fn pop_unchecked(&amp;mut self) -&gt; T &#123;
        let end = self.end.unwrap();
        let head = self.entry[end].as_ref().unwrap().next;
        self.remove(head).unwrap()
    &#125;

    pub fn len(&amp;self) -&gt; usize &#123;
        self.len
    &#125;

    pub fn for_preceding(&amp;mut self, index: usize, mut action: impl FnMut(&amp;mut T)) &#123;
        let mut index = index % self.size;
        index = match self.entry[index].as_ref() &#123;
            Some(elem) =&gt; elem.prev,
            None =&gt; return,
        &#125;;
        while index != self.end.unwrap() &#123;
            let elem = self.entry[index].as_mut().unwrap();
            action(&amp;mut elem.data);
            index = elem.prev;
        &#125;
    &#125;
&#125;</code></pre>
<p>因为滚动数组是连续空间，在内存布局上相较于链表对于缓存更加友好，所以速度应该还可以再快一点。唯一的不足是<code>unwrap</code>有点多看着心惊肉跳，并且用指针可能会比用下标快一丁点，但是用Rust写数据结构大约就是这个尿性。</p>
<p>有这个打底，窗口大小开到8192实测是一点问题都没有的，更大的没试过。</p>
<p>但KCP的设计本质上是不适合大流量的，因为快速重传无论如何优化数据结构最坏的线性复杂度就在那里无法消除，除非可以限制快速重传向后看的范围，但后者又削弱了快速重传的意义与效用。</p>
<h1 id="重传计时器的改进">重传计时器的改进</h1>
<p>原版的KCP实现在<code>check</code>的时候需要遍历发送窗口来确定最近的重传时间，在<code>flush</code>的时候又要遍历才能重传，这在窗口较大的时候显然是比较吃性能的。原作者记得在issues里的讨论中提过可以用时间轮进行优化。诚然，时间轮是最好的方案，但是实现起来较为复杂。因此，本实现使用借助Rust的标准库实现起来相对简单的小根堆进行优化：</p>
<pre class="line-numbers"><code class="language-rust">use std::cmp::Reverse;
use std::collections::BinaryHeap;

pub struct Timer(BinaryHeap&lt;Reverse&lt;u64&gt;&gt;);

impl Timer &#123;
    pub fn with_capacity(capacity: usize) -&gt; Self &#123;
        Self(BinaryHeap::with_capacity(capacity))
    &#125;

    pub fn schedule(&amp;mut self, ts: u32, sn: u32) &#123;
        self.0.push(Reverse(((ts as u64) &lt;&lt; 32) | sn as u64));
    &#125;

    /// 获取截止到now发生的 一个 事件，应该重复调用
    pub fn event(&amp;mut self, now: u32) -&gt; Option&lt;(u32, u32)&gt; &#123;
        let key = (now as u64 + 1) &lt;&lt; 32;
        match self.0.peek() &#123;
            Some(&amp;Reverse(val)) if val &lt; key =&gt; &#123;
                let sn = val &amp; (u32::max_value() as u64);
                let ts = val &gt;&gt; 32;
                self.0.pop();
                Some((ts as u32, sn as u32))
            &#125;
            _ =&gt; None,
        &#125;
    &#125;
&#125;</code></pre>
<p>计时器只需要存时间和分段序号即可。调用的代码如下：</p>
<pre class="line-numbers"><code class="language-rust">fn flush_push(&amp;mut self) &#123;
    // ... 省去流控以及把队列里的分段加入发送窗口的部分
    let mut send_buf = std::mem::take(&amp;mut self.send_buf);
    while let Some((ts, sn)) = self.timer.event(self.now) &#123;
        if sn &lt; self.send_una || sn &gt;= self.send_nxt &#123;
            continue; // 分段被ACK于是不在发送窗口里了，自然跳过
        &#125;
        if let Some(seg) = send_buf.get_mut(sn as usize) &#123;
            if ts == seg.ts &#123;
                seg.ts = self.prepare_send(seg); // 更新RTO并计算下一次重传的时间
                seg.ts_last_send = ts;
                self.dead_link |= seg.sends &gt;= self.config.dead_link_thres;
                self.flush_segment(Command::Push, seg.frg, seg.sn, ts, seg.payload.len());
                self.buffer.extend_from_slice(&amp;seg.payload);
                self.timer.schedule(seg.ts, seg.sn); // 安排下一次重传
            &#125;
        &#125;
    &#125;
    self.send_buf = send_buf;
&#125;</code></pre>
<p>由于查看小根堆堆顶是<span class="math inline">\(\mathcal{O}(1)\)</span>的，因此在没有重传的时候<code>flush_push</code>的开销确实很小。足以在<code>input</code>和<code>send</code>时都调用一次。真的要重传时，更新小根堆的时间复杂度也是对数级别的，这就给去除<code>check</code>和<code>update</code>提供了基础。</p>
<h1 id="bbr">BBR</h1>
<p>最后的改进是用BBR取代了KCP原版实现中朴素的基于丢包的流控算法。</p>
<p>我试图参照<a target="_blank" rel="noopener" href="https://research.google/pubs/pub45646/">原论文</a>实现BBR，但因为计时精度的问题packet pacing是做不到了。实现的部分有</p>
<ul>
<li>基于单调队列的滑动窗口BtlBw max-filter。</li>
<li>基于单调队列的滑动窗口RTprop min-filter。</li>
<li>BBR状态机。</li>
<li>基于以上三者计算inflight limit进行流控。</li>
</ul>
<p>和BBR有分歧的一点在于在ProbeRTT状态采用BDP的一半作为拥塞窗口而不是原文的4个包。</p>
<p>此外，本实现只对只传输一次的分段计算BBR的各项参数，如RTT，带宽，更新各个filter等。原因是实际上大部分的分段都在看到包头的UNA之后就被ACK掉了而不是被单独的ACK包ACK的。ACK包带有分段的序号与时间戳，所以可以清楚知道ACK的是哪一次传输，但被UNA ACK掉的就不清楚，唯一的例外是分段只被传输了一次。如果对于多次传输的包仍然直接计算BBR，那么万一ACK恰好在重传之后到达，那么误算出的RTT就非常小，导致RTprop非常小，进而BDP非常小，整个BBR就堵住了。诚然，可以把每一次传输的时间戳都存起来，然后在被UNA时选择最接近<code>now - srtt</code>的传输，但这就增加了代码的复杂度。考虑到丢包的毕竟是少数，如此未必会有特别大的优势（实现这个的代码在这个<a target="_blank" rel="noopener" href="https://github.com/alan20210202/ekho/blob/01b1d72b7e/src/kcp.rs">commit</a>，也可作为参考）。</p>
<p>实测效果还行。一个比较重要的问题是在间歇性<code>flush</code>的情况下对于带宽的计算并不准确甚至有低估的倾向，往往导致BDP过于保守，即使ProbeBW状态有一个1.25x的激进phase也解决不了问题。我想到的一个解决方案是将拥塞窗口不是简单的设置为BDP，而是乘上一个增益，也就是配置里面的<code>bdp_gain</code>。为了避免浮点数运算，<code>bdp_gain</code>使用1024为基数。一般来说设置成1280就差不多了——其实就是主动创造轻微的拥塞来确保占有带宽。这对于其他的TCP连接固然有些不公平的，是否采用见仁见智。</p>
<h1 id="真背景">真·背景</h1>
<p>其实一开始，只是为了编译的时候能够不带着<code>unsafe</code>和C编译器而选择把原版实现移植到Rust，当时代码大部分几乎一模一样。</p>
<p>后来引入BBR魔改了一回。</p>
<p>为了代码更Rust魔改了一回。</p>
<p>再后来做配置分离魔改了一回。</p>
<p>再后来数据结构优化又魔改了一回。</p>
<p>来来回回地改，到最后除了架子还和原版实现相似，内部的代码已经大变样了。</p>
<p>但是在ICMP隧道上试验下来仍然不是最令人满意，CPU占用仍然不少，带宽仍然不能跑满，goodput仍然不高。</p>
<p>我不知道是我应用层以及底层的代码写的有问题，还是KCP本身就不是很适合高流量大窗口的应用场景。</p>
<p>或许二者兼有之？</p>
<p>前两天突然想起了QUIC，找了一下，Cloudflare有一个优秀的QUIC实现，是Rust的，而且是Sans IO的。大概QUIC才是最适合我的应用情形的吧。我准备这几天试验一下。</p>
<p>或许之后就转QUIC了呢？（笑）</p>
<p>那我魔改的KCP就放在这吃灰？</p>
<p>于是乎，就有了这篇文章。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/11/25/Wallis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/25/Wallis/" class="post-title-link" itemprop="url">数学课划水整活之Wallis乘积公式的一种证明</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-25 17:06:04" itemprop="dateCreated datePublished" datetime="2020-11-25T17:06:04+08:00">2020-11-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-16 13:07:26" itemprop="dateModified" datetime="2021-03-16T13:07:26+08:00">2021-03-16</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>今天数学课讲了一点组合数的性质，因为太简单了所以稍微划了一会水。</p>
<p>结果发现自己整出来了一个算<span class="math inline">\(\pi\)</span>的式子？</p>
<p>化简以后发现是传说中的Wallis公式？</p>
<p>虽然原理一样的证明Wiki上有提到但是还是当场惊了。</p>
<p>简单记一笔吧。</p>
<p>一切的开端是今年寒假做夏校申请的时候证明过的一个极限 <span class="math display">\[
\lim_{n\to\infty} 2^{-2n}\binom{2n}{n} = 0
\]</span> 当时是用斯特林近似暴力代换进行证明（现在看来并不严谨） <span class="math display">\[
\begin{aligned}
    \lim_{n\to\infty} \binom{2n}{n} \frac{\left[\sqrt{2\pi n} \left(n \over e\right)^n \right]^2} {\sqrt{4\pi n} \left(2n \over e\right)^{2n}} &amp;= \lim_{n\to\infty} \left[\frac{\sqrt{2\pi n} \left(n \over e\right)^n}{n!}\right]^2 \frac{(2n)!}{\sqrt{4\pi n} \left(2n \over e\right)^{2n}} \\
    &amp;= 1 \\     
    \Rightarrow 
    \lim_{n\to\infty} 2^{-2n}\binom{2n}{n} &amp;= \lim_{n\to\infty} 2^{-2n}\frac {\sqrt{4\pi n} \left(2n \over e\right)^{2n}}{\left[\sqrt{2\pi n} \left(n \over e\right)^n\right]^2} \cdot \lim_{n\to\infty} \binom{2n}{n} \frac{\left[\sqrt{2\pi n} \left(n \over e\right)^n\right]^2} {\sqrt{4\pi n} \left(2n \over e\right)^{2n}} \\
    &amp;=  \lim_{n\to\infty} 2^{-2n}\frac {\sqrt{4\pi} 2^{2n}n^{2n+\frac{1}{2}}e^{-2n}}{2\pi n^{2n+1}e^{-2n}} \\
    &amp;= \lim_{n\to\infty} \frac{1}{\sqrt{\pi n}}\\
    &amp;= 0
\end{aligned}
\]</span> 今天划水的时候发现由以上过程，这个极限可以加强为 <span class="math display">\[
\lim_{n\to\infty} \frac{\sqrt{\pi n}\binom{2n}{n}}{2^{2n}} = 1
\]</span> 稍作整理即得 <span class="math display">\[
\lim_{n\to\infty} \frac{2^{4n}}{n\binom{2n}{n}^2} = \pi
\]</span> 拿卡西欧摁了一下，发现式子没有假，虽然收敛得有亿点点慢但确实是收敛到了<span class="math inline">\(\pi\)</span>。</p>
<p>关键是这个式子我似乎没见过啊？<del>内心直接膨胀，可把我牛逼坏了。</del></p>
<p>因为形式看起来较复杂，接着我就想可不可以通过邻项作比的方式变换一下形态 <span class="math display">\[
\begin{aligned}
\frac{2^{4n}}{n\binom{2n}{n}^2} \Bigg / \frac{2^{4(n-1)}}{(n-1)\binom{2n-2}{n-1}^2} &amp;= \frac{16(n-1)}{n} \left[\binom{2n-2}{n-1} \bigg/ \binom{2n}{n}\right]^2 \\
&amp;= \frac{16(n-1)}{n} \left[\frac{n^2}{2n(2n-1)}\right]^2 \\
&amp;= \frac{16n(n-1)}{(4n-2)^2} \\
&amp;= \frac{2n}{2n-1}\cdot \frac{2n-2}{2n-1}
\end{aligned}
\]</span> 这个形式似曾相识，结合上式把式子化为连乘积的形式，要素察觉！ <span class="math display">\[
\begin{aligned}
\frac{2^{4n}}{n\binom{2n}{n}^2} &amp;= \frac{2^{4}}{1\binom{2}{1}^2} \cdot \frac{2}{3} \cdot \frac{4}{3} \cdot \frac{4}{5} \cdot \frac{6}{5} \cdots \frac{2n-2}{2n-1}\cdot \frac{2n}{2n-1} \\
&amp;= 4\cdot \frac{2}{3} \cdot \frac{4}{3} \cdot \frac{4}{5} \cdot \frac{6}{5} \cdots \frac{2n-2}{2n-1}\cdot \frac{2n}{2n-1}
\end{aligned}
\]</span> 这不就是Wallis乘积公式嘛？翻出Wikipedia一看： <span class="math display">\[
\begin{aligned}
\frac{\pi}{2} &amp;=\prod_{n=1}^{\infty} \frac{4 n^{2}}{4 n^{2}-1}=\prod_{n=1}^{\infty}\left(\frac{2 n}{2 n-1} \cdot \frac{2 n}{2 n+1}\right) \\
&amp;=\left(\frac{2}{1} \cdot \frac{2}{3}\right) \cdot\left(\frac{4}{3} \cdot \frac{4}{5}\right) \cdot\left(\frac{6}{5} \cdot \frac{6}{7}\right) \cdot\left(\frac{8}{7} \cdot \frac{8}{9}\right) \cdots
\end{aligned}
\]</span> 完全一致，直接得证。</p>
<p>哇，也就是说我划着水就把Wallis公式不严谨地整了一遍？</p>
<p><em>果然还是要膨胀.jpg</em></p>
<p>以前觉得这个式子很高端的，现在有种莫名的幻灭感。</p>
<p>但是写到这的时候多看了一眼，发现斯特林逼近的一个推导里用到了Wallis公式？</p>
<p>突然有点不确定这算不算是循环论证了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/08/28/Minecraft%20ILP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/28/Minecraft%20ILP/" class="post-title-link" itemprop="url">Designing Computational Redstone Circuits Automatically in Minecraft with Integer Programming: Preliminary Thoughts and Tests</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-28 13:48:50" itemprop="dateCreated datePublished" datetime="2020-08-28T13:48:50+08:00">2020-08-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-25 17:05:52" itemprop="dateModified" datetime="2020-11-25T17:05:52+08:00">2020-11-25</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>UNFINISHED ARTICLE -- WORK IN PROGRESS</strong></p>
<p><strong>UNFINISHED ARTICLE -- WORK IN PROGRESS</strong></p>
<p><strong>UNFINISHED ARTICLE -- WORK IN PROGRESS</strong></p>
<p>This was a project I worked on two months ago, but it wasn't until now that I have the time to write it down and share it on my blog.</p>
<h1 id="intro">Intro</h1>
<p>Redstone has been a core element in the game Minecraft for quite some years. It is presumably the most untrivial one as well: while anyone could master nearly all Minecraft mechanics through experiences, it takes not only experience but also ingenuity to design a good redstone circuit. Few of us are bold enough to claim "I master redstone", even after playing Minecraft for a decade.</p>
<p>So here comes the question: <strong>Can the design of redstone circuits, the core of Minecraft automations, be automated?</strong> and <strong>If so, how?</strong> (appreciate how meta this is :)</p>
<p>Theoretically, the answer is "yes...but". Minecraft has a finite world, and each position has a finite number of possible blockstates. We can write a program to enumerate all possible placements of blocks until we find some placement corresponding to the desired redstone circuit. However, this needs exponential time and we may need to wait for a century before it could give us, for instance, a decent piston door. Moreover, if a circuit involves manipulation of entities (which could have infinite many states), then we are easily screwed.</p>
<p>Well, perhaps it is difficult to let a program design any redstone circuit. But there is indeed a subset of redstone circuits whose design can very likely be automated -- <strong>computational redstone circuits</strong>, aka. logic gates, calculators, CPUs etc. Why? Because software that design their real world electronic counterparts are readily available -- they are called "EDA".</p>
<p>As a high school student I, of course, know little about the inner workings of real-world EDA applications (and there doesn't seem to be a lot of resources out there). I am convinced that this problem is NPC (further articulated below), so designing an efficient polytime combinatorial algorithm doesn't seem plausible. That said, what about reducing this problem to some other NPC problems which we can solve relatively quickly with optimized algorithms / heuristics -- say, ILP? This is what I am trying to do here.</p>
<h1 id="formulating-the-problem">Formulating the problem</h1>
<p>"Designing computational redstone circuit automatically" is a vague idea, so it is necessary that we know what this truly means.</p>
<h2 id="whats-the-input">What's the input?</h2>
<p>The input should describe the intended functionality of a circuit. Recall how we usually describe a circuit: we draw a <strong>circuit diagram</strong>. I here characterize a redstone circuit diagram by the assumptions and constraints below:</p>
<ol type="1">
<li>A circuit contains two parts: <strong>wires and components</strong>.</li>
<li>Components are the <strong>primitives</strong> of a circuit. E.g. A torch or a wire junction.</li>
<li>A component has <strong>interfaces</strong>, either <strong>in or out</strong>, as where the component receives signals from and sends signals to.</li>
<li>A wire connects <strong>an</strong> out-interface from a component ("source") to <strong>an</strong> in-interface of another component ("target").</li>
<li>Wires are <strong>directed</strong>.</li>
<li>Components are <strong>independent</strong>. i.e. they do not interfere with other components in any way other than being connected by wires from interfaces.</li>
</ol>
<p>A circuit diagram can be represented in a directed graph, with components as vertices and wires as edges. Source/target interfaces as extra information stored on edges.</p>
<h2 id="whats-the-output">What's the output?</h2>
<p>We want our program to tell us how the circuit we described in the input can be built in the Minecraft world. Therefore, we could define the the output to be a set of position - blockstate pairs, (which, in implementation, can be stored in a schematic file).</p>
<p>However, we don't want to jump straight from a circuit diagram to a detailed Minecraft schematic because that means taking interference between components, quasi connectivity, update order -- basically everything that makes redstone engineering complex -- into consideration in the first place.</p>
<p>Instead, we could first build our circuit in an <strong>ideal world</strong>, in which we forget about all those factors above, and then convert the ideal placement into an actual Minecraft schematic.</p>
<p>What's an idea world?</p>
<ol type="1">
<li>A circuit consists of multiple ideal blocks.</li>
<li>A component fully occupies a set of ideal blocks, some of which are its interfaces. How many and which blocks a certain type of component occupies depend on its size in Minecraft and how we plan to convert the ideal placement to a real schematic.</li>
<li>A wire is a chain of blocks, where any adjacent two share a face. The first block is always the source interface and the last is always the target interface.</li>
<li><strong>Exclusiveness: </strong>All components and all wires (ignoring their first and last block) mustn't overlap.</li>
<li><strong>Mutual Independence: </strong>Unless both blocks are occupied by the same component / wire, anything in two adjacent cells do not interfere with each other.</li>
<li>Wire junctions are special components and are exceptions to rule 2 and 3. A wire junction always have three interfaces (1 in &amp; 2 outs, or 2 ins &amp; 1 out). Multiple junctions can overlap and they can overlap with an interface of some component.</li>
<li>There are times when we want to fix the location of some components in the input. These components are usually just placeholders that mark the position of IO. (We don't want to produce a circuit with an unreachable input/output in the center of everything else, right?)</li>
</ol>
<h2 id="the-objective">The Objective</h2>
<ol type="1">
<li>The circuit represented by the output must have the same functionality as described by the input circuit diagram.</li>
<li>The delay of the circuit should be minimized.</li>
</ol>
<h2 id="example-the-and-gate">Example: the AND gate</h2>
<p>Let's see how we design a simple AND gate.</p>
<p>Suppose the only primitive components we have are NOT gate (torch), wire junction, and IO placeholder. The circuit diagram of AND gate is:</p>
<p><img src="ANDCD.svg" /></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/08/20/NOI%202020/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/20/NOI%202020/" class="post-title-link" itemprop="url">蒟蒻的NOI 2020退役记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-08-20 16:23:58 / 修改时间：16:18:17" itemprop="dateCreated datePublished" datetime="2020-08-20T16:23:58+08:00">2020-08-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="day--1">Day -1</h1>
<p>在中午太阳晒得最狠的时候到了学校。宿舍爬楼累死人，也不知道为啥学校楼要建那么高。幸好宿舍里的空调给力，好评。</p>
<p>宿舍的环境还行。个人觉得比当年WC2018的要好。</p>
<p>信号出奇地差，必须在直接靠窗的地方才有4G，不然连2G也别想收到，听宿管和小卖部阿姨说当初就是设计成这个样子的。差评。</p>
<p>插座很多好评。</p>
<p>但是还是没有桌子，无论用什么姿势看电脑都贼难受。同寝室的jtl带了一个床上架的桌子，看了直呼内行。床板贼硬，差评。</p>
<p>伙食还可以，豆浆我觉得挺好喝的，就是湖南菜多多少少带点辣个人不是很能接受，而且菜很细碎的样子。</p>
<p>睡前随随便便背了点笔试题。</p>
<h1 id="day-0">Day 0</h1>
<p>早上迷迷糊糊地去参加了开幕式。听到dzd说有剩饭扣1分大惊。其他就没啥印象了=_=。</p>
<p>结束后拱火mr押题，mr说看到才艺表演一个跳舞的转来转去暗示会考平衡树，一本正经胡说八道.jpg。</p>
<p>感觉周围大佬都贼多，互相之间也都认识，我一个蒟蒻在当中不知所措。自己看来对于在竞赛圈内的信息闭塞的可以。</p>
<p>中午又背了一会笔试题，然后下午就去试机了。笔试没有想象中的难，但是确实是有超纲的，纠结了很久。幸好最后还是满分飘过了。唯一值得吐槽的或许是CCF十年不变的远古测评系统。</p>
<p>随后在试机场上敲了一波LCT和FFT。看到jtl在写MTT有想敲三模数的冲动但是最后的合并调了好一会才勉强调出来，于是就很慌。</p>
<p>晚上寝室里大家都在欢快地打板子。对面两个人都在打带花树，然后惊奇地发现带花树的代码似乎也没有想象中那么长。三个人讨论了一下觉得似乎有概率考分块的样子，但是笑一笑也就过去了。我自己把各种字符串的算法全部过了一遍。</p>
<h1 id="day-1">Day 1</h1>
<p>看到T1愣了好一会，愣是没有第一时间看出DP。不知道为什么当时满脑子都是Tarjan和缩点然后沿着这个方向陷入了死胡同。于是先敲了一个DFS，觉得自己要完蛋。</p>
<p>看了T2又愣了一会，先敲了个暴力，然后觉得<span class="math inline">\(m\)</span>比较小的情况可以动态维护链并+容斥解决。先放着。</p>
<p>看到T3深切地感受到这或许是个数据结构毒瘤？先敲了一个二维树状数组的暴力。当时脑子大概是坏掉了不是枚举矩形直接算而是枚举点算贡献。总之暴力复杂度似乎<span class="math inline">\(\mathcal O(nm\log^2 n)\)</span>非常差。然后认真思考了一下部分分，发现可以莫队。于是基于二维树状数组写了一个<span class="math inline">\(\mathcal O\left(n\sqrt m \log^2 n\right)\)</span>的算法。然后觉得<span class="math inline">\(\mathcal O(\log ^2n)\)</span>的二维数点不妥，改成了<span class="math inline">\(\mathcal O(\log n)\)</span>的可持久化线段树，于是暴力和莫队的复杂度都少了一个<span class="math inline">\(\log\)</span>。再一看发现莫队我可以用树状数组干嘛要二维数点，于是莫队的常数又降下来一点。瞄了一眼后面觉得应该可以用<span class="math inline">\(\mathcal O(n^{7/4})\)</span>的四维莫队，可惜当初没认真学高维莫队不知道块大小咋算了，于是作罢。最后敲了一个莫队和暴力的对拍放着。</p>
<p>回到T2开始敲树剖和容斥，写了一个<span class="math inline">\(\mathcal O\left(m2^m\log^2n\right)\)</span>的算法。和暴力结合在一起觉得至少能拿<span class="math inline">\(32\)</span>分，常数小一点也可以冲冲<span class="math inline">\(40\)</span>样子。</p>
<p>然后回到T1，突然发现这不就一个裸的DP吗，直骂自己前面傻逼。于是花5分钟敲完朴素DP，然后再花10分钟敲完环的部分分。</p>
<p>然后发现边权至多为<span class="math inline">\(5\)</span>，意识到正解显然是用max-plus algebra下的矩阵快速幂进行优化，于是开始敲。此时离考试结束还有60分钟，心中贼慌。等到敲完离考试结束还有30分钟，心态爆炸，然后死活调不出来。只能把这个正解例程写在程序里作为最后之选。离交卷还有5分钟的时候不改了。检查其他两题的程序无误后就开始坐着怀疑自己前三个小时脑子到底在想什么……</p>
<p>出考场觉得自己已经成为了时代的眼泪（笑）。</p>
<p>下午三点去查分。听jtl说这次CCF准时出分没有咕简直是奇迹。结果就是<span class="math inline">\(50+32+40=122\)</span>。和预想的完全一致。这个时候就很后悔。如果当初早点看出矩阵快速幂把T1的正解调出来就好了。这个分觉得铁牌已经在向我招手。</p>
<p>晚上讲题。T1的确是快速幂正解。T2的正解是线段树合并维护树形DP这个之前也在寝室里有了大概的想法，但是一看这个DP的状态设计果然神仙。出题人怒斥了我们打<span class="math inline">\(32\)</span>分树剖暴力的，说是什么数据结构学傻了……然后说写个虚树不就<span class="math inline">\(40\)</span>了吗。我下面听着就很无语：我也想打虚树，但是我不会啊…… T3的出题人原来就是各种OJ上人们一直吐槽的lxl。这个题目的内部名称似乎叫“第十三分块”？正解似乎是先建一个树套树然后再分治再分块……讲到一半就lost了，内心大骂出题人毒瘤。</p>
<p>回寝室后所有人都是颓废的状态，gyc在打Splay的板子。剩下我们两个人开始摸鱼。</p>
<h1 id="day-2">Day 2</h1>
<p>T1一看给人一种网络流的既视感，然后发现图建不出来。退而求其次试图写出线性规划进行代数化建图，发现线性规划必须使用Big M的办法才能建出来，而且直观一看integrity gap大的离谱是不可能建图的。因为是求可行解也不知道目标函数咋写，所以也不能从对偶下手，只能作罢。敲了一个非常粗暴的DFS暴力枚举每道菜用哪两个原材料分别用多少，发现这个DFS在最坏情况下跑得巨慢无比——难不成我暴力骗分都不成？</p>
<p>这个时候有了一个乱搞的intuition，就是枚举原料的排列然后按照排列来确定所用的原料。然后发现过不了样例，于是作罢。</p>
<p>之后稍微改进了一点暴力，只枚举每道菜用哪两个原材料，最后时候用多少最后用网络流来判。这下终于拿到了<span class="math inline">\(15\)</span>分的暴力。顺便基于这个敲了一个随机化，但是似乎表现也不佳的样子。</p>
<p>T2题面长度属实劝退。读完题面之后觉得似乎不是很可做。看了样例之后有了一点暴力的想法，写了一个复杂度为<span class="math inline">\(\mathcal O\left(2^{2^{h_{\text{max}}-1}}\right)\)</span>的算法。简单来说就是把输入的树补成最大树高然后枚举能否扩张成最大树高下的所有可能的二叉树形态。觉得除了<span class="math inline">\(12\)</span>分纯暴力还可以拿<span class="math inline">\(h_{\text{max}}=4\)</span>的分？之后就不会了。</p>
<p>T3一看给我整懵了。可真就暴力不会写呗。直觉上似乎可以写Dijkstra然后在转移的时候排除掉当前路径下的割边。但是很快意识到Dijkstra的本质是DP而这个转移方案是有后效性的。事实上也是如此，样例都没有过。然后试验性地写了一个不可行的判定方法：求出最短路，如果把最短路去掉之后全图不连通，则不可行——也不知道这样对不对。</p>
<p>5个小时就在三个题目的来回懵逼当中度过。</p>
<p>这次CCF出分直接咕了将近两个小时。我们很明智地从一开始就待在寝室里，那些下去等分的就苦逼了。分数出来是<span class="math inline">\(15+12+5=32\)</span>、也差不多是我预想的这个水平，T2树高为<span class="math inline">\(4\)</span>的点我还是超时了，大概还是没有判同构去重的原因？</p>
<p>下午去听讲题。T1正解的思路源于<span class="math inline">\(m=n-1\)</span>的思考，其他的情况都是向<span class="math inline">\(m=n-1\)</span>情况的规约，感觉是非常巧妙的。T2的最优算法居然是线性的？有点听蒙了。听到T3讲解的时候才意识到T3当中的图叫做弦图，而正解源于对于弦图性质的思考，最后用过两次类Dijkstra来解决，感觉是非常非常神奇，不明觉厉，自愧不如。</p>
<p>讲的时候就出榜了，一看果然Cu，心情复杂，但是一开始也没有期望，所以也没有太沮丧。感觉心态真正崩盘的大概是jtl，人家Cu第一……差一分就Ag了。但是看榜还是有<span class="math inline">\(500\)</span>分以上的，觉得这些人真的很厉害。我或许不比他们笨，但是他们确实历练的比我这种多多了。我这种常年边缘划水的OIer果然不能和这些人比。</p>
<h1 id="day-3">Day 3</h1>
<p>看着手中的铜牌，意识到自己划水的OI之路至少到此为止暂时地画上了句号，颇有些不真实感。</p>
<p>我一直在想，如果D1T1的正解我调出来了，我就是Ag了，会不会好一点呢？但是这终究也只是一个幻想而已罢了。一是比赛不能重来，二是我似乎也不知道缓存矩阵乘方的套路所以真写快速幂有可能复杂度还是会炸的样子。</p>
<p>一如既往，自己复习的算法完美地和考试算法错开了。没有LCT，没有FFT，没有字符串。我深切意识到OI果然还是靠平时积累的，这种比赛临时抱佛脚很大概率是不靠谱的。</p>
<p>还是要谢谢NOI最后给了我一个意识到自己有多菜的机会。还有那么多我没有学的啊~</p>
<p>大概在没有竞赛压力之后我还是会对这些算法认真地研究一番的吧。觉得自己的心态是一个很奇妙的东西。在被父母逼着学竞赛的时候总觉得这些算法很烦，但是意识到自己远离竞赛之后，反而又觉得它们有趣起来了。</p>
<p>网上看过很多这样的游记，一般到最后作者不是Au就是进队了，这种好事终究不会发生在我身上。</p>
<p>唉。这就退役了。</p>
<p>写于Day 3从长沙回上海的火车上。自己的思路一如既往地混乱。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/08/14/TreapMultiset/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/14/TreapMultiset/" class="post-title-link" itemprop="url">Reinventing the Wheel: A Drop-in STL Multiset Alternative Using Treap</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-14 15:20:55" itemprop="dateCreated datePublished" datetime="2020-08-14T15:20:55+08:00">2020-08-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-16 11:30:48" itemprop="dateModified" datetime="2021-03-16T11:30:48+08:00">2021-03-16</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>It turns out that writing a STL container from scratch is mostly a tedious physical labor.</p>
</blockquote>
<p>STL is created to save C++ programmers the time of reinventing wheels. Unfortunately, many STL data structures, most notably self-balancing BSTs (aka. <code>std::(multi)set</code>), are not extendable and are by itself too limited to be used in the context of competitive programming, forcing us to write our own BSTs again and again in competitions.</p>
<p>There comes the fact I find really interesting: A quick and dirty self-balancing BST implementation written during a competition is only about 50-60 lines long, while the STL implementation of <code>std::set</code> and <code>std::multiset</code> is usually more than a thousand-lines long in total.</p>
<p>It does make me wonder: what makes this huge difference? And, will the code of our BST bloat as well if we write it the STL way -- with generics, iterators, and all the necessary bits and pieces as specified in the reference?</p>
<p>To answer my question, I have here tried creating my implementation of multiset using treap as the underlying data structure. The result, <code>treap_multiset</code>, is almost a drop-in replacement to <code>std::multiset</code>. The few places where it does not conform to the C++ standard are:</p>
<ol type="1">
<li>It is currently not allocator-aware, so all allocator-related features are not implemented.</li>
<li><code>emplace</code> and <code>emplace_hint</code> are not implemented.</li>
<li>All operations that have logarithmic time complexity in <code>std::multiset</code> still have logarithmic time complexity here, but only in the average sense (because treap is a randomized data structure), and could have linear worst-case time complexity (though very, very, very unlikely).</li>
<li><code>void erase(iterator)</code> takes amortized logarithmic time instead of constant time.</li>
<li>A few uncommonly-used member types are missing.</li>
</ol>
<p><code>treap_multiset</code> also supports two new operations that are not supported in the original <code>std::multiset</code>:</p>
<ol type="1">
<li><pre class="line-numbers"><code class="language-cpp">   size_type rank(iterator it) const;
   size_type rank(const_iterator it) const;</code></pre>
<p>Both take average logarithmic time and return the rank / position of the iterator.</p></li>
<li><pre class="line-numbers"><code class="language-cpp">   iterator at(size_type index);
   const iterator at(size_type index) const;</code></pre>
<p>Both take average logarithmic time and return the iterator at the specified index/position.</p></li>
</ol>
<p>The code is shown below:</p>
<pre class="line-numbers"><code class="language-cpp">#include &lt;stdexcept&gt;
#include &lt;random&gt;
#include &lt;algorithm&gt;

static std::random_device random_device;
static std::mt19937_64 random_engine(random_device());

template &lt;typename T&gt;
struct treap_node &#123;
    using rand_weight_type = decltype(random_engine)::result_type;
    using size_type = std::size_t;

    treap_node *left, *right, *parent;
    rand_weight_type weight;
    size_type size;
    T value;

    treap_node(const T &amp;value): left(nullptr), right(nullptr), parent(nullptr),
        weight(random_engine()), size(1), value(value) &#123;&#125;

    treap_node(treap_node *left, treap_node *right, treap_node *parent, 
        rand_weight_type weight, size_type size, const T &amp;value): 
        left(left), right(right), parent(parent), weight(weight),
        size(size), value(value) &#123;&#125;

    void update_size() &#123;
        size = 1 + (left ? left-&gt;size : 0) + (right ? right-&gt;size : 0);
    &#125;
&#125;;

#define IMPL_ITERATOR_MOVE_NEXT do &#123; \
    if (!node) break; \
    if (node-&gt;right) &#123; \
        node = node-&gt;right; \
        while (node &amp;&amp; node-&gt;left) node = node-&gt;left; \
    &#125; else &#123; \
        bool from_right = true; \
        while (from_right) &#123; \
            if (!node-&gt;parent) &#123; node = nullptr; break; &#125; \
            from_right = node-&gt;parent-&gt;right == node; \
            node = node-&gt;parent; \
        &#125; \
    &#125; \
&#125; while (0)

#define IMPL_ITERATOR_MOVE_PREV do &#123; \
    if (!node) break; \
    if (node-&gt;left) &#123; \
        node = node-&gt;left; \
        while (node &amp;&amp; node-&gt;right) node = node-&gt;right; \
    &#125; else &#123; \
        bool from_left = true; \
        while (from_left) &#123; \
            if (!node-&gt;parent) &#123; node = nullptr; break; &#125; \
            from_left = node-&gt;parent-&gt;left == node; \
            node = node-&gt;parent; \
        &#125; \
    &#125; \
&#125; while (0)

#define TREAP_ITERATOR_DECL(name, qualifier, inc, dec) \
template &lt;typename T&gt; struct name &#123; \
    qualifier treap_node&lt;T&gt; *node; bool past_the_end; \
    name(): node(nullptr), past_the_end(true) &#123;&#125; \
    name(qualifier treap_node&lt;T&gt; *node, bool past_the_end) \
        : node(node), past_the_end(past_the_end) &#123;&#125; \
    name(qualifier treap_node&lt;T&gt; *node): node(node), past_the_end(false) &#123;&#125; \
    qualifier T &amp;operator *() qualifier &#123; \
        if (!node || past_the_end) \
            throw std::runtime_error(&quot;dereferencing null/past-end iterator&quot;); \
        return node-&gt;value; \
    &#125; \
    bool operator ==(const name&lt;T&gt; &amp;b) const &#123; \
        return node == b.node &amp;&amp; past_the_end == b.past_the_end; \
    &#125; \
    bool operator !=(const name&lt;T&gt; &amp;b) const &#123; \
        return node != b.node || past_the_end != b.past_the_end; \
    &#125; \
    name&lt;T&gt; &amp;operator ++() &#123; \
        qualifier treap_node&lt;T&gt; *backup = node; \
        IMPL_ITERATOR_MOVE_##inc; \
        if (!node) past_the_end = true, node = backup; \
        return *this; \
    &#125; \
    name&lt;T&gt; operator ++(int) &#123; \
        name&lt;T&gt; ret(*this); \
        return ++(*this), ret; \
    &#125; \
    name&lt;T&gt; &amp;operator --() &#123; \
        if (past_the_end) past_the_end = false; \
        else IMPL_ITERATOR_MOVE_##dec; \
        if (!node) \
            throw std::runtime_error(&quot;can&#39;t decrement at the beginning&quot;); \
        return *this; \
    &#125; \
    name&lt;T&gt; operator --(int) &#123; \
        name&lt;T&gt; ret(*this); \
        return --(*this), ret; \
    &#125; \
&#125;

TREAP_ITERATOR_DECL(treap_iterator, /* NO QUALIFIER */, NEXT, PREV);
TREAP_ITERATOR_DECL(reverse_treap_iterator, /* NO QUALIFIER */, PREV, NEXT);
TREAP_ITERATOR_DECL(const_treap_iterator, const, NEXT, PREV);
TREAP_ITERATOR_DECL(const_reverse_treap_iterator, const, PREV, NEXT);

template &lt;typename T, typename Compare = std::less&lt;T&gt;&gt;
class treap_multiset &#123;
public:
    using key_type = T;
    using value_type = T;
    using size_type = typename treap_node&lt;T&gt;::size_type;
    using key_compare = Compare;
    using value_compare = Compare;
    using node_type = treap_node&lt;T&gt;*;
    using iterator = treap_iterator&lt;T&gt;;
    using reverse_iterator = reverse_treap_iterator&lt;T&gt;;
    using const_iterator = const_treap_iterator&lt;T&gt;;
    using const_reverse_iterator = const_reverse_treap_iterator&lt;T&gt;;

    treap_multiset(): root(nullptr) &#123;&#125;

    treap_multiset(const treap_multiset &amp;b): root(deep_copy(b.root)), comp(b.comp) &#123;&#125;

    treap_multiset(treap_multiset &amp;&amp;b): root(b.root), comp(b.comp) &#123;&#125;

    ~treap_multiset() &#123; if (root) recursive_free(root); &#125;

    bool empty() const &#123; return root == nullptr; &#125;

    size_type size() const &#123; return root ? root-&gt;size : 0; &#125;

    size_type max_size() const &#123; return 0x7FFFFFFF; &#125;

    key_compare key_comp() const &#123; return comp; &#125;

    value_compare value_comp() const &#123; return comp; &#125;

    iterator begin() 
        &#123; return iterator(leftmost(root)); &#125;

    const_iterator begin() const 
        &#123; return const_iterator(leftmost(root)); &#125;

    const_iterator cbegin() const 
        &#123; return const_iterator(leftmost(root)); &#125;

    iterator end() 
        &#123; return iterator(rightmost(root), true); &#125;

    const_iterator end() const 
        &#123; return const_iterator(rightmost(root), true); &#125;

    const_iterator cend() const 
        &#123; return const_iterator(rightmost(root), true); &#125;

    reverse_iterator rbegin() 
        &#123; return reverse_iterator(rightmost(root)); &#125;

    const_reverse_iterator rbegin() const 
        &#123; return const_reverse_iterator(rightmost(root)); &#125;

    const_reverse_iterator crbegin() const 
        &#123; return const_reverse_iterator(rightmost(root)); &#125;

    reverse_iterator rend() 
        &#123; return reverse_iterator(leftmost(root), true); &#125;

    const_reverse_iterator rend() const 
        &#123; return const_reverse_iterator(leftmost(root), true); &#125;

    const_reverse_iterator crend() const 
        &#123; return const_reverse_iterator(leftmost(root), true); &#125;

    iterator insert(const value_type &amp;value) &#123;
        node_type left, right;
        split_le(root, value, left, nullptr, right, nullptr);
        node_type temp = new treap_node&lt;T&gt;(value);
        root = join(join(left, temp), right);
        return iterator(temp);
    &#125;

    iterator insert(iterator position, const value_type &amp;value) 
        &#123; return insert(value); &#125;

    template &lt;typename II&gt;
    void insert(II first, II last) &#123; 
        for (; first != last; first++) 
            insert(*first); 
    &#125;

    size_type rank(iterator it) const &#123; return rank(it.node); &#125;
    
    size_type rank(const_iterator it) const &#123; return rank(it.node); &#125;

    iterator at(size_type index) &#123;
        if (index &lt; 0 || index &gt; size()) return end();
        return iterator(at_internal(index));
    &#125;

    const_iterator at(size_type index) const &#123;
        if (index &lt; 0 || index &gt; size()) return end();
        return const_iterator(at_internal(index));
    &#125;

    void erase(iterator pos) &#123;
        assert_valid(pos);
        node_type a, b, c;
        size_type rank = this-&gt;rank(pos.node);
        split_size(root, rank, a, nullptr, c, nullptr);
        split_size(a, rank - 1, a, nullptr, b, nullptr);
        root = join(a, c);
        // assert(b == pos.node);
        delete b;
    &#125;

    size_type erase(const value_type &amp;key) &#123;
        node_type a, b, c;
        split_le(root, key, a, nullptr, c, nullptr);
        split_re(a, key, a, nullptr, b, nullptr);
        root = join(a, c);
        if (b) &#123;
            size_type ret = b-&gt;size;
            recursive_free(b);
            return ret;
        &#125;
        return 0;
    &#125;

    void erase(iterator first, iterator last) &#123;
        size_type rank_first = rank(first);
        size_type rank_last = rank(last);
        node_type a, b, c;
        split_size(root, rank_last, a, nullptr, c, nullptr);
        split_size(a, rank_last - 1, a, nullptr, b, nullptr);
        root = join(a, c);
        if (b) recursive_free(b);
    &#125;

    void clear() &#123; if (root) recursive_free(root); &#125;

    void swap(treap_multiset &amp;b) &#123; swap(root, b.root); &#125;

    iterator find(const value_type &amp;key) &#123;
        node_type ret = find_internal(key);
        return ret ? iterator(ret) : end();
    &#125;

    const_iterator find(const value_type &amp;key) const &#123;
        node_type ret = const_cast&lt;treap_multiset&lt;T&gt;*&gt;(this)-&gt;find_internal(key);
        return ret ? const_iterator(ret) : end();
    &#125;

    size_type count(const value_type &amp;key) const &#123;
        node_type a, b, c;
        treap_multiset&lt;T&gt; *thiz = const_cast&lt;treap_multiset&lt;T&gt;*&gt;(this);
        thiz-&gt;split_le(root, key, a, nullptr, c, nullptr);
        thiz-&gt;split_re(root, key, a, nullptr, b, nullptr);
        size_type ret = b ? b-&gt;size : 0;
        thiz-&gt;root = thiz-&gt;join(thiz-&gt;join(a, b), c);
        return ret;
    &#125;

    iterator lower_bound(const value_type &amp;key) &#123;
        node_type ret = lower_bound_internal(key);
        return ret ? iterator(ret) : end();
    &#125;

    const_iterator lower_bound(const value_type &amp;key) const &#123;
        node_type ret = const_cast&lt;treap_multiset&lt;T&gt;*&gt;(this)-&gt;lower_bound_internal(key);
        return ret ? const_iterator(ret) : end();
    &#125;

    iterator upper_bound(const value_type &amp;key) &#123;
        node_type ret = upper_bound_internal(key);
        return ret ? iterator(ret) : end();
    &#125;

    const_iterator upper_bound(const value_type &amp;key) const &#123;
        node_type ret = const_cast&lt;treap_multiset&lt;T&gt;*&gt;(this)-&gt;upper_bound_internal(key);
        return ret ? const_iterator(ret) : end();
    &#125;

    std::pair&lt;iterator, iterator&gt; equal_range(const value_type &amp;key) &#123;
        return std::make_pair(lower_bound(key), upper_bound(key));
    &#125;

    std::pair&lt;const_iterator, const_iterator&gt; equal_range(const value_type &amp;key) const &#123;
        return std::make_pair(lower_bound(key), upper_bound(key));
    &#125;

    size_type depth(node_type node) &#123;
        if (!node) return 0;
        return 1 + std::max(depth(node-&gt;left), depth(node-&gt;right));
    &#125;
    
private:
    Compare comp;
    node_type root;

    void recursive_free(node_type root) &#123;
        if (root-&gt;left) 
            recursive_free(root-&gt;left);       
        if (root-&gt;right) 
            recursive_free(root-&gt;right);
        delete root;
    &#125;

    void split_le(node_type root, const value_type &amp;key, 
        node_type &amp;left, node_type left_parent,
        node_type &amp;right, node_type right_parent) &#123;
        if (!root) &#123; left = right = nullptr; return; &#125;
        if (!comp(key, root-&gt;value)) &#123;
            left = root; root-&gt;parent = left_parent;
            split_le(root-&gt;right, key, root-&gt;right, root, right, right_parent);
        &#125; else &#123;
            right = root; root-&gt;parent = right_parent;
            split_le(root-&gt;left, key, left, left_parent, root-&gt;left, root);
        &#125;
        root-&gt;update_size();
    &#125;

    void split_re(node_type root, const value_type &amp;key, 
        node_type &amp;left, node_type left_parent,
        node_type &amp;right, node_type right_parent) &#123;
        if (!root) &#123; left = right = nullptr; return; &#125;
        if (comp(root-&gt;value, key)) &#123;
            left = root; root-&gt;parent = left_parent;
            split_re(root-&gt;right, key, root-&gt;right, root, right, right_parent);
        &#125; else &#123;
            right = root; root-&gt;parent = right_parent;
            split_re(root-&gt;left, key, left, left_parent, root-&gt;left, root);
        &#125;
        root-&gt;update_size();
    &#125;

    void split_size(node_type root, size_type size, 
        node_type &amp;left, node_type left_parent,
        node_type &amp;right, node_type right_parent) &#123;
        if (!root) &#123; left = right = nullptr; return; &#125;
        size_type left_size = 1 + (root-&gt;left ? root-&gt;left-&gt;size : 0);
        if (left_size &lt;= size) &#123;
            left = root; root-&gt;parent = left_parent;
            split_size(root-&gt;right, 
                size - left_size, root-&gt;right, root, right, right_parent);
        &#125; else &#123;
            right = root; root-&gt;parent = right_parent;
            split_size(root-&gt;left, size, left, left_parent, root-&gt;left, root);
        &#125;
        root-&gt;update_size();
    &#125;

    node_type join(node_type left, node_type right) &#123;
        if (!left) return right;
        if (!right) return left;
        if (left-&gt;weight &lt;= right-&gt;weight) &#123;
            node_type temp = join(left-&gt;right, right);
            if (temp) temp-&gt;parent = left;
            left-&gt;right = temp;
            left-&gt;update_size();
            return left;
        &#125; else &#123;
            node_type temp = join(left, right-&gt;left);
            if (temp) temp-&gt;parent = right;
            right-&gt;left = temp;
            right-&gt;update_size();
            return right;
        &#125;
    &#125;

    node_type leftmost(node_type x) const &#123;
        if (!x) return nullptr;
        node_type ret = x; while (ret-&gt;left) ret = ret-&gt;left;
        return ret;
    &#125;

    node_type rightmost(node_type x) const &#123;
        if (!x) return nullptr;
        node_type ret = x; while (ret-&gt;right) ret = ret-&gt;right;
        return ret;
    &#125;

    node_type find_internal(const value_type &amp;key) &#123;
        node_type a, b, c;
        split_le(root, key, a, nullptr, c, nullptr);
        split_re(root, key, a, nullptr, b, nullptr);
        root = join(join(a, b), c);
        return b;
    &#125;

    node_type lower_bound_internal(const value_type &amp;key) &#123;
        node_type left, right;
        split_re(root, key, left, nullptr, right, nullptr);
        node_type ret = leftmost(right);
        root = join(left, right);
        return ret;
    &#125;

    node_type upper_bound_internal(const value_type &amp;key) &#123;
        node_type left, right;
        split_le(root, key, left, nullptr, right, nullptr);
        node_type ret = leftmost(right);
        root = join(left, right);
        return ret;
    &#125;

    node_type at_internal(size_type index) const &#123;
        node_type temp = root;
        while (true) &#123;
            size_type left_size = 1 + (temp-&gt;left ? temp-&gt;left-&gt;size : 0);
            if (index == left_size) return temp;
            else if (index &lt; left_size) temp = temp-&gt;left;
            else temp = temp-&gt;right, index -= left_size;
        &#125;
        return nullptr; // UNREACHABLE
    &#125;

    size_type rank(node_type node) &#123;
        bool from_right = true;
        size_type ret = 0;
        while (node) &#123;
            if (from_right)
                ret += 1 + (node-&gt;left ? node-&gt;left-&gt;size : 0);
            if (node-&gt;parent)
                from_right = node == node-&gt;parent-&gt;right;
            node = node-&gt;parent;
        &#125;
        return ret;
    &#125;

    node_type deep_copy(node_type node) &#123;
        if (!node) return nullptr;
        node_type left = deep_copy(node-&gt;left);
        node_type right = deep_copy(node-&gt;right);
        node_type ret = new treap_node&lt;T&gt;(
            left, right, nullptr,
            node-&gt;weight, node-&gt;size, node-&gt;value
        );
        if (left) left-&gt;parent = ret;
        if (right) right-&gt;parent = ret;
        return ret;
    &#125;

    void assert_valid(iterator it) &#123;
        if (!it.node || it.past_the_end)
            throw std::runtime_error(&quot;invalid iterator&quot;);
        node_type temp = it.node;
        while (temp-&gt;parent) temp = temp-&gt;parent;
        if (temp != root)
            throw std::runtime_error(&quot;invalid iterator&quot;);
    &#125;
&#125;;</code></pre>
<p>(The code above hasn't been thoroughly tested yet and could still contain bugs).</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/08/12/AlipayParanoia/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/12/AlipayParanoia/" class="post-title-link" itemprop="url">论支付宝对Xposed框架的被害妄想症</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-08-12 13:29:54 / 修改时间：22:30:26" itemprop="dateCreated datePublished" datetime="2020-08-12T13:29:54+08:00">2020-08-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近真的是被支付宝的操作恶心到了。</p>
<p>跑到医院门口，要出示健康码了。打开支付宝选择随申码，登录授权时要刷脸，然后告诉我手机不支持刷脸？场面一度非常尴尬。</p>
<p>“您的手机不支持刷脸”。为什么不支持？缺少硬件？缺少驱动？含糊其辞，搞得我一开始真以为XDA上下下来的ROM不贴合我国国情少预装了一套刷脸的库。</p>
<p>查了好久才意识到原来是支付宝检测到Magisk和Xposed的缘故。</p>
<p>好啊，这可以理解嘛，人脸验证和支付都是安全性极高的，关键步骤被hook是会出大事的。</p>
<p>于是停用了Riru和EdXposed的模块。但是还是不支持。</p>
<p>三清之后重装，又支持了。</p>
<p>然后我遵循网友的经验，安装Magisk，然后开启随机包名重装和Magisk Hide。没有出问题。</p>
<p>然后再安装EdXposed，即时模块打开，黑名单打开把支付宝加进去，然后开启强制SafetyNet检验。</p>
<p>然后支付宝安全检查之后就又告诉我不支持了。</p>
<p>唉，我啥模块都没装呢，拉黑之后就算装了也hook不到你支付宝紧张啥？</p>
<p>网上逛了一圈，有不少遇到这个问题的，大家都没有好的解决办法，有的说双开，有的说双手机，有的说回退到play上的19年9月份的75版本。最后一条亲测确实有效，但是一直停留在老版本也不是个事啊。</p>
<p>也看了CSDN上一些关于阿里系应用反hook机制的研究，大概是18年左右写的。当时的机制是通过反射检测有没有<code>XposedHelper</code>这个类，有这个类之后检测缓存里面有没有alipay等关键词。这个机制非常巧妙，而且我觉得强度也足够了。</p>
<p>但是现在似乎已经不是这个机制了。通过有些解决方案当中关闭读取应用列表权限这一项我隐约可以猜出这支付宝大概是直接读取手机安装的所有应用，然后发现带Xposed就是不安全？</p>
<p>这也太过了吧，我个人甚至觉得有些流氓之嫌。</p>
<blockquote>
<p>看到Xposed，立刻想到自己被hook，立刻想到这hook一定会让用户亏钱，立刻想到自己要赔钱，然后就紧张的要命。支付宝的想像惟在这一层能够如此跃进。<del>——鲁迅</del></p>
</blockquote>
<p>这个逻辑链有两处是有待商榷的。</p>
<p>为什么所有Xposed插件一定要来hook你？我手机一般就装两模块，一个修改界面的locale让不够本地化的地方本地化，一个修改图标让系统更美观。这两个模块都不用hook进支付宝，而且还都是我自己一行一行写出来的。我脑子坏掉了去搞支付宝自己坑自己？</p>
<p>为什么觉得因为用户因为hook造成的损失一定要支付宝负责？还真就社会责任心爆棚呗。服务条款里面加一行“由于用户使用第三方软件自行修改系统框架进而影响本应用的正常运行，导致财产损失的，责任自负，支付宝概不负责”有那么困难吗？Xposed必须是用户自己装的，模块一定是用户自己下载并且启用的，考虑到使用Xposed基本上都是安卓的发烧友，翻车了自己负责这条道理大家都认，也没有人来说是支付宝的不对。</p>
<p>退一步，如果我真的要搞尽一切代价搞支付宝，支付宝检测有没有被hook的代码可不可能被hook呢？我能不能不用Xposed而用一些更底层的框架例如Riru来搞呢？支付宝作为一个正常权限的应用软件，面对因用户主动选择破坏承载其运行的，本来安全的安卓系统框架，而导致的可能来自底层的，高权限的修改与破坏一定是无能为力的。支付宝完全没有必要对一个受害者主动引发，且本质上自身无能为力的损失负责。</p>
<p>进一步，今天支付宝可以读取应用看到Xposed就不让刷脸，明天如果腾讯和阿里干架，支付宝也可以读取应用列表看到有微信就不让用（3Q大战既视感）。现在看来“读取应用列表”不是安卓原生自带的权限实在是一个设计漏洞。支付宝这个行为也显然开了一个不好的先例。</p>
<p>最后，我其实一直不理解的一点是，是什么让支付宝觉得原来合理的Xposed框架检测逻辑有问题，进而换上了这套长臂管辖似的一刀切呢？</p>
<p>在不知道更多信息以前，我只能认为是支付宝自身在有些情境下不必要的责任感以及过度的被害妄想症在作祟。</p>
<p>在此，向设计这个安全检查模块的所有阿里员工以及十八代亲属致以最诚挚的问候。</p>
<p>最后的最后，讲一讲在保留Magisk和Xposed功能的情况下，可能的解决办法吧。</p>
<ol type="1">
<li>停留在老版本的支付宝。</li>
<li>让EdXposed也有和Magisk类似的随机包名重装功能。</li>
<li>让支付宝找一个更合理的办法检验自己有没有被hook。</li>
<li>让支付宝目前这套方案失效，比如说禁止支付宝调用<code>getInstalledPackages</code>来获取已经安装的应用。这个我知道在一些国产的系统里面是有类似功能的。但是目前类原生的系统还没有。虽可以通过Xposed模块来实现，但是在这个背景下毫无意义。唯一的一个方案是把系统的源码clone一份下来，然后直接改代码。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/08/07/FWHT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/07/FWHT/" class="post-title-link" itemprop="url">Fast Walsh-Hadamard Transform in Competitive Programming</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-08-07 13:26:34 / 修改时间：16:56:27" itemprop="dateCreated datePublished" datetime="2020-08-07T13:26:34+08:00">2020-08-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>This should be the very first English post I write on my blog and I expect there to be some minor errors. This is a popular technique in the Chinese competitive programming community but there doesn't seem to be a lot of documentation about its application in the English CP community. The posts I found on Codeforces doesn't seem to be very clear to me...</p>
<h1 id="prerequisites">Prerequisites</h1>
<ul>
<li>A decent proficiency in competitive programming.</li>
<li>A basic understanding of the Cooley-Tukey FFT and its application in competitive programming.</li>
<li>A decent understanding of bitwise operations.</li>
</ul>
<h1 id="why-do-we-need-fwht">Why do we need FWHT?</h1>
<p>Recall what we would do if we are to quickly calculate the following convolution of two sequences <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, each of length <span class="math inline">\(n\)</span>: <span class="math display">\[
\{a\circledast b\}_i=\sum_{j+k=i}a_{j}b_k \Bigg/ \{a\circledast b\}_i=\sum_{j=0}^ia_{j}b_{i-j}
\]</span> We use FFT, which applies the following transformation to the input sequence: <span class="math display">\[
\mathcal{F}\{a\}_i = \sum_{j=0}^n a_j\omega_{n}^{ij}
\]</span> Since the calculation of this transformation (and its inverse) can be done in a divide-and-conquer manner in <span class="math inline">\(\mathcal O(n\log n)\)</span> and the element wise product of the transformation is equivalent to the convolution on the original series, we are able to calculate the convolution in <span class="math inline">\(\mathcal O(n\log n)\)</span>.</p>
<p>Now we try to generalize our findings to a more general case: <span class="math display">\[
\{a\circledast b\}_i=\sum_{j \star k=i}a_jb_k
\]</span> where <span class="math inline">\(\star\)</span> is some binary operation. The convolution we see at the beginning is a special case where <span class="math inline">\(\star = +\)</span>.</p>
<p>FWHT is an algorithm that borrows similar notions from FFT and is able to compute the convolution in <span class="math inline">\(\mathcal O(n \log n)\)</span> time for <span class="math inline">\(\star =\vee,\wedge,\oplus\)</span> (bitwise OR, bitwise AND, and bitwise XOR). Why do the convolutions of these bitwise operations matter? Observe that binary representation is a way of encoding sets and these three operations correspond to set union, set intersection and set symmetric difference respectively, therefore, FWHT can be used to accelerate set-based DPs.</p>
<h1 id="bitwise-or-convolution">Bitwise OR convolution</h1>
<p>Let's start with the convolution with respect to bitwise OR: <span class="math display">\[
\{a\circledast b\}_i = \sum_{j\vee k=i}a_jb_k
\]</span> We start by exploiting an interesting property of bitwise OR: <span class="math display">\[
x \vee z = z,y\vee z = z \Leftrightarrow (x\vee y)\vee z=z
\]</span> or its clearer equivalent in set-based notations: <span class="math display">\[
X\subseteq Z,Y\subseteq Z \Leftrightarrow (X\cup Y)\subseteq Z
\]</span> <strong>Claim:</strong> The following transformation can turn OR convolutions to element-wise multiplications: <span class="math display">\[
\mathcal{FWHT}\{a\}_i=\sum_{j\vee i=i} a_j
\]</span> <strong>Proof:</strong> <span class="math display">\[
\begin{aligned}
\mathcal{FWHT}\{a\}_i\cdot\mathcal{FWHT}\{b\}_i &amp;= \left(\sum_{j\vee i=i}a_j\right) \left(\sum_{k\vee i=i}b_k\right) \\
&amp;= \sum_{j\vee i=i}\sum_{k\vee i=i}a_jb_k \\
&amp;= \sum_{(j\vee k)\vee i=i} a_jb_k \\
&amp;= \sum_{l\vee i = i}\sum_{j \vee k = l} a_jb_k\\
&amp;= \mathcal{FWHT}\{a\circledast b\}_i
\end{aligned}
\]</span> Then how are we able to compute <span class="math inline">\(\mathcal{FWHT}\{a\}\)</span> quickly? A trivial implementation still takes <span class="math inline">\(\mathcal O(n^2)\)</span> time.</p>
<p>Recall what we did in FFT: we divide <span class="math inline">\(a\)</span> into two subsequences based on parity of indices, a.k.a, the last bit of indices. We did this because the root of unity has such amazing property as <span class="math inline">\(\omega_n^k=\omega_{n/2}^{k/2}\)</span>. We could do that here as well, but a limitation of dividing based on the last bit is that the order of elements changes in the process, so an efficient in-place implementation has to do a pre-shuffle to cope with that. Since OR is a bitwise operation, which bit based on which we divide doesn't really matter much. Why not simply <strong>divide based on the first, or the most significant bit</strong>, such that the order of elements is preserved in the process? Dividing based on the highest bit of indices, simply put, is to split <span class="math inline">\(a\)</span> into the first half, <span class="math inline">\(a^0\)</span>, and the second half, <span class="math inline">\(a^1\)</span>, in their natural order.</p>
<p>Here I introduce a notation, <span class="math inline">\(1|a\)</span> or <span class="math inline">\(0|a\)</span>. In the context where the length of the sequence is <span class="math inline">\(n\)</span> (and <span class="math inline">\(n\)</span> is a power of <span class="math inline">\(2\)</span>), <span class="math inline">\(1|a=\frac{n}{2}+a\)</span> where <span class="math inline">\(0\le a&lt;n/2\)</span>, and <span class="math inline">\(0|a\)</span> is just <span class="math inline">\(a\)</span>. In other words, <span class="math inline">\(1|a\)</span> has <span class="math inline">\(1\)</span> as the highest bit and <span class="math inline">\(0|a\)</span> has <span class="math inline">\(0\)</span> as the highest bit.</p>
<p>(Note using this notation, <span class="math inline">\(a^0_i = a_{0|i}\)</span> and <span class="math inline">\(a^1_i = a_{1|i}\)</span>)</p>
<p>To make our writing clearer, denote <span class="math display">\[
\begin{aligned}
\mathcal{FWHT}\{a\} &amp;= A \\
\mathcal{FWHT}\left\{a^0\right\} &amp;= A^0 \\
\mathcal{FWHT}\left\{a^1\right\} &amp;= A^1 \\
\end{aligned}
\]</span> We want to express each element of <span class="math inline">\(A\)</span> as a combination of some element in <span class="math inline">\(A^0\)</span> and <span class="math inline">\(A^1\)</span>.</p>
<p>We first look at the first half of <span class="math inline">\(A\)</span>. Using the notation I defined above, these elements can be expressed as <span class="math inline">\(A_{0|i}\)</span>. <span class="math display">\[
\begin{aligned}
A_{0|i}&amp;=\sum_{j\vee (0|i)=0|i}a_j \\
&amp;= \sum_{(0|j)\vee (0|i)=0|i}a^0_j + \sum_{(1|j)\vee (0|i)=0|i}a^1_j \\
\end{aligned}
\]</span> We know that the highest bit of <span class="math inline">\((1|j)\vee (0|i)\)</span> should always be <span class="math inline">\(1\)</span>, so the condition in the second summation is never satisfied, and we can simply throw the second term away. And <span class="math inline">\((0|j)\vee (0|i)=0|i\)</span> simplifies to <span class="math inline">\(j\vee i =i\)</span>, so we get, by definition of <span class="math inline">\(A^0\)</span>: <span class="math display">\[
A_{0|i} = A^0_i
\]</span> What about the second half, <span class="math inline">\(A_{1|i}\)</span>? <span class="math display">\[
\begin{aligned}
A_{1|i}&amp;=\sum_{j\vee (1|i)=1|i}a_j \\
&amp;= \sum_{(0|j)\vee (1|i)=1|i}a^0_j + \sum_{(1|j)\vee (1|i)=1|i}a^1_j \\
&amp;= A_i^0+A_i^1
\end{aligned}
\]</span> Together we get: <span class="math display">\[
A=\left(A^0, A^0+A^1\right)
\]</span> with the trivial recursion boundary <span class="math inline">\(A_0=a_0\)</span> when <span class="math inline">\(n=0\)</span>.</p>
<p>(here I use the tuple notation to denote concatenation, and <span class="math inline">\(+\)</span> to denote element-wise addition).</p>
<p>This is something we can write an in-place implementation for with ease:</p>
<pre class="line-numbers"><code class="language-cpp">void fwht_or(int n, int *a, int *A) &#123;
    copy(a, a + n, A);
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1)
        for (int l = 0; l &lt; n; l += s)
            for (int i = 0; i &lt; h; i++)
                A[l + h + i] += A[l + i]
&#125;</code></pre>
<p>Its time complexity is obviously <span class="math inline">\(\mathcal O(n\log n)\)</span> with a really small constant factor.</p>
<p>Its reverse transform turns out to be simple as well, suppose we know <span class="math inline">\(A\)</span> and let <span class="math display">\[
A=(A&#39;,A&#39;&#39;)
\]</span> (Assuming <span class="math inline">\(n\)</span> is a power of <span class="math inline">\(2\)</span> and <span class="math inline">\(A&#39;\)</span> and <span class="math inline">\(A&#39;&#39;\)</span> each have length <span class="math inline">\(n/2\)</span>)</p>
<p>Then we can recover <span class="math inline">\(A^0\)</span> and <span class="math inline">\(A^1\)</span>: <span class="math display">\[
\begin{cases}
    A^0=A&#39;\\
    A^1=A&#39;&#39;-A&#39;
\end{cases}
\]</span> Implementation:</p>
<pre class="line-numbers"><code class="language-cpp">void ifwht_or(int n, int *a, int *A) &#123; 
    std::copy(A, A + n, a);
    // If n is guaranteed to be a power of 2 then we don&#39;t need n_ and the min(...) in the inner loop.
    int n_ = 1; while (n_ &lt; n) n_ &lt;&lt;= 1; 
    // n_ = 1 &lt;&lt; (32 - __builtin_clz(n - 1));
    for (int s = n_, h = n_ / 2; h; s &gt;&gt;= 1, h &gt;&gt;= 1)
        for (int l = 0; l &lt; n; l += s)
            for (int i = 0; i &lt; std::min(i, n - l - h); i++)
                a[l + h + i] -= a[l + i]
&#125;</code></pre>
<p>And an amazing thing about this, which I haven't quite figured out why, is that the order of the outermost loop above can be reversed and both functions can be merged into one:</p>
<pre class="line-numbers"><code class="language-cpp">void fwht_or(int n, int *a, int *A, int dir = 1) &#123;
    std::copy(a, a + n, A);
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1)
        for (int l = 0; l &lt; n; l += s)
            for (int i = 0; i &lt; h; i++)
                A[l + h + i] += dir * A[l + i]
&#125;</code></pre>
<p>(Fast bitwise OR / set union convolution is sometimes aliased "Fast Mobius Transform" in Chinese CP community. Both are essentially the same.)</p>
<h1 id="bitwise-and-convolution">Bitwise AND convolution</h1>
<p>The bitwise AND convolution <span class="math display">\[
\{a\circledast b\}_i = \sum_{j\wedge k=i}a_jb_k
\]</span> can be accelerated in a similar way.</p>
<p>(Actually, by de Morgan's Law we can always reduce an AND convolution to an OR convolution)</p>
<p>Note that AND also has this interesting property: <span class="math display">\[
x \wedge z = z,y\wedge z = z \Leftrightarrow (x\wedge y)\wedge z=z
\]</span> or in set notations: <span class="math display">\[
Z\subseteq X,Z\subseteq Y \Leftrightarrow Z\subseteq(X\cap Y)
\]</span> Thus, we can prove in a way similar to what we did in OR convolution that the transform <span class="math display">\[
\mathcal{FWHT}\{a\}_i=\sum_{j\wedge i=i} a_j
\]</span> can turn convolutions to element-wise multiplications.</p>
<p>We still adopt the same divide-and-conquer approach and continue to use the notations <span class="math inline">\(a, a^0,a^1,A,A^0,A^1\)</span>.</p>
<p>Consider the first half of <span class="math inline">\(A\)</span>, which can be expressed as <span class="math inline">\(A_{0|i}\)</span>: <span class="math display">\[
\begin{aligned}
A_{0|i}&amp;=\sum_{j\wedge (0|i)=0|i}a_j \\
&amp;= \sum_{(0|j)\wedge (0|i)=0|i}a^0_j + \sum_{(1|j)\wedge (0|i)=0|i}a^1_j \\
\end{aligned}
\]</span> And by the properties of AND, both <span class="math inline">\((0|j)\wedge (0|i)=0|i\)</span> and <span class="math inline">\((1|j)\wedge (0|i)=0|i\)</span> simplify to <span class="math inline">\(j\wedge i=i\)</span>. So by definition we get <span class="math display">\[
A_{0|i}=A^0_i+A_i^1
\]</span> Then consider the other half of <span class="math inline">\(A\)</span>: <span class="math display">\[
\begin{aligned}
A_{1|i}&amp;=\sum_{j\wedge (1|i)=1|i}a_j \\
&amp;= \sum_{(0|j)\wedge (1|i)=1|i}a^0_j + \sum_{(1|j)\wedge (1|i)=1|i}a^1_j \\
&amp;= A_i^1
\end{aligned}
\]</span> Together we have: <span class="math display">\[
A=\left(A^0+A^1,A^1\right)
\]</span> with the trivial recursion boundary <span class="math inline">\(A_0=a_0\)</span> when <span class="math inline">\(n=0\)</span>.</p>
<p>This gives an efficient implementation very similar to <code>fwht_or</code> above:</p>
<pre class="line-numbers"><code class="language-cpp">void fwht_and(int n, int *a, int *A) &#123;
    std::copy(a, a + n, A);
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1)
        for (int l = 0; l &lt; n; l += s)
            for (int i = 0; i &lt; h; i++)
                A[l + i] += A[l + h + i]
&#125;</code></pre>
<p>The inverse transform is simple as well. Let <span class="math inline">\(A=(A&#39;, A&#39;&#39;)\)</span>, then <span class="math display">\[
\begin{cases}
A^0=A&#39;-A&#39;&#39; \\
A^1=A&#39;&#39;
\end{cases}
\]</span> The code:</p>
<pre class="line-numbers"><code class="language-cpp">void ifwht_and(int n, int *a, int *A) &#123; 
    std::copy(A, A + n, a);
    // If n is guaranteed to be a power of 2 then we don&#39;t need n_ and the min(...) in the inner loop.
    int n_ = 1; while (n_ &lt; n) n_ &lt;&lt;= 1; 
    for (int s = n_, h = n_ / 2; h; s &gt;&gt;= 1, h &gt;&gt;= 1)
        for (int l = 0; l &lt; n; l += s)
            for (int i = 0; i &lt; std::min(i, n - l - h); i++)
                a[l + i] -= a[l + h + i]
&#125;</code></pre>
<p>The order of the outermost loop can be reversed and we can also merge the functions above together.</p>
<h1 id="bitwise-xor-convolution">Bitwise XOR convolution</h1>
<p>The XOR operation does <strong>not</strong> have such nice property as <span class="math display">\[
x\oplus z=z, y\oplus z=z\Leftrightarrow (x\oplus y)\oplus z=z
\]</span> So accelerating the convolution <span class="math display">\[
\{a\circledast b\}_i = \sum_{j\oplus k=i}a_jb_k
\]</span> is not as straightforward as we did above.</p>
<p>We first introduce an auxiliary operation, define <span class="math inline">\(x \otimes y= \operatorname{popcount}(x\wedge y) \bmod 2\)</span>, where <span class="math inline">\(\operatorname{popcount}(x)\)</span> denotes the number of <span class="math inline">\(1\)</span>s in the binary representation of <span class="math inline">\(x\)</span>.</p>
<p><strong>Claim:</strong> The transformation below turns convolutions to element-wise multiplications: <span class="math display">\[
\mathcal{FWHT}\{a\}_i=\sum_{j\otimes i=0} a_j - \sum_{j\otimes i=1} a_j
\]</span> <strong>Proof: </strong> <span class="math display">\[
\begin{aligned}
\mathcal{FWHT}\{a\}_i\cdot\mathcal{FWHT}\{b\}_i &amp;= \left(\sum_{j\otimes i=0} a_j - \sum_{j\otimes i=1} a_j\right) \left(\sum_{k\otimes i=0} b_k - \sum_{k\otimes i=1} b_k\right) \\
&amp;= \sum_{j\otimes i=0}\sum_{k\otimes i=0}a_jb_k +\sum_{j\otimes i=1}\sum_{k\otimes i=1}a_jb_k \\
&amp;- \sum_{j\otimes i=1}\sum_{k\otimes i=0}a_jb_k - \sum_{j\otimes i=0}\sum_{k\otimes i=1}a_jb_k
\end{aligned}
\]</span> How to simplify those terms?</p>
<p>Observe that by the definition of XOR we have <span class="math display">\[
\operatorname{popcount}(x\oplus y) = \operatorname{popcount}(x)+\operatorname{popcount}(y)-2\operatorname{popcount}(x\wedge y)
\]</span> So if we apply modulo <span class="math inline">\(2\)</span> on both sides, <span class="math display">\[
\operatorname{popcount}(x\oplus y) \equiv \operatorname{popcount}(x)+\operatorname{popcount}(y) \pmod 2
\]</span> Plug in <span class="math inline">\(x=j\wedge i,y=k\wedge i\)</span> and we get <span class="math display">\[
\operatorname{popcount}((j\wedge i)\oplus (k\wedge i)) \equiv \operatorname{popcount}(j\wedge i)+\operatorname{popcount}(k\wedge i) \pmod 2
\]</span> We are almost there. Apply the identity below, whose proof I simply omit here, <span class="math display">\[
(j\wedge i)\oplus (k\wedge i)=(j\oplus k)\wedge i
\]</span> (This is something good about bitwise operations: if you cannot prove an identity the smart way you can always fall back on the dumb method -- making a truth table)</p>
<p>We finally get <span class="math display">\[
(j \oplus k)\otimes i \equiv j\otimes i+k\otimes i \pmod 2
\]</span> (We are actually quite familiar with this if we remove the circles outside <span class="math inline">\(+\)</span>s and <span class="math inline">\(\times\)</span>s)</p>
<p>With this conclusion we can simplify the four terms above: <span class="math display">\[
\begin{aligned}
\mathcal{FWHT}\{a\}_i\cdot\mathcal{FWHT}\{b\}_i &amp;= \cdots \\
&amp;= \sum_{(j\oplus k)\otimes i=0}a_jb_k - \sum_{(j\oplus k)\otimes i=1}a_jb_k \\
&amp;=  \mathcal{FWHT}\{a\circledast b\}_i
\end{aligned}
\]</span> which completes the proof.</p>
<p>We then explore how to compute <span class="math inline">\(\mathcal{FWHT}\{a\}\)</span> efficiently. Divide and conquer is still our friend, and dividing <span class="math inline">\(a\)</span> based on the highest bit works here so we continue to use those notations.</p>
<p>Consider the first half of <span class="math inline">\(A\)</span>... <span class="math display">\[
\begin{aligned}
A_{0|i} &amp;= \sum_{j\otimes (0|i)=0} a_j - \sum_{j\otimes (0|i)=1} a_j \\
&amp;= \sum_{(0|j)\otimes (0|i)=0} a_j^0+  \sum_{(1|j)\otimes (0|i)=0}a_j^1 -  \sum_{(0|j)\otimes (0|i)=1} a_j^0-  \sum_{(1|j)\otimes (0|i)=1}a_j^1 \\
&amp;= \sum_{j\otimes i=0} a_j^0+  \sum_{j\otimes i=0}a_j^1 -  \sum_{j\otimes i=1} a_j^0-  \sum_{j\otimes i=1}a_j^1 \\
&amp;= A_i^0
+A_i^1\end{aligned}
\]</span> and the other half: <span class="math display">\[
\begin{aligned}
A_{1|i} &amp;= \sum_{j\otimes (1|i)=0} a_j - \sum_{j\otimes (1|i)=1} a_j \\
&amp;= \sum_{(0|j)\otimes (1|i)=0} a_j^0+  \sum_{(1|j)\otimes (1|i)=0}a_j^1 -  \sum_{(0|j)\otimes (1|i)=1} a_j^0-  \sum_{(1|j)\otimes (1|i)=1}a_j^1 \\
&amp;= \sum_{j\otimes i=0} a_j^0+  \sum_{j\otimes i=1}a_j^1 -  \sum_{j\otimes i=1} a_j^0-  \sum_{j\otimes i=0}a_j^1 \\
&amp;= A_i^0 - A_i^1
\end{aligned}
\]</span> So together we get <span class="math display">\[
A=\left(A^0+A^1,A^0-A^1\right)
\]</span> and the inverse transform <span class="math display">\[
A=(A&#39;,A&#39;&#39;) \Rightarrow \begin{cases}
\displaystyle A^0=\frac{A&#39;+A&#39;&#39;}{2} \\
\displaystyle A^1=\frac{A&#39;-A&#39;&#39;}{2}
\end{cases}
\]</span> The code for both transforms are a bit longer than those for OR and AND, but not by too much:</p>
<pre class="line-numbers"><code class="language-cpp">void fwht_xor(int n, int *a, int *A) &#123;
    std::copy(a, a + n, A);
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1) &#123;
        for (int l = 0; l &lt; n; l += s) &#123;
            for (int i = 0; i &lt; h; i++) &#123;
                int t = A[l + h + i];
                A[l + h + i] = A[l + i] - t;
                A[l + i] += t;
            &#125;
        &#125;
    &#125;
&#125;
void ifwht_xor(int n, int *a, int *A) &#123;
    std::copy(A, A + n, a);
    // If n is guaranteed to be a power of 2 then we don&#39;t need n_ and the min(...) in the inner loop.
    int n_ = 1; while (n_ &lt; n) n_ &lt;&lt;= 1; 
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1) &#123;
        for (int l = 0; l &lt; n; l += s) &#123;
            for (int i = 0; i &lt; std::min(i, n - l - h); i++) &#123;
                int t = a[l + h + i];
                a[l + h + i] = (a[l + i] - t) / 2;
                a[l + i] = (a[l + i] + t) / 2;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>They can be merged as well:</p>
<pre class="line-numbers"><code class="language-cpp">void fwht_xor(int n, int *a, int *A, bool inv = false) &#123;
    std::copy(a, a + n, A);
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1) &#123;
        for (int l = 0; l &lt; n; l += s) &#123;
            for (int i = 0; i &lt; h; i++) &#123;
                int t = A[l + h + i];
                A[l + h + i] = A[l + i] - t;
                A[l + i] += t;
                if (inv) A[l + h + i] /= 2, A[l + i] /= 2;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p><strong>This code above is what Wikipedia refers to as the authentic Fast Walsh-Hadamard Transform</strong>.</p>
<h1 id="some-sidenotes">Some sidenotes</h1>
<p>Note that though FFT and FWHT shares the same idea of divide and conquer, FWHT does not require <span class="math inline">\(n\)</span> to be a power of <span class="math inline">\(2\)</span> whereas FFT does. (Well actually neither of them "require" <span class="math inline">\(n\)</span> to be a power of <span class="math inline">\(2\)</span>, but to apply FFT when <span class="math inline">\(n\)</span> is not a power of <span class="math inline">\(2\)</span> you either need to pad with <span class="math inline">\(0\)</span>s or you have to make your implementation really complicated).</p>
<p>Also, I just came to know that if we express WHT in the language of matrices and vectors, the matrix is called a Hadamard Matrix.</p>
<p>Another fact that I didn't quite understand is why the order of the inverse FWHT can be reversed.</p>
<p>For instance, when <span class="math inline">\(n=8\)</span>, after fully dividing the sequence into individual elements, we first merge <span class="math inline">\((0,1),(2,3),(4,5),(6,7)\)</span>, then we merge <span class="math inline">\((0,1,2,3),(4,5,6,7)\)</span> and finally <span class="math inline">\((0,1,2,3,4,5,6,7)\)</span>. Naturally when we do the inverse transform we have to start with <span class="math inline">\((0,1,2,3,4,5,6,7)\)</span>, recover <span class="math inline">\((0,1,2,3),(4,5,6,7)\)</span>, then recover <span class="math inline">\((0,1),(2,3),(4,5),(6,7)\)</span> and then recover the individual elements. But the popular implementation seems to suggest that the inverse transformation algorithm works in another direction as well. I am now puzzled why this is true and currently I'm just taking this for granted. Perhaps I derived the inversion in a different way than others did? If you have a simple explanation please leave a comment :)</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/07/29/PACT0710/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/29/PACT0710/" class="post-title-link" itemprop="url">PACT 07/10 主对偶方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-07-29 16:29:11 / 修改时间：21:45:12" itemprop="dateCreated datePublished" datetime="2020-07-29T16:29:11+08:00">2020-07-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是主对偶方法">什么是主对偶方法？</h1>
<p>对于所有可以写成整数规划/线性规划形式的问题（不妨假设是最小化问题），由对偶定理可得，对偶最优解一定是<span class="math inline">\(\mathrm{OPT}\)</span>的一个下界。</p>
<p>因此，对偶可行解也是<span class="math inline">\(\mathrm{OPT}\)</span>的一个下界。</p>
<p>所谓的主对偶方法（Primal-dual Method），就是从一个对偶规划的可行解出发，不断优化这个对偶可行解，并在这个过程中利用对偶规划的特性指引我们求得原问题的解。</p>
<p>太抽象？</p>
<h1 id="叕访顶点覆盖">叕访顶点覆盖</h1>
<p>（顶点覆盖问题属实牛逼嗷，那么多近似方法都可以用）</p>
<p>顶点覆盖问题的主线性规划是 <span class="math display">\[
\begin{aligned}
    \text{minimize}\quad &amp;\sum_{v\in V}w_vx_v \\
    \text{subject to}\quad &amp;x_u+x_v\ge 1\quad \forall (u, v)\in E \\
    &amp;x_v \in \{0,1\}\quad \forall v\in V
\end{aligned}
\]</span> 其对偶规划是 <span class="math display">\[
\begin{aligned}
    \text{maximize}\quad &amp;\sum_{v\in E} y_e \\
    \text{subject to}\quad &amp;\sum_{v\in e} y_e \le w_v \quad \forall v \in V\\
    &amp;y_e \ge 0\quad \forall e\in E
\end{aligned}
\]</span> 显然，<span class="math inline">\(y_e=0\)</span>就是一个平凡的对偶可行解。基于主对偶方法的思想，我们可以得到两个算法：</p>
<h2 id="算法1">算法1</h2>
<ol type="1">
<li>初始化<span class="math inline">\(y_e\gets0,C\gets \emptyset\)</span>。</li>
<li>当还有一条边<span class="math inline">\((u,v)\)</span>没有被覆盖时，
<ol type="1">
<li><span class="math inline">\(\varepsilon\gets \min\left\{w_u-\sum_{u\in e} y_e,w_v-\sum_{v\in e} y_e\right\}\)</span>。</li>
<li><span class="math inline">\(y_e\gets y_e+\varepsilon\)</span>（以上两步旨在尽可能增加<span class="math inline">\(y_e\)</span>直至两端点中一个点对应的约束收紧）。</li>
<li>假设增加<span class="math inline">\(y_e\)</span>之后<span class="math inline">\(u\)</span>对应的约束收紧了，那么<span class="math inline">\(C\gets C\cup\{u\}\)</span>。</li>
<li>同时删除所有与<span class="math inline">\(u\)</span>邻接的边。</li>
</ol></li>
<li>返回<span class="math inline">\(C\)</span>。</li>
</ol>
<p>（注意到，当<span class="math inline">\(w_u=1\)</span>时，这个算法退化为我们最初学的极大匹配算法）</p>
<h2 id="算法2">算法2</h2>
<ol type="1">
<li>初始化<span class="math inline">\(y_e\gets0,C\gets \emptyset\)</span>。</li>
<li>当<span class="math inline">\(C\)</span>不是一个合法的顶点覆盖时，
<ol type="1">
<li><span class="math inline">\(\varepsilon\gets \min_{v\in V} \left\{\frac{1}{\deg(v)}\sum_{v\in e}y_e\right\}\)</span></li>
<li>对于所有边<span class="math inline">\(e\in E\)</span>，<span class="math inline">\(y_e\gets y_e+\varepsilon\)</span>（以上两步旨在同时增加所有<span class="math inline">\(y_e\)</span>直至有约束收紧）。</li>
<li>将所有紧约束对应的顶点加入<span class="math inline">\(C\)</span>。</li>
<li>同时删去这些点和它们邻接的所有边。</li>
</ol></li>
<li>返回<span class="math inline">\(C\)</span>。</li>
</ol>
<p>其实还有很多这样的寻找局部极大对偶可行解的方法，以上两个算法是最容易想到的。</p>
<h2 id="分析">分析</h2>
<p>两个算法的分析是共通的： <span class="math display">\[
\begin{aligned}
    \sum_{v\in C}w_v &amp;= \sum_{v \in C}\sum_{v\in e\in E} y_e \\
    &amp;= \sum_{e\in E} y_e |C\cap e| \\
    &amp;\le \sum_{e\in E} y_e \cdot 2 \\
    &amp;= 2 \cdot \mathrm{OPT}_{\text{dual}} \\
    &amp;\le 2 \cdot \mathrm{OPT}
\end{aligned}
\]</span> 以上步骤的第一步是因为我们加入覆盖集的所有顶点对应的约束都是紧的。</p>
<p>主对偶方法神奇的一点就在于：<strong>虽然我们在线性规划的指导下进行设计与分析，但是最后的算法却是一个完全不需要求解线性规划的纯粹的组合算法（Combinatorial Algorithm），因此非常优雅。</strong></p>
<h1 id="再探设施选址">再探设施选址</h1>
<p>回忆之前设施选址的线性规划。<span class="math inline">\(y_i\)</span>表示设施<span class="math inline">\(i\)</span>是否被选，<span class="math inline">\(x_{ij}\)</span>表示用户<span class="math inline">\(j\)</span>是否到设施<span class="math inline">\(i\)</span>去： <span class="math display">\[
\begin{aligned}
    \text{minimize}\quad &amp;\sum_{i\in F}f_iy_i + \sum_{j\in D}\sum_{i \in F}c_{ij}x_{ij} \\
    \text{subject to}\quad &amp;\sum_{i\in F}x_{ij} \ge 1 \quad \forall j\in D \\
    &amp;y_i - x_{ij} \ge 0 \quad \forall i\in F, j\in D \\
    &amp;x_{ij} \ge 0 \quad \forall i\in F, j\in D \\
    &amp;y_i \ge 0 \quad \forall i \in F
\end{aligned}
\]</span> 其对偶为 <span class="math display">\[
\begin{aligned}
    \text{maximize}\quad &amp;\sum_{j \in D}\alpha_j \\
    \text{subject to}\quad &amp;\alpha_j - \beta_{ij} \le c_{ij}\quad \forall i \in F, j\in D \\
    &amp;\sum_{j\in D}\beta_{ij} \le f_i\quad \forall i\in F
\end{aligned}
\]</span></p>
<p>以下将对偶规划中第一行的约束称为“第一类约束”，第二行的约束称为“第二类约束”。</p>
<h2 id="算法">算法</h2>
<p>我们设计一个基于主对偶方法的近似算法：</p>
<ol type="1">
<li>初始化<span class="math inline">\(\alpha_j\gets 0,\beta_{ij}\gets 0\)</span>（平凡的对偶可行解）。</li>
<li>以相同的速率同时增加的值<span class="math inline">\(\alpha_j\)</span>。</li>
<li>当对于某些<span class="math inline">\(i,j\)</span>出现<span class="math inline">\(\alpha_j=c_{ij}\)</span>时，为了能够在不违反第一类约束的前提下让<span class="math inline">\(\alpha_j\)</span>继续增加，我们开始同步增加<span class="math inline">\(\beta_{ij}\)</span>的值。</li>
<li>随着一些<span class="math inline">\(\beta_{ij}\)</span>值的增加某些第二类约束也会收紧，此时暂时开放该约束对应的设施。因为此时对应的<span class="math inline">\(\beta_{ij}\)</span>不能再增加了，那些<span class="math inline">\(\alpha_j\)</span>也自然不会再增加了，我们就此将这些<span class="math inline">\(\alpha_j\)</span>的值冻结起来（其余的<span class="math inline">\(\alpha_j\)</span>可以继续增加）。</li>
<li>不断重复以上步骤直至所有的<span class="math inline">\(\alpha_j\)</span>都被冻结了。</li>
<li>按照第4步开放的先后顺序处理所有暂时开放的设施，
<ol type="1">
<li>永久开放该设施，</li>
<li>并将所有和该设施共享一个“紧顾客”（tight client，指和设施对应约束是紧的顾客，这里实在是不怎么好翻，具体的解释参看下面的感性认识和接下来的分析），即那些两边的<span class="math inline">\(\beta\)</span>都大于<span class="math inline">\(0\)</span>的顾客的暂时开放的设施关闭（移出队列）。</li>
</ol></li>
</ol>
<p>听听这是人话吗？感性理解一下以上算法（也有助于接下来的分析）：</p>
<ol type="1">
<li><span class="math inline">\(\alpha_j\)</span>可以理解为每个顾客为了得到服务愿意付出的代价，一开始所有人都想白嫖。</li>
<li>显然如果大家都想白嫖的话没有一个人会得到服务，因此大家一起提升这个愿意付出的代价。</li>
<li>当<span class="math inline">\(\alpha_j=c_{ij}\)</span>也就是某个顾客发现自己愿意支付的价位内出现了设施的时候他就很高兴。但是这个设施没开，所以顾客决定给这个设施的开放分摊成本（增加<span class="math inline">\(\beta_{ij}\)</span>），但是这样也不是个事，万一不远处有个不需要他付钱或者只需要分摊很少开张费用的设施呢？所以<span class="math inline">\(\alpha_j\)</span>的增长也不能落下。</li>
<li>当有第二类约束收紧，即几个顾客终于凑够了钱让这个设施开放，那么这个设施就暂时开张了。这几个用户很满足，就准备去这个设施了，所以他们的<span class="math inline">\(\alpha_j\)</span>不增加了。</li>
<li>不断重复以上步骤直至满足所有顾客的需求。</li>
<li>按照第4步开放的先后顺序处理暂时开张的设施，
<ol type="1">
<li>永久开张，</li>
<li>如果去这个设施的顾客里有人给其他设施也分摊成本了，那把那些设施全部关掉。</li>
</ol></li>
</ol>
<p>（如果我把上面变量的名字换一下，把“第一类约束”，“第二类约束”也换个名字，那么从上面的算法当中你根本看不到线性规划的痕迹，这就是一个听着很有道理实际上近似比也有保证的组合算法。这就是主对偶方法的优雅之处。）</p>
<h2 id="分析-1">分析</h2>
<p>我们不妨称那些为最后永久开放的设施垫付开张成本的顾客为“幸运顾客”，形式上地来说，一个顾客<span class="math inline">\(j\)</span>为幸运顾客当且仅当最后永久开张的设施中有一处设施<span class="math inline">\(i\)</span>使得<span class="math inline">\(\alpha_j-\beta_{ij}=c_{ij},\beta_{ij}&gt;0\)</span>，也就是说顾客<span class="math inline">\(j\)</span>和设施<span class="math inline">\(i\)</span>之间在对偶规划对应的约束是紧的——这也是上面tight client的本意。</p>
<p>相对地我们称不是幸运顾客的那些顾客“倒霉顾客”，说他们倒霉是因为他们明明给某些设施分摊了开张成本，也都准备好去那里了，结果这个设施在最后关掉了。</p>
<p>不妨设最后决定开张的设施为<span class="math inline">\(F&#39;\)</span>，幸运顾客的集合为<span class="math inline">\(L\)</span>。<span class="math inline">\(j \to i\)</span>表示顾客<span class="math inline">\(j\)</span>到设施<span class="math inline">\(i\)</span>的约束是紧的（也就是顾客<span class="math inline">\(j\)</span>给设施<span class="math inline">\(i\)</span>分摊了成本）。注意由于我们算法最后一步的清理操作，每个幸运顾客只可能垫付一个<span class="math inline">\(F\)</span>中设施的成本，那么设施的开放费用和幸运顾客的服务成本可以一起表示为： <span class="math display">\[
\begin{align}
    &amp;\quad\,\sum_{i\in F&#39;}f_i+\sum_{j\in L} \sum_{\substack{i\in F&#39;\\ j\to i}} c_{ij}\\
    &amp;= \sum_{i \in F&#39;}\sum_{\substack{j\in L\\ j\to i}} \beta _{ij}+\sum_{j\in L} \sum_{\substack{i\in F&#39;\\ j\to i}} \left(\alpha_j - \beta_{ij}\right) \\
    &amp;=\sum_{j \in L} \alpha_{j}
\end{align}
\]</span> 我们接下来分析倒霉顾客的情况。</p>
<p>假设有一个倒霉顾客<span class="math inline">\(k\)</span>，他分摊了设施<span class="math inline">\(b\)</span>的开张成本并最终让设施<span class="math inline">\(b\)</span>暂时开张（同时假设<span class="math inline">\(b\)</span>是他分摊成本的设施中最先开张的——也就是<span class="math inline">\(\alpha_k\)</span>恰在<span class="math inline">\(b\)</span>开张后被冻结）。但是比<span class="math inline">\(b\)</span>早开张的设施<span class="math inline">\(a\)</span>中有一个幸运顾客<span class="math inline">\(j\)</span>也为<span class="math inline">\(b\)</span>分摊了成本，导致最后清理的时候<span class="math inline">\(b\)</span>被关闭了。不妨假设<span class="math inline">\(k\)</span>最后只能去<span class="math inline">\(a\)</span>。注意到由三角不等式， <span class="math display">\[
\begin{align}
c_{ak} &amp;\le c_{aj} + c_{bj} +c_{bk} \\
&amp;\le (\alpha_j-\beta_{aj}) + (\alpha_j - \beta_{bj}) + (\alpha_{k}-\beta_{bk}) \\
&amp;\le \alpha_j+\alpha_j + \alpha_k \\
&amp;\le 3\alpha_k
\end{align}
\]</span> 最后一步之所以成立，是因为<span class="math inline">\(a\)</span>开张后<span class="math inline">\(\alpha_j\)</span>必然冻结，<span class="math inline">\(\alpha_k\)</span>停止增长要等到<span class="math inline">\(b\)</span>开张后。而<span class="math inline">\(a\)</span>比<span class="math inline">\(b\)</span>先开张，因此<span class="math inline">\(\alpha_k \ge \alpha_j\)</span>。我们在上面假设<span class="math inline">\(k\)</span>最后去了<span class="math inline">\(a\)</span>，其实如果最后<span class="math inline">\(k\)</span>去了比<span class="math inline">\(a\)</span>还近的那自然他的服务成本更低了。</p>
<p>因此倒霉顾客的服务成本<span class="math inline">\(\le \sum_{k\in D\setminus L} \alpha_k\)</span>。</p>
<p>结合上述的分析，我们可以得到我们的总成本： <span class="math display">\[
\begin{align}
    \text{total cost} &amp;\le \sum_{j\in L} \alpha_j + \sum_{k\in D\setminus L} 3\alpha_k \\
    &amp;\le 3\sum_{j\in D}\alpha_j \\
    &amp;\le 3\cdot\mathrm{OPT}
\end{align}
\]</span> 也就是说，我们证明了我们这个算法的近似比为<span class="math inline">\(3\)</span>。</p>
<h2 id="为什么最后一步要清理一些暂时开张的设施">为什么最后一步要清理一些暂时开张的设施？</h2>
<p>为什么我们算法的最后一步要清理暂时开张的设施呢？为什么不能一些用户分摊够开张费用就让这个设施永久开张下去呢？</p>
<p>考虑如下的一个实例：</p>
<p>有<span class="math inline">\(n\)</span>个设施，其中<span class="math inline">\(f_1=n+1\)</span>且<span class="math inline">\(f_i=n+2\quad\forall i =2,3,\cdots,n\)</span>。</p>
<p>有<span class="math inline">\(2n\)</span>个顾客。前<span class="math inline">\(n\)</span>名顾客到所有设施的距离都是<span class="math inline">\(1\)</span>。对于后面的<span class="math inline">\(n\)</span>名顾客，第<span class="math inline">\(n+i\)</span>名顾客只和设施<span class="math inline">\(i\)</span>的距离为<span class="math inline">\(1\)</span>，和其余设施的距离都为<span class="math inline">\(3\)</span>。易证这样的边权满足三角不等式。</p>
<p>现在考察我们算法的运行情况：</p>
<ul>
<li><span class="math inline">\(t=0\)</span>，初始化。</li>
<li><span class="math inline">\(t=1\)</span>，所有的<span class="math inline">\(\alpha_j=1\)</span>，每名顾客开始为至少一个设施分摊成本了。</li>
<li><span class="math inline">\(t=2\)</span>，对于任何一个设施都有<span class="math inline">\(n+1\)</span>名顾客为其人均分摊了<span class="math inline">\(1\)</span>的开张成本，而注意到<span class="math inline">\(f_1=n+1\)</span>，因此设施<span class="math inline">\(1\)</span>开张了，相应地，前<span class="math inline">\(n\)</span>名顾客和第<span class="math inline">\(n+1\)</span>名顾客的<span class="math inline">\(\alpha_j\)</span>被冻结。其余的<span class="math inline">\(n-1\)</span>名顾客继续为对应的设施分摊费用。</li>
<li><span class="math inline">\(t=3\)</span>，剩下的<span class="math inline">\(n-1\)</span>家设施全部开张。</li>
</ul>
<p>如果没有最后的清理步骤，那么我们的算法会开放所有的设施。光是开放设施的代价就有<span class="math inline">\(n+1+(n-1)(n+2)=\Omega(n^2)\)</span>。而只开一家设施的代价是<span class="math inline">\(O(n)\)</span>的。因此最后的清理步骤非常重要！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chengyuan Ma</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js" integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha512-br8H6OngKoLht57WKRU5jz3Vr0vF+Tw4G6yhNN2F3dSDheq4JiaasROPJB1wy7PxPk7kV/+5AIbmoZLxxx7Zow==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-bash.min.js" integrity="sha512-JvRd44DHaJAv/o3wxi/dxhz2TO/jwwX8V5/LTr3gj6QMQ6qNNGXk/psoingLDuc5yZmccOq7XhpVaelIZE4tsQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-c.min.js" integrity="sha512-T6Lco61aWqCKSznWkd38lf159pD0+EwZ9UCEv6ARAvaWFiy/UHtYgOmlasT8lq5Ck17ZNHzbe5eHUablTGRXxw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cmake.min.js" integrity="sha512-M99z3be36IUB5pA3DWoJvjSYaZA9BiUqf1jXzVcjntASBZFNI53oDRzdJqGzH5voybcAx5Sg8F5QyryE6afD3g==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cpp.min.js" integrity="sha512-hxZJ6OUEpUl9/o4C1gMGvrAbeqDaldBiZbs08c/V8NcU7YImBFlqJAc7Uzjf3bh2W8Wx26/dVDyPk9cUMQY0Mw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-go.min.js" integrity="sha512-SgF1uayJ2/8TV+MhLasqygnm++vYRXswmrR2ZAmUCL4pXtf+6KzUgXPpn10Y6xca658sxOQEOsoP3MChfhke5A==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-java.min.js" integrity="sha512-PWHY6Vao4E9K4LsGBYCY0ttDeiWZwuUozTbJvSy9UFHRz2J4Bl7rcWML3wEnJTVuCJhSwGne/8My5gTo/gnbpg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-json.min.js" integrity="sha512-IC7rV8RslChgByOdUFC6ePqOGn+OwJhnKC3S5AezM8DAiOdGhJMwgsIvBChsa2yuxxoPbH2+W/kjNUM1cc+jUQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-kotlin.min.js" integrity="sha512-aTozTdtORp/xxS/dhRRDfmv/p1eyEMTje96MplkSOqdbKGGvOYIlogoGdtsh/BD91vaqKoAw9M7O/DodqqudIQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-julia.min.js" integrity="sha512-eTGeKQdDzC2rPAUVfM2Fa36s9B9wp138NEhzZqJpRSdJQ66BwLUot25r2YQveCRU5uYNVfX3gckDkl4byfBIWw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-latex.min.js" integrity="sha512-6D3l3Fy8g/hr6AeK2g1rcVZHyFjCqiqgUrwy0mBZTGFd8UwVcUDhzQeIIv3eYeXDecGPTtBOS9ctyRzJyUgypQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-rust.min.js" integrity="sha512-kgT7r2HlCEO4b+Rp3nJvm+/EMBwGMvv1WMdWkb3eNgnS91llMli8Y3T1CgnD8Hifqx50Q3XLUQXDd7PzKQQtUA==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-python.min.js" integrity="sha512-wK9tQmDrstGtZqTKcyVf3h457QGMlNriKs+fHmEkiCizrq0LVovfT3v1smeT1DlQetHhdRkkX1JSuZg5LoNHJg==" crossorigin="anonymous"></script>
<script type = "text/javascript">
    document.addEventListener('pjax:complete', function() {
        if (typeof Prism !== 'undefined') {
            Prism.highlightAll();
        }
    });
</script>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  






  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    <div class="pjax">

  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



    </div>
</body>
</html>
