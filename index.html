<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"alan20210202.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="不务正业高中生一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="Chengyuan Ma&#39;s Blog">
<meta property="og:url" content="https://alan20210202.github.io/index.html">
<meta property="og:site_name" content="Chengyuan Ma&#39;s Blog">
<meta property="og:description" content="不务正业高中生一枚">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chengyuan Ma">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://alan20210202.github.io/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.css" integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbggqjHJeyzx88I3rfwjS38WJag/ihH7lzuGlGHpDBymLirZQ==" crossorigin="anonymous" />
<title>Chengyuan Ma's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-65HSG5NCY6"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-65HSG5NCY6');
      }
    </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Chengyuan Ma's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-pagedewarp"><a href="/dewarp/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>PageDewarp</a></li>
        <li class="menu-item menu-item-english"><a href="/english/" rel="section"><i class="fa fa-globe-americas fa-fw"></i>English</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chengyuan Ma"
      src="/avatar.png">
  <p class="site-author-name" itemprop="name">Chengyuan Ma</p>
  <div class="site-description" itemprop="description">不务正业高中生一枚</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">91</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://kalasearch.cn/" title="https:&#x2F;&#x2F;kalasearch.cn&#x2F;" rel="noopener" target="_blank">卡拉搜索</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/04/18/Projection%20and%20Least%20Square/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/18/Projection%20and%20Least%20Square/" class="post-title-link" itemprop="url">投影、最小二乘拟合与QR分解笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-18 14:37:09" itemprop="dateCreated datePublished" datetime="2021-04-18T14:37:09+08:00">2021-04-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-19 13:15:17" itemprop="dateModified" datetime="2021-04-19T13:15:17+08:00">2021-04-19</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="投影">投影</h1>
<p>高中的时候就学过，向量<span class="math inline">\(\vec b\)</span>在<span class="math inline">\(\vec a\)</span>上的投影为 <span class="math display">\[
\vec p = \frac{\vec a^{\mathrm T}\vec b}{\vec a^{\mathrm T}\vec a} \cdot \vec a
\]</span> 当时推导主要利用了点积的几何意义$a b = |a||b|$。在代数意义上上式是怎么推导的呢？</p>
<p>其实也不难：注意到<span class="math inline">\(\vec b\)</span>和其投影<span class="math inline">\(\vec p\)</span>的差一定是垂直于基向量<span class="math inline">\(\vec a\)</span>的。因为<span class="math inline">\(\vec p\)</span>与<span class="math inline">\(\vec a\)</span>平行，设<span class="math inline">\(\vec p = x\vec a\)</span> <span class="math display">\[
\begin{aligned}
    \vec a^{\mathrm T}\left(\vec b - x\vec a\right) &amp;= 0 \\
    \Rightarrow \vec a^{\mathrm T}x\vec a &amp;= \vec a^{\mathrm T}\vec b \\
    \Rightarrow x\vec a^{\mathrm T}\vec a &amp;= \vec a^{\mathrm T}\vec b \\
    \Rightarrow x &amp;= \frac{\vec a^{\mathrm T}\vec b}{\vec a^{\mathrm T}\vec a}
\end{aligned}
\]</span> 我们就得到了一开始的结论。如果把<span class="math inline">\(\vec a\)</span>写到左边（因为是向量的实数积所以可以交换） <span class="math display">\[
p = \vec a\cdot \frac{\vec a^{\mathrm T}\vec b}{\vec a^{\mathrm T}\vec a} = \frac{\vec a\vec a^{\mathrm T}}{\vec a^{\mathrm T}\vec a}\vec b
\]</span> 我们这下看清楚了：将<span class="math inline">\(\vec b\)</span>转变为其在<span class="math inline">\(\vec a\)</span>上的投影的是一个矩阵！这个矩阵<span class="math inline">\(P = \frac{\vec a\vec a^{\mathrm T}}{\vec a^{\mathrm T}\vec a}\)</span>被称为<strong>投影矩阵</strong>。</p>
<p>代数推导和投影矩阵有啥用？它们可以让我们把投影从投影到一个向量推广到投影到向量空间。</p>
<p>考虑如何把一个向量<span class="math inline">\(\vec b\)</span>投影到矩阵<span class="math inline">\(A = \begin{bmatrix} \vec {a_1} &amp;\vec {a_2} &amp;\cdots &amp;\vec {a_n}\end{bmatrix}\)</span>的列空间上（假设<span class="math inline">\(A\)</span>的列向量线性无关）。我们一样考虑<span class="math inline">\(\vec b\)</span>与<span class="math inline">\(\vec p\)</span>的差，其一定垂直于<span class="math inline">\(C(A)\)</span>，自然也垂直于<span class="math inline">\(\vec {a_1} \cdots \vec {a_n}\)</span>，于是就有： <span class="math display">\[
\vec {a_k} ^{\mathrm T}\left(\vec b - \vec p\right) = 0, \quad k = 1,2,\cdots,n
\]</span> 或者写在一起： <span class="math display">\[
\begin{bmatrix}
    \vec {a_1}^{\mathrm T} \\
    \vec {a_2}^{\mathrm T} \\
    \vdots \\
    \vec {a_n}^{\mathrm T} \\
\end{bmatrix}
\left(\vec b  - \vec p\right) = \vec 0 \Rightarrow 
A^{\mathrm T} \left(\vec b  - \vec p\right) = \vec 0
\]</span> 因为<span class="math inline">\(\vec p \in C(A)\)</span>，所以<span class="math inline">\(\vec p\)</span>是<span class="math inline">\(A\)</span>列向量的线性组合，可以写作<span class="math inline">\(\vec p = A\vec x\)</span>。于是我们就得到了方程 <span class="math display">\[
A^{\mathrm T} \left(\vec b  - A\vec x\right) = \vec 0 \Rightarrow A^{\mathrm T}A\vec x = A^{\mathrm T}\vec b
\]</span> 因为<span class="math inline">\(A\)</span>的列是线性无关的，所以<span class="math inline">\(A^{\mathrm T}A\)</span>是可逆的（这个我们待会证明），于是我们可以解得 <span class="math display">\[
\vec x = \left(A^{\mathrm T}A\right)^{-1}A^{\mathrm T}\vec b
\]</span> 即 <span class="math display">\[
\vec p = A\left(A^{\mathrm T}A\right)^{-1}A^{\mathrm T}\vec b
\]</span> 此时我们很清楚地看到，投影矩阵是<span class="math inline">\(P = A\left(A^{\mathrm T}A\right)^{-1}A^{\mathrm T}\)</span>。</p>
<hr />
<p>我们接下来证明之前我们用到的一个结论：<strong><span class="math inline">\(A^{\mathrm T}A\)</span>可逆的充分必要条件是<span class="math inline">\(A\)</span>的列向量线性无关</strong>。</p>
<p>我们发现这个结论等价于：<span class="math inline">\(A^{\mathrm T}A\)</span>和<span class="math inline">\(A\)</span>有相同的零空间。</p>
<p>怎么证明？一个方向是简单的： <span class="math display">\[
A\vec x = \vec 0 \Rightarrow A^{\mathrm T}\left(A\vec x\right) = \vec 0 \Rightarrow A^{\mathrm T} A\vec x = \vec 0
\]</span> 反方向的证明需要一些技巧： <span class="math display">\[
A^{\mathrm T} A\vec x = \vec 0 \Rightarrow \vec x^{\mathrm T} A^{\mathrm T} A\vec x = 0 \Rightarrow \left(A\vec x\right)^{\mathrm T}A\vec x = 0 \Rightarrow A\vec x = \vec 0
\]</span> 倒数第二步写得有点花里胡哨其实就是向量自己和自己的点积，如果是零的话显然原向量就是零。</p>
<p>证毕。</p>
<h1 id="最小二乘拟合">最小二乘拟合</h1>
<p>投影和最小二乘拟合是怎么联系起来的呢？</p>
<p>线性拟合的本质是用给定的若干列向量的线性组合表示另一个向量。</p>
<p>比如我有一组数据<span class="math inline">\(\vec x,\vec y\)</span>，我的模型是<span class="math inline">\(y = a + bx\)</span>，拟合的过程就是用向量<span class="math inline">\(\vec 1\)</span>和<span class="math inline">\(\vec x\)</span>的线性组合表示<span class="math inline">\(\vec y\)</span>的过程： <span class="math display">\[
\begin{bmatrix}
    1 &amp;x_1 \\
    1 &amp;x_2  \\
    \vdots &amp;\vdots\\
    1 &amp;x_n 
\end{bmatrix}
\begin{bmatrix}
    a \\
    b
\end{bmatrix} \stackrel{?}{=} 
\begin{bmatrix}
    y_1 \\
    y_2 \\
    \vdots \\
    y_n 
\end{bmatrix}
\]</span> “线性拟合”的线性指的是这种组合的线性，和模型本身的线性是没有关系的。模型里面有二次项不要紧，只要二次项和其他项是线性组合的，那也不过是在左边的矩阵里多了一个列向量而已： <span class="math display">\[
\begin{bmatrix}
    1 &amp;x_1 &amp;x_1^2 \\
    1 &amp;x_2 &amp;x_2^2 \\
    \vdots &amp;\vdots &amp;\vdots \\
    1 &amp;x_n &amp;x_n^2
\end{bmatrix}
\begin{bmatrix}
    a \\
    b \\
    c
\end{bmatrix} \stackrel{?}{=} 
\begin{bmatrix}
    y_1 \\
    y_2 \\
    \vdots \\
    y_n 
\end{bmatrix}
\]</span> 那么我们发现线性拟合的本质其实就是解一个形如<span class="math inline">\(A\vec x = \vec b\)</span>的方程组（这里的<span class="math inline">\(\vec x\)</span>表示模型中各项的系数，和上面表示自变量的<span class="math inline">\(\vec x\)</span>没有关系），这个我们老熟悉了。</p>
<p>但是事情不太妙的就是<span class="math inline">\(A\)</span>又高又瘦，方程组比未知数多，所以几乎肯定不存在准确解。</p>
<p>什么时候存在准确解？<span class="math inline">\(\vec b\)</span>要在<span class="math inline">\(A\)</span>的列空间<span class="math inline">\(C(A)\)</span>里。</p>
<p>所以如果只能求近似解，我们可以考虑把<span class="math inline">\(\vec b\)</span>“近似到”<span class="math inline">\(C(A)\)</span>中的一个最近的向量，然后就能求解了。</p>
<p>这个“近似”的过程其实就是投影。在<span class="math inline">\(C(A)\)</span>中<span class="math inline">\(\vec b\)</span>的投影肯定最接近<span class="math inline">\(\vec b\)</span>，因为只有二者的差是和<span class="math inline">\(C(A)\)</span>垂直的，这很符合我们的代数直觉。</p>
<p>所以联系之前的投影的推导，假设这个投影向量是<span class="math inline">\(A\vec{\hat{x}}\)</span>，我们直接写出方程和解： <span class="math display">\[
A^{\mathrm T} \left(\vec b  - A\vec{\hat{x}} \right) = \vec 0 \Rightarrow \vec{\hat{x}} = \left(A^{\mathrm T}A\right)^{-1}A^{\mathrm T}\vec b
\]</span> 这就叫“最小二乘拟合”。</p>
<hr />
<p>如果非要较真，从微积分的角度理解一波也是可以的：定义拟合的误差函数为 <span class="math display">\[
L= \left|\vec b - A\vec{\hat x}\right| = \sum_{i = 1}^n \left(\vec b_i - \left(A\vec{\hat x}\right)_i\right)^2
\]</span> 如果要最小化<span class="math inline">\(L\)</span>，那么<span class="math inline">\(L\)</span>关于<span class="math inline">\(\vec{\hat x}\)</span>的所有分量的导数都为<span class="math inline">\(0\)</span>： <span class="math display">\[
\frac{\mathrm d L}{\mathrm d\vec{\hat x}_k} = 2\sum_{i = 1}^n A_{i, k} \left(\left(A\vec{\hat x}\right)_i - \vec b_i\right) =  0, \quad \forall k = 1, 2, \cdots, n
\]</span> 令<span class="math inline">\(A\)</span>第<span class="math inline">\(i\)</span>列的列向量为<span class="math inline">\(\vec a_i\)</span>，那么上面也可以写成 <span class="math display">\[
\frac{\mathrm d L}{\mathrm d\vec{\hat x}_k} = 2\vec a_k^{\mathrm T} \left(A\vec{\hat x} - \vec b\right) =  0, \quad \forall k = 1, 2, \cdots, n
\]</span> 并在一起得 <span class="math display">\[
2A^{\mathrm T}\left(A\vec{\hat x} - \vec b\right) =  0
\]</span> 这就是上面我们通过投影推出的方程。</p>
<p><span class="math inline">\(L\)</span>中的平方项也是最小二乘中“二”的由来。</p>
<h1 id="矩阵的gram-schmidt正交化">矩阵的Gram-Schmidt正交化</h1>
<p>我们发现无论是投影还是最小二乘拟合，计算<span class="math inline">\(A^{\mathrm T}A\)</span>和它的逆都是绕不过去的一步。<span class="math inline">\(A^{\mathrm T}A\)</span>本身就有一些特殊的性质，比如说其一定是正方阵，一定是对称的（通过转置等于自身易证）。但是这些性质在计算的时候帮助不大。如果我们能够优化<span class="math inline">\(A\)</span>的形态从而简化<span class="math inline">\(A^{\mathrm T}A\)</span>和它的逆的计算，那么各种算法的效率都会高上不少。</p>
<p>注意到<span class="math inline">\(A^{\mathrm T}A\)</span>中的每一个位置都是<span class="math inline">\(A\)</span>两个列向量的点积。<strong>如果<span class="math inline">\(A\)</span>当中的列向量是两两正交的，那么<span class="math inline">\(A^{\mathrm T}A\)</span>就变成了一个对角阵。对角阵的逆不要太好算！更进一步，如果<span class="math inline">\(A\)</span>的每一个列向量都是单位向量，那么<span class="math inline">\(A^{\mathrm T}A\)</span>就是单位阵，连逆都不用求了</strong>！</p>
<p>所以说啊，正交是个好东西。那对于一个矩阵<span class="math inline">\(A\)</span>，通过什么样的方式将其列向量完成正交化呢？</p>
<p>比较简单的一个算法称为Gram-Schmidt正交化。设<span class="math inline">\(A\)</span>的列向量为<span class="math inline">\(\vec {a_1},\cdots, \vec{a_n}\)</span>，则向量正交化之后的结果<span class="math inline">\(\vec{q_i}\)</span>可以这么计算： <span class="math display">\[
\vec{q_i} = \vec{a_i} - \sum_{j = 1}^{i - 1} \frac{\vec{q_j}^{\mathrm T}\vec{a_i}}{\vec{q_j}^{\mathrm T}\vec{q_j}} \vec{q_j}
\]</span> 即对于第<span class="math inline">\(i\)</span>个列向量通过减去其在所有之前的（完成正交化的）向量上的投影来确保其和前面的向量都正交。</p>
<p>最后，把所有的<span class="math inline">\(\vec{q_i}\)</span>除以其模完成归一化，我们就可以得到一个标准正交列向量组成的矩阵<span class="math inline">\(Q\)</span>，满足<span class="math inline">\(Q^{\mathrm T}Q = I\)</span>。（线性代数中常使用<span class="math inline">\(Q\)</span>表示列向量标准正交的矩阵）</p>
<p>从<span class="math inline">\(A\)</span>变到<span class="math inline">\(Q\)</span>的过程没有改变列空间，所以不会改变投影矩阵，但计算投影矩阵的开销大大降低了： <span class="math display">\[
P = Q\left(Q^{\mathrm T}Q\right)^{-1}Q^{\mathrm T} = QQ^{\mathrm T}
\]</span></p>
<h1 id="qr分解">QR分解</h1>
<p>Gram-Schmidt正交化的过程可以看作是在原矩阵上进行列变换，而列变换是可以用矩阵表示的。类比从高斯消元导出LU分解的思路，我们可以从Gram-Schimidt正交化导出一个矩阵的QR分解： <span class="math display">\[
A = QR
\]</span> 我们有<span class="math inline">\(A\)</span>，可以通过Gram-Schmidt正交化算出<span class="math inline">\(Q\)</span>，但<span class="math inline">\(R\)</span>怎么计算呢？因为<span class="math inline">\(Q^{\mathrm T}Q=I\)</span>，所以只要在等式两边同时乘以<span class="math inline">\(Q^{\mathrm T}\)</span>，就得到<span class="math inline">\(R=Q^{\mathrm T}A\)</span>。或者用<span class="math inline">\(Q\)</span>和<span class="math inline">\(A\)</span>的列向量表示： <span class="math display">\[
R = \begin{bmatrix}
    \vec{q_1}^{\mathrm T} \\
    \vec{q_2}^{\mathrm T} \\
    \vdots \\
    \vec{q_n}^{\mathrm T}
\end{bmatrix}
\begin{bmatrix}
    \vec{a_1} &amp;\vec{a_2} &amp;\cdots &amp;\vec{a_n}
\end{bmatrix}
= \begin{bmatrix}
    \vec{q_1}^{\mathrm T}\vec{a_1} &amp;\vec{q_1}^{\mathrm T}\vec{a_2} &amp;\cdots &amp;\vec{q_1}^{\mathrm T}\vec{a_n} \\
    \vec{q_2}^{\mathrm T}\vec{a_1} &amp;\vec{q_2}^{\mathrm T}\vec{a_2} &amp;\cdots &amp;\vec{q_2}^{\mathrm T}\vec{a_n} \\
    \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\
    \vec{q_n}^{\mathrm T}\vec{a_1} &amp;\vec{q_n}^{\mathrm T}\vec{a_2} &amp;\cdots &amp;\vec{q_n}^{\mathrm T}\vec{a_n}
\end{bmatrix}
\]</span> 注意到，因为<span class="math inline">\(\vec{q_i}\)</span>正交于所有<span class="math inline">\(\vec {q_j}(i &lt; j)\)</span>，而<span class="math inline">\(\vec{a_j}\)</span>又是由<span class="math inline">\(\vec{q_1},\cdots,\vec{q_j}\)</span>表示的，所以<span class="math inline">\(i &gt; j\)</span>时，<span class="math inline">\(\vec{q_i}^{\mathrm T}\vec{a_j} = 0\)</span>。所以<span class="math inline">\(R\)</span><strong>其实是一个上三角阵</strong>： <span class="math display">\[
R = \begin{bmatrix}
    \vec{q_1}^{\mathrm T}\vec{a_1} &amp;\vec{q_1}^{\mathrm T}\vec{a_2} &amp;\cdots &amp;\vec{q_1}^{\mathrm T}\vec{a_n} \\
    0 &amp;\vec{q_2}^{\mathrm T}\vec{a_2} &amp;\cdots &amp;\vec{q_2}^{\mathrm T}\vec{a_n} \\
    \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\
    0 &amp;0 &amp;\cdots &amp;\vec{q_n}^{\mathrm T}\vec{a_n}
\end{bmatrix}
\]</span> 再观察<span class="math inline">\(R\)</span>的各个非零位置的值以及Gram-Schimidt的公式，其实<span class="math inline">\(R\)</span>是可以在计算Gram-Schmidt正交化的时候顺便算出来的。</p>
<p>QR分解有什么用呢？之前我们说正交化不改变投影矩阵，原因是“正交化不改变列空间”，QR分解能让我们在代数上证明这一点： <span class="math display">\[
\begin{aligned}
    P &amp;= A\left(A^{\mathrm T}A\right)^{-1}A^{\mathrm T} \\
    &amp;= QR\left(R^{\mathrm T}Q^{\mathrm T}QR\right)^{-1}R^{\mathrm T}Q^{\mathrm T} \\
    &amp;= QR\left(R^{\mathrm T}R\right)^{-1}R^{\mathrm T}Q^{\mathrm T} \\
    &amp;= QRR^{-1}\left(R^{\mathrm T}\right)^{-1}R^{\mathrm T}Q^{\mathrm T} \\
    &amp;= QQ^{\mathrm T}
\end{aligned}
\]</span> 注：因为<span class="math inline">\(R\)</span>是一个方阵，所以我们这里能够把<span class="math inline">\(\left(R^{\mathrm T}R\right)^{-1}\)</span>改写成<span class="math inline">\(R^{-1}(R^{\mathrm T})^{-1}\)</span>。<span class="math inline">\(\left(A^{\mathrm T}A\right)^{-1}\)</span>是不能这么转换的，因为长方阵不存在常规意义上的逆。</p>
<p>类似地，QR分解还简化了最小二乘拟合的计算： <span class="math display">\[
\vec{\hat{x}} = \left(A^{\mathrm T}A\right)^{-1}A^{\mathrm T}\vec b = R^{-1}Q^{\mathrm T}\vec b
\]</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/04/16/Four%20Spaces/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/16/Four%20Spaces/" class="post-title-link" itemprop="url">线性代数四大空间笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-16 17:02:06" itemprop="dateCreated datePublished" datetime="2021-04-16T17:02:06+08:00">2021-04-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-17 16:03:07" itemprop="dateModified" datetime="2021-04-17T16:03:07+08:00">2021-04-17</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>以下是读Gilbert Strang的<em>Introduction to Linear Algebra</em>的后回忆整理的笔记。内容大概包括第三节和第四节开头的一部分。</p>
<h1 id="四大空间">四大空间</h1>
<p>对于矩阵<span class="math inline">\(A\in \mathbb{R}^{m\times n}\)</span>，定义</p>
<ol type="1">
<li><span class="math inline">\(A\)</span>的列空间为其所有列向量的张成空间，<span class="math inline">\(A\)</span>的列向量的线性组合记作<span class="math inline">\(A\vec{x}=\vec b\)</span>——因此所有这个形式的<span class="math inline">\(\vec b\)</span>都属于<span class="math inline">\(A\)</span>的列空间。记作<span class="math inline">\(C(A)\)</span>。<span class="math inline">\(C(A)\subset\mathbb{R}^m\)</span>。</li>
<li><span class="math inline">\(A\)</span>的零空间为令其列向量线性组合为零的组合构成的空间，即所有满足<span class="math inline">\(A\vec{x}=\vec 0\)</span>的向量<span class="math inline">\(\vec x\)</span>。记作<span class="math inline">\(N(A)\)</span>。<span class="math inline">\(N(A)\subset \mathbb{R}^n\)</span>。</li>
<li><span class="math inline">\(A\)</span>的行空间为其所有行向量的张成空间。因为<span class="math inline">\(A\)</span>的行向量都是<span class="math inline">\(A^{\mathrm{T}}\)</span>的列空间，所以行空间可以记作<span class="math inline">\(C\left(A^{\mathrm T}\right)\)</span>。<span class="math inline">\(C\left(A^{\mathrm T}\right) \subset \mathbb{R}^{n}\)</span>。</li>
<li><span class="math inline">\(A\)</span>的左零空间为令其行向量线性组合为零的组合构成的空间，即所有满足<span class="math inline">\(\vec{x}^{\mathrm T}A = \vec 0^{\mathrm T}\)</span>的向量<span class="math inline">\(\vec{x}\)</span>，现在<span class="math inline">\(\vec x\)</span>在左边，所以和零空间相比就叫左零空间了。左零空间自然可以记作<span class="math inline">\(C\left(A^{\mathrm T}\right)\)</span>。<span class="math inline">\(C\left(A^{\mathrm T}\right) \subset \mathbb{R}^{m}\)</span>。</li>
</ol>
<p>以上就是线性代数当中比较重要的四个空间。虽然有四个，但本质只有“列空间”和“零空间”两种。基于矩阵的定义是颇有些枯燥的。矩阵只是线性变换比较常用且典型的形式，列空间和零空间的定义并不局限于此。归根结底，<strong>列空间是线性变换的“值域”，零空间是线性变换的“零点”</strong>。</p>
<p><sub>注：列空间在一些地方也叫做像空间（image），零空间在一些地方也叫做核（kernel）。个人认为，对于一般的线性变换，像空间的称谓比列空间更为恰当，但kernel这个词就有些莫名奇妙——我没有了解过相关的背景，但我觉得零空间的叫法更为直观。</sub></p>
<h1 id="向量空间的维度">向量空间的维度</h1>
<p>向量空间的维度定义为这个空间任何一组基包含的向量个数。这个定义蕴含的一个事实是：对于同一个向量空间，无论其基如何选取，其大小都是相同的。这里摘录一个书上的证明：</p>
<p><strong>证明：</strong> 假设向量空间<span class="math inline">\(\mathbf V\)</span>的两组基为<span class="math inline">\(\vec{v_1},\vec{v_2},\cdots,\vec{v_n}\)</span>和<span class="math inline">\(\vec{w_1}, \vec{w_2}, \cdots ,\vec{w_m}\)</span>。运用反证法，不失一般性，设<span class="math inline">\(n &lt; m\)</span>。因为<span class="math inline">\(\vec{v_1},\vec{v_2},\cdots,\vec{v_n}\)</span>是基，所以任意<span class="math inline">\(\vec{w_k}\)</span>都可以用他们的线性组合表示。即 <span class="math display">\[
\vec{w_k} = \begin{bmatrix}
    \vec{v_1} &amp;\vec{v_2} &amp;\cdots &amp;\vec{v_n}  
\end{bmatrix}\cdot \vec{a}
\]</span> （回忆一下，矩阵左乘向量等于按照向量的系数对矩阵的列向量进行线性组合）</p>
<p>进一步地， <span class="math display">\[
\begin{bmatrix}
    \vec{w_1} &amp;\vec{w_2} &amp;\cdots &amp;\vec{w_m}  
\end{bmatrix}= 
\begin{bmatrix}
    \vec{v_1} &amp;\vec{v_2} &amp;\cdots &amp;\vec{v_n}  
\end{bmatrix}\cdot A
\]</span> 不难发现，<span class="math inline">\(A\)</span>是<span class="math inline">\(n\)</span>行<span class="math inline">\(m\)</span>列的矩阵，而<span class="math inline">\(n &lt; m\)</span>，所以<span class="math inline">\(A\)</span>是扁的。在代数上，齐次线性方程组的变量多于方程数，也就是说<span class="math inline">\(A\vec{x} = \vec{0}\)</span>有非平凡解。 <span class="math display">\[
\begin{aligned}
    A\vec{x} &amp;= \vec{0} \\
    \Rightarrow \begin{bmatrix}
    \vec{v_1} &amp;\vec{v_2} &amp;\cdots &amp;\vec{v_n}  
\end{bmatrix} A\vec{x} &amp;= \vec{0} \\
    \Rightarrow \begin{bmatrix}
    \vec{w_1} &amp;\vec{w_2} &amp;\cdots &amp;\vec{w_m}  
\end{bmatrix} \vec{x} &amp;= \vec{0}
\end{aligned}
\]</span> 也就是说，<span class="math inline">\(\vec{w_1}, \vec{w_2}, \cdots ,\vec{w_m}\)</span>线性相关，推出矛盾，证毕。</p>
<h1 id="四大空间的维度">四大空间的维度</h1>
<p>一个矩阵四大空间的维度可以通过将其化简为行简化阶梯型（reduced row echelon form）来计算。行简化阶梯型的定义</p>
<ol type="1">
<li>阶梯型/上三角型矩阵</li>
<li>主元位置都是<span class="math inline">\(1\)</span></li>
<li>主元正上方都是<span class="math inline">\(0\)</span></li>
</ol>
<p>例如 <span class="math display">\[
\operatorname{rref}\left(
\begin{bmatrix}
    1 &amp;1 &amp;2 &amp;4\\
    1 &amp;2 &amp;2 &amp;5\\
    1 &amp;3 &amp;2 &amp;6
\end{bmatrix}
\right)
=
\begin{bmatrix}
    1 &amp;0 &amp;2 &amp;3\\
    0 &amp;1 &amp;0 &amp;1\\
    0 &amp;0 &amp;0 &amp;0
\end{bmatrix}
\]</span> 行简化阶梯型矩阵可以通过原矩阵的初等行变换得到（高斯消元）。</p>
<p>行简化阶梯型矩阵当中主元的个数称为矩阵的<strong>秩</strong>（rank）。我们首先注意到，对于一个行简化阶梯型矩阵<span class="math inline">\(A\)</span>，</p>
<ol type="1">
<li><strong>它列空间的维度是它的秩</strong>：主元列显然是线性无关的，而非主元列显然可以用主元列的线性组合表示（系数就写在列里面呢，比如说在上面的例子中，第四列是第一列的<span class="math inline">\(3\)</span>倍和第二列的<span class="math inline">\(1\)</span>倍之和）。</li>
<li><strong>它行空间的维度也是它的秩</strong>：行简化阶梯型的形态让我们不难发现每一个非零行都是线性无关的。原因在于每个非零行都包含一个主元，而只有那一行在主元的那一列是<span class="math inline">\(1\)</span>。</li>
<li><strong>它零空间的维度是列数与秩之差</strong>，即非主元列的个数：从方程<span class="math inline">\(A\vec x = \vec 0\)</span>的角度看，非主元列代表自由变量。通过令一个自由变量为<span class="math inline">\(1\)</span>，令其余自由变量为<span class="math inline">\(0\)</span>，并依此计算主元，我们可以得到和自由变量同样数目的若干“解向量”。这些解向量线性无关，都处在零空间中，且张成整个零空间，因此是零空间的一个基。</li>
<li><strong>它左零空间的维度是行数与秩之差</strong>，即零行的个数：非零行线性无关，因此要使行的线性组合为零所有非零行的系数必须为零，零行的系数任意，因此左零空间的维度就是零行的个数。</li>
</ol>
<p>接下来，我们观察到<strong>从一般矩阵化简为行简化阶梯型的过程不会改变矩阵的四个空间的维度</strong>：</p>
<ol type="1">
<li>初等行变换不会改变列向量之间的线性关系——对于所有列来说，行变换是“一荣俱荣，一损俱损”的。如果原来矩阵的第三列是第一列的两倍，那么行变换之后第三列还是第一列的两倍。如果原来矩阵的第二列是第一列和第三列的和，那么行变换之后这个和的关系不变。</li>
<li>因为列向量之间的线性关系没有变，所以零空间不会变，列空间的维数也不会变（但列空间本身会变）。</li>
<li>行变换是对行的线性组合，所以行简化阶梯型的行空间是原矩阵行空间的子集；而高斯消元的行变换是可逆的，所以原矩阵的行空间也是行简化阶梯型行空间的子集。因此，化简到行简化阶梯型的过程当中，行空间不变。</li>
<li>行简化阶梯型只是揭示而并非改变行向量之间的线性相关关系（行简化阶梯型中的零行表示原来的行向量和上面几行的行向量线性相关）。原来线性无关的行不会因为行变换就线性相关，反之亦然。因此左零空间的维数是不会变的。</li>
</ol>
<p>所以，一般矩阵的秩也就可以定义为其对应行简化阶梯形矩阵的秩，一般矩阵的四大空间的维度也可以用其秩计算了。</p>
<h1 id="四大空间维度的奇妙关联">四大空间维度的奇妙关联</h1>
<p>简要地总结一下，对于一个<span class="math inline">\(m\)</span>行<span class="math inline">\(n\)</span>列秩<span class="math inline">\(r\)</span>的矩阵<span class="math inline">\(A\)</span>，有</p>
<ol type="1">
<li><span class="math inline">\(\dim\left(C(A)\right) = r\)</span></li>
<li><span class="math inline">\(\dim\left(N(A)\right) = n - r\)</span></li>
<li><span class="math inline">\(\dim\left(C\left(A^{\mathrm T}\right)\right) = r\)</span></li>
<li><span class="math inline">\(\dim\left(N\left(A^{\mathrm T}\right)\right) = m - r\)</span></li>
</ol>
<p>然后我们整理一下就发现 <span class="math display">\[
\begin{aligned}
    \dim\left(C(A)\right) + \dim\left(N(A)\right) &amp;= n = \dim\left(\mathbb{R}^n\right) \\
    \dim\left(C\left(A^{\mathrm T}\right)\right) + \dim\left(N\left(A^{\mathrm T}\right)\right) &amp;= m = \dim\left(\mathbb{R}^m\right)
\end{aligned}
\]</span> 有什么意义？注意到<span class="math inline">\(A\)</span>可以看作一个线性变换，其定义域所在的空间是<span class="math inline">\(\mathbb{R}^n\)</span>。<span class="math inline">\(A^{\mathrm T}\)</span>也是如此。结合零空间和列空间的意义，我们发现了这样一个关系：</p>
<p><strong>线性变换定义域（输入）的维度，等于零空间与值域（输出）维度之和。</strong></p>
<p>好理解不？一个输入的部分维度在线性变换中“卷入零空间”消失了，只有剩下的维度反映在输出中。</p>
<p>高屋建瓴，妙不可言。这个关系具有震撼人心的力量。自己前几天在学校阅览室读到这一行，差点拍案叫绝。</p>
<p>线性代数是简洁的。</p>
<p>线性代数是优美的。</p>
<p>莫不如是。</p>
<p>这有啥用处？</p>
<p>书后有一个习题</p>
<blockquote>
<p>定义两个子向量空间<span class="math inline">\(\mathbf{V}\)</span>和<span class="math inline">\(\mathbf W\)</span>的和<span class="math inline">\(\mathbf{V} + \mathbf{W}\)</span>为二者中任意向量组合形成的空间（即二者基的并的张成空间）。</p>
<p>求证： <span class="math display">\[
\dim(\mathbf V) + \dim(\mathbf W) = \dim(\mathbf V + \mathbf W) + \dim(\mathbf V \cap \mathbf W)
\]</span></p>
</blockquote>
<p>朴素的做法设出两向量空间交的基，然后在此基础上分别拓展形成<span class="math inline">\(\mathbf V\)</span>，<span class="math inline">\(\mathbf W\)</span>，然后再证明这些分别拓展的基和两空间交的基一起是线性无关的。步骤倒也不是特别复杂。</p>
<p>但是格局低了。</p>
<p>Mike Artin提出的证明是这样的：考虑二元运算<span class="math inline">\(+\)</span>把二元组 <span class="math inline">\((\vec v\in \mathbf V, \vec w\in \mathbf W)\)</span>变换到<span class="math inline">\(\vec v + \vec w\)</span>。易证这个变换是线性的。其输入维度是<span class="math inline">\(\dim(\mathbf V) + \dim(\mathbf W)\)</span>。其值域的维度是<span class="math inline">\(\dim(\mathbf V + \mathbf W)\)</span>。其零空间是<span class="math inline">\((\vec v, \vec -v)\)</span>其中<span class="math inline">\(v\in \mathbf V \cap \mathbf W\)</span>，维度自然是<span class="math inline">\(\dim(\mathbf V \cap \mathbf W)\)</span>。因为线性变换输入的维度等于输出的维度与零空间维度之和，得证。</p>
<p><img src="/2021/04/16/Four%20Spaces/v2-d3a9348b3a938c79f5998c5bc40a1d82_hd.webp" class=""></p>
<p>太高了，我恐高症都犯了。</p>
<h1 id="四大空间的正交性">四大空间的正交性</h1>
<p>还有一点很妙的是：<strong>四大空间是两两正交的</strong>！</p>
<p>什么是正交？两个子向量空间正交当且仅当两个空间中的任意两个向量都互相垂直。（说“子向量空间”是因为两个向量谈论垂直不垂直的前提条件自然是两个向量维数一样，即同属于一个更大的向量空间）</p>
<ol type="1">
<li><p>在<span class="math inline">\(\mathbb R^n\)</span>内，零空间<span class="math inline">\(N(A)\)</span>和行空间<span class="math inline">\(C\left(A^{\mathrm T}\right)\)</span>互相正交 <span class="math display">\[
\forall A^{\mathrm T}\vec x \in C\left(A^{\mathrm T}\right),\vec y \in N(A),\quad \left(A^{\mathrm T}\vec x\right)^{\mathrm T}\vec y = \vec{x}^{\mathrm T}A\vec y = \vec{x}^{\mathrm T}\cdot \vec 0 = 0
\]</span> 又因为二者维度之和为<span class="math inline">\(n\)</span>，所以二者互补，即<span class="math inline">\(N(A) + C\left(A^{\mathrm T}\right) = \mathbb{R}^n\)</span>。</p></li>
<li><p>在<span class="math inline">\(\mathbb R^m\)</span>内，列空间<span class="math inline">\(C(A)\)</span>和左零空间<span class="math inline">\(N\left(A^{\mathrm T}\right)\)</span>互相正交 <span class="math display">\[
\forall A\vec x \in C(A),\vec y \in N\left(A^{\mathrm T}\right),\quad \left(A\vec x\right)^{\mathrm T}\vec y = \vec{x}^{\mathrm T}A^{\mathrm T}\vec y = \vec{x}^{\mathrm T}\cdot \vec 0 = 0
\]</span> 又因为二者维度之和为<span class="math inline">\(m\)</span>，所以二者互补，即<span class="math inline">\(C(A)+ N\left(A^{\mathrm T}\right) = \mathbb{R}^m\)</span>。</p></li>
</ol>
<p>于是就可以祭出Introduction to Linear Algebra 封面上的神图<del>手绘重制以表敬意</del></p>
<p><img src="/2021/04/16/Four%20Spaces/image-20210417155102490.png" class=""></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/03/17/MITAdmitted/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/17/MITAdmitted/" class="post-title-link" itemprop="url">被MIT录取杂感</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-17 20:44:31" itemprop="dateCreated datePublished" datetime="2021-03-17T20:44:31+08:00">2021-03-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-27 16:17:56" itemprop="dateModified" datetime="2021-03-27T16:17:56+08:00">2021-03-27</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>3月15日清晨6:30分</p>
<p>某人迷迷糊糊地刚刚从被窝里爬出来</p>
<p>迷迷糊糊地唤醒一夜没关的电脑</p>
<p>迷迷糊糊地点进MIT的portal</p>
<p>啊，果然status更新了呢，虽然不该抱什么期待的</p>
<p>自己这个水平申请纯属做分母哦，大概一定是thank you for applying to MIT这种套路话罢（确信）</p>
<p>为了彻底让自己死心点了进去并开始阅读</p>
<blockquote>
<p>On behalf of the Admissions Committee, it is my pleasure to offer you admission to the MIT Class of 2025! You stood out ...</p>
</blockquote>
<p>嗯？（要素察觉）</p>
<p><img src="/2021/03/17/MITAdmitted/%E5%9C%B0%E9%93%81%E8%80%81%E4%BA%BA%E6%89%8B%E6%9C%BA.jpg" class=""></p>
<p><strong>嗯？！？！？</strong></p>
<p><img src="/2021/03/17/MITAdmitted/%E8%BF%99%E5%9C%BA%E9%9D%A2%E6%88%91%E7%9C%9F%E6%B2%A1%E8%A7%81%E8%BF%87.jpg" class=""></p>
<p>千言万语在早晨上学的急忙中汇成一句话</p>
<blockquote>
<p>草，居然录了？</p>
</blockquote>
<p>然后简单地发了个朋友圈，吃完饭，开开心心上学去了。</p>
<p>学校申请的竞争是残酷的，所谓成王败寇莫不如是。抢救性写感言，各路学弟开始问经验，然后我其实一时半会并答不出来。另一方面，我在学姐的帮助下倒是在一个小时内就找到了组织见到了前几届MIT的学长，然后发现群里面个个都是集训队级别的大佬，区区国铜瑟瑟发抖。</p>
<p>一切都引向了一个我必须思考的问题：</p>
<blockquote>
<p>我这么菜，为啥会被MIT看上呢？</p>
</blockquote>
<p><img src="/2021/03/17/MITAdmitted/%E5%8F%8D%E5%A4%8D%E5%88%86%E6%9E%90.jpg" class=""></p>
<p>论标化，自己的标化成绩在国内传统认知内对于MIT的申请只能称得上是堪堪够用。</p>
<p>论文书，因为自己原本对MIT的申请不抱特别大的希望，文书写的是中规中矩，没有特别多的灵光一现和奇妙构思。</p>
<p>论活动，自己没有上过许多国内奉为圭臬的夏校。没有辩论，没有模联，没有特别多社会活动。</p>
<p>论竞赛，自己国铜的最高水准大概只到了最低线？</p>
<p>论申请策略，自己直接说喜欢EECS的直球做法在许多人看来也是头铁。</p>
<p>那是为什么呢？</p>
<p>转了一圈，思绪回到1月6号申请最后一天在电脑前的奋笔疾书。</p>
<p>是了，原来如此，答案或许见诸于MIT申请系统的首页：</p>
<blockquote>
<p>The key is to be yourself.</p>
</blockquote>
<p>我在最后一天才意识到MIT的申请居然允许递交一份maker portfolio，那时的兴奋是无以言表的。</p>
<p>自己就把自己平时乱搞的小项目连简介带Github链接填了上去，填了九个，简介写了一千多个词，自己从未如此畅快。</p>
<p>想必让招生官高看我一眼的，大概就是这么多乱搞项目当中体现出来的对<del>摸鱼</del>计算机的一种热情？（暴论）</p>
<p>记得自己曾经做第一个小项目的时候，一方面是觉得自己开心，另一方面为未尝没有“如果项目牛逼了会不会被人赏识”的小功利心和小幻想。做了那么多小项目，快乐是总有的，但牛逼的项目是没有的，所以在高中的几年觉得大学申请愈发迫近也曾焦虑迷茫过，尝试过竞赛，但也难以完全投入精力，最终屈服于自己强大的摸鱼欲之下重操旧业。也不止一次地心中有“自己摸鱼做项目的时间是不是浪费了呢？”的疑问。</p>
<p>但是现实证明，所有的努力都不会被辜负。</p>
<p>自己的气质或许也和MIT很般配呢（大雾）。</p>
<p><img src="/2021/03/17/MITAdmitted/tradeschoolmeme.png" class=""></p>
<p>当然，这也可以理解为是某人摸鱼主义哲学的大胜利（大雾）。</p>
<p><img src="/2021/03/17/MITAdmitted/image-20210326162803734.png" class=""></p>
<p><del>上图：当你摸鱼的contribution都状似摸鱼，你就达成了二阶摸鱼的至高境界，物极必反，这是MIT的隐藏通道</del></p>
<p>人啊，还是要有理想的，有理想地摸鱼，这就达成了一组矛盾的对立统一，矛盾摸鱼，乃摸鱼之大境界。</p>
<p>最后还是要说一句，<del>Cornell你拒的好啊！</del></p>
<p>录了技校，人很开心，加上之前录了剑桥，所以现在就是一个去Cambridge还是去Cambridge的问题了，我选择去Cambridge。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/03/14/%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E8%BF%B7%E6%80%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/14/%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E8%BF%B7%E6%80%9D/" class="post-title-link" itemprop="url">中文编程迷思</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-14 16:11:44" itemprop="dateCreated datePublished" datetime="2021-03-14T16:11:44+08:00">2021-03-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-27 11:43:57" itemprop="dateModified" datetime="2021-04-27T11:43:57+08:00">2021-04-27</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>又一次在网上看到中文编程的日经贴后，我觉得这似乎会是一个不错的博文题目。</p>
<p>这篇文章我计划讲的内容在标题里写得很明白——“迷思”。</p>
<p>迷思，经常被用作英文myth的音译，衍生出“神话”、“传言”的意项。在这个定义下，“中文编程”或许可以称得上是一个迷思了，初学编程的萌新和温饱思扯淡的键盘程序语言设计家（我或许可以忝列后者）一天到晚在讲，Github上偶尔有个小项目也会有不少的曝光率，但是也就止步于笑谈中了，现实的应用几乎没有（唯一勉强成气候的易语言常年处于鄙视链的最低端）。这样一种现状，似乎和动漫当中的“都市传说”颇有共同点。可是动漫的“都市传说”最后都是真的，“中文编程”则未必然。</p>
<p>若纯粹地拆字组词，“迷思”又有一种“胡思乱想”的意项在，这是我对于我想法的总结——胡思乱想。这篇文章就是胡思乱想，想着想着觉得有暴论出现可以写一下，仅此而已。我会尽力组织自己的逻辑，但是要这篇文章变成如同高考作文一般逻辑严密，既非我愿，也非我力所能及。</p>
<p>对中文编程我一直保有比较浓厚的兴趣，记得小学刚毕业的时候简短地用过所谓易语言。后来自己以前闲着无聊的时候写过自己脚本语言的解释器所以对于语言设计实现大约还算有一点点心得。恰好最近手痒又想写parser，我就想：为什么不试试看写一个中文的脚本语言呢？</p>
<p>然而思前想后，哪怕只是纸上谈兵的幻想，结果都不算乐观。</p>
<p>做个暴论吧：<strong>目前的所谓中文编程语言不过花瓶，真正实用的中文编程（如果真的有必要的话）任重而道远。</strong></p>
<hr />
<p>我一直认为，要大致把握一个编程语言的特征，写一段快速排序的代码是一个非常好的选择。快排是一个不简单且不平凡的算法，在传统命令式语言的理论框架内，顺序，分支和循环结构都用到了；如果更特殊的特性，快排的复杂度也勉强允许一些语言施展一下其特殊的语言构造。例如Haskell经典的四行快排我觉得就是对函数式语言哲学的一种不错的体现，C++或许也可以炫一波模板元编程和新出的concept。与此同时快速排序也不是特别复杂，让人能够多花心思在语言的特征而不是辨认算法本身上。最后的最后，它还能让我复习一下快排咋写，何乐而不为？</p>
<p>先放一段快排的C代码，代码是我从网上随手拉来的，显然还有很大的优化空间，但这并不重要：</p>
<pre class="line-numbers"><code class="language-c">void quick_sort(int *arr, int left, int right) &#123;
    if (left &gt;= right) return; 
    int p = arr[left];
    int i = left, j = right;
    while (i &lt; j) &#123;
        while (arr[j] &gt;= p &amp;&amp; i &lt; j) j--;         
        while (arr[i] &lt;= p &amp;&amp; i &lt; j) i++;
        int temp = arr[j];
        arr[j] = arr[i];
        arr[i] = temp;
    &#125;
    arr[left] = arr[i]; 
    arr[i] = p;
    quick_sort(arr, left, j - 1);
    quick_sort(arr, j + 1, right);
&#125;</code></pre>
<p>那么问题来了：<strong>人们心目中与上面这一段C对应的“中文代码”应该是什么个样子呢？</strong></p>
<p>是这样吗？</p>
<pre class="line-numbers"><code class="language-none">定义 函数 快速排序（输入：整数 数组，左边界：整数，右边界：整数）：
    如果（左边界 &gt;= 右边界）：返回
    令 基准 为 输入【左边界】
    令 甲 为 左边界
    令 乙 为 左边界
    当（甲 &lt; 乙）时循环：
        当（输入【乙】 &gt;= 基准 且 甲 &lt; 乙）时循环：
            乙 自减
        当（输入【甲】 &lt;= 基准 且 甲 &lt; 乙）时循环：
            甲 自增
        交换（输入【甲】，输入【乙】）
    令 输入【左边界】 为 输入【甲】
    令 输入【甲】 为 基准
    快速排序（输入，左边界，乙 - 1）
    快速排序（输入，乙 + 1，右边界）</code></pre>
<p><strong>中文编程是为了接地气，不是接地府</strong></p>
<p>以上文法的所谓“中文编程语言”在现实开发中是极为不便的。</p>
<p>但很遗憾，这就是现在网络上通行的“中文编程”的现状。</p>
<p>有错吗？乍一看似乎是没有的，在某种意义上这还是“要素完全”的：</p>
<ol type="1">
<li>上面的代码一个拉丁字母都没有用到——“完全汉化”</li>
<li>尽量使用全角字符——“贴合国人使用习惯”</li>
<li>可读性勉强令人满意。</li>
</ol>
<p>然而上面这坨东西我写的时候血压直线飙升。是哪里出了问题？</p>
<p>不妨再看看下一种可能的情况：</p>
<pre class="line-numbers"><code class="language-none">定义快排（整数组输入，整数左界，整数右界）：
    若左界&gt;=右界：返回
    基准赋输入于左界
    甲赋左界；乙赋右界
    当甲&lt;乙：
        当输入于乙&gt;=基准且甲&lt;乙：
            乙自减
        当输入于甲&lt;=基准且甲&lt;乙：
            甲自增
        交换（输入于甲，输入于乙）
    输入于左界赋输入于甲
    输入于甲赋基准
    快排（输入，左界，乙-1）
    快排（输入，乙+1，右界）</code></pre>
<p>看起来似乎比最上面一个例子要好一点是不是？</p>
<p>如果在这个基础上进行一定的代码高亮，那感觉就更上一个台阶：</p>
<p><img src="/2021/03/14/%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E8%BF%B7%E6%80%9D/%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E6%BC%94%E7%A4%BA.svg" class=""></p>
<p>虽然一开始的那一版“中文编程”也可以通过适当的代码高亮在效果上进行优化，但各位试一试就知道，效果应当还是不如上图的。那么，两种文法，都是“中文编程”，是什么导致了舒适度上的巨大差异？</p>
<hr />
<p>回顾编程语言的历史，我们发现，编程语言正逐渐以语言本身的定位为基础，探寻如下三者的最优平衡：</p>
<ol type="1">
<li>对于机器来说好读：文法无二义性，且运行效率高</li>
<li>对于人类来说好读：文法大致贴合阅读习惯，或者说，在训练之后可以快速阅读</li>
<li>对于人类来说好写：文法“废话少”，开发效率高。</li>
</ol>
<p>在文法解析技术、编译器优化技术、以及硬件技术如此发达的当下，第一点的重要性正在逐渐被弱化。那么剩下的，就只有对人好读好写的要求了。既然是“对人”，就自然需要考虑编程语言所依附的自然语言的语言特性。所有人都知道英语和中文无论是在直觉上还是在语言学意义上都有着巨大的差异，因此基于中文的编程语言，又怎么可以生搬硬套基于英语的编程语言的结构呢？以上示例中的两门语言之所以在观感上具有差距，就是因为前者是可以通过直接的单词替换预处理还原为另一门语言的“套皮”，而后者则做了一定程度上的“本地化”。</p>
<p>我们首先注意到，<strong>中文当中是没有空格分词的</strong>。在输入大段中文的时候，空格键往往只作为输入法选词的快捷键而本身不进入文本。这是很多中文编程语言所忽视的。例如</p>
<blockquote>
<p>每 个 中文 词 之间 都有 空格， 写 起来 很 别扭， 读 起来 也 不 习惯。</p>
</blockquote>
<blockquote>
<p>每个中文词之间没有空格读写起来会更为自然。</p>
</blockquote>
<p>这是很多中文编程语言所忽视的一点。然而也必须承认，空格的存在给词法分析提供了极大的便利。联系到当下对于大段中文的分词往往采用，也只能采用启发式的算法的现状，可以说<strong>在一门中文编程语言当中删去空格，虽然可以让读写更为顺畅，但对文法的设计与解析提出了更大的挑战</strong>。（同时，空格的去除让代码开起来更为紧凑，在汉字本身就结构相对复杂的情况下就更会对可读性产生一定的影响，因此在这种情况下，<strong>代码高亮是必要的</strong>）</p>
<p>我们还发现，当下的编程语言在英语的基础上对于关键词进行大量的<strong>简化</strong>。例如，define在Python中被简化为<code>def</code>；function在Go中被简化为<code>func</code>，在Kotlin中被简化为<code>fun</code>，在Rust中更是被简化到<code>fn</code>；integer在很多语言当中都被简化到<code>int</code>，structure被简化到<code>struct</code>……对于英语等拼音文字，这种简化往往是通过去除辅音，删去末音节等完成的，较为简单。但是对于中文象形文字，这种简化就很难了，因为一个词往往就双音节两个字，去了哪个都不行，而仿照去除辅音搞去除笔画之类的毫无意义：<code>结构</code>变成<code>吉勾</code>？还是两个汉字不说，词本身的辨识性已经被破坏殆尽。</p>
<p>然而，我们关注的是目的而不是手段，抛开如此简单粗暴的类比，事情就豁然开朗了。编程语言简化关键词拼写的目的何在？一方面是<strong>让代码更加简洁，阅读效率更高</strong>。另一方面则是<strong>提升输入效率</strong>。中文或许在阅读效率方面已经无可挑剔，但是在输入效率上一直差强人意——我不是说中文本身的输入效率，而是写代码本身的效率。二者有何区别？</p>
<p>如今不用代码补全写代码的人已经不多了。代码补全的本质，是在用户敲击键盘进行原始输入的同时，结合上下文，给出符合编程语言语法以及（理想情况下）代码语义的代码建议。仔细想想，这和中文的输入法何其相似！然而现在并没有专为写代码而生的输入法。要写中文代码，就必须先敲键盘，再输入法选词，等到中文字实实在在地落到了编辑器里，代码补全才会出现，然后用户就要再次选词，如图</p>
<p><img src="/2021/03/14/%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E8%BF%B7%E6%80%9D/Completion.svg" class=""></p>
<p>显然，在上例中，如果能把输入法整合进自动补全（或者反过来），使得在键入<code>ks</code>时就自动跳出<code>快速排序</code>的提示项，对于开发效率和流畅性会有可观的提升（在没有空格分词的中文编程语言中，这样的融合自动补全可以综合考虑到关键词以及文法结构，这种流畅性提升会更为显著）。否则，对于针对自然语言输入而设计的输入法而言，编程的上下文不免会让提词非常别扭；对于代码补全而言，变量名一般就三四个字个字，在输入法打完两个字后再补全一般似乎也如同鸡肋。两者没有沟通各自为战，折磨的就是开发者。理想情况下，<strong>中文编程中的输入法和代码补全不说是合二为一也应当是互相合作的</strong>。相比于独立地弹出一个下拉框，代码补全应当使用一个输入法提供的接口访问用户在键盘上的原始输入并给出建议，这样用户在输入法的选词界面就可以直接看到代码提示，效率何止提升了两倍。然而，现实中的各输入法都热衷于闭门造车，即使是以开源闻名的Rime都不提供这种动态提词接口。因此，如果要实现前文的创想，倒是IDE的开发者自己从零写一个兼容自动补全的输入法更现实一点。而后者可就造轮子造大了去了。</p>
<p>简单的总结一下，如果要实现我心目中理想的中文编程语言，应当有这两个特点：</p>
<ol type="1">
<li><strong>本土化的语言文法：</strong>在不引入二义性的前提下，降低空格分词的必要性，或更多地从中文本身借鉴一部分文法结构，使得汉字的输入和阅读更符合自然语言的习惯。不满足这一点，则不免对于阅读的流畅性产生影响，产生生硬之观感，被好事者讥为“套皮”。</li>
<li><strong>高效率的开发环境：</strong>在开发环境上完成输入法和自动补全的整合，提升写代码的流畅性，同时提供靠谱的代码高亮方案以辅助阅读。不满足这一点，则读起来再赏心悦目的编程语言写起来都有不便，难免花瓶一个，华而不实。</li>
</ol>
<p>这两点的难度不是一般的大，因此我觉得实用的中文编程任重而道远。当然，考虑到中文编程除了看着一乐以外未必有其他特殊的吸引力，实际上这种编程语言大概是遥遥无期了。</p>
<p>迷思迷思，思到这大概也就结束了。整篇文章想到哪里写到哪里，估计很乱吧（笑），如果有人读着这个觉得摸不着头脑，实在是抱歉。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/03/13/LaTeX%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/13/LaTeX%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">LaTeX小技巧整理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-13 18:24:21" itemprop="dateCreated datePublished" datetime="2021-03-13T18:24:21+08:00">2021-03-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-27 11:43:24" itemprop="dateModified" datetime="2021-04-27T11:43:24+08:00">2021-04-27</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这篇文章是在经历<span class="math inline">\(\LaTeX\)</span>改格式改得死去活来后对于以后可能经常会用到的格式调整小技巧的一个汇总。许多片段的来源是TeX StackExchange, 源链接就不一一表明了。这些技巧在XeTeX上编译通过，对于其他的引擎尚未测试。</p>
<p>该列表预计会随着我被<span class="math inline">\(\LaTeX\)</span>虐的次数增加而不断更新。</p>
<h1 id="页边距设置">页边距设置</h1>
<p>使用<code>geometry</code>宏包：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;geometry&#125;
\geometry&#123;a4paper, top = 34.4mm, bottom = 45mm, left = 23mm, right = 23mm&#125;</code></pre>
<p>更高级的用途可以参阅其官方文档。</p>
<h1 id="字体设置">字体设置</h1>
<h2 id="times-new-roman">Times New Roman</h2>
<p>为了全局设置Times New Roman字体，我们需要<code>fontspec</code>宏包：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;fontspec&#125;
\setmainfont&#123;Times New Roman&#125;</code></pre>
<p>如果希望数学公式的字体也使用Times New Roman，可以使用<code>newtx</code>宏包：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;newtxmath&#125;</code></pre>
<p>注：<code>newtx</code>宏包下还有<code>newtxtext</code>可以代替<code>fontspec</code>和<code>setmainfont</code>的功能，但是不知为何在Windows的XeTeX上编译错误。归根结底，XeTeX以及LuaTeX的一个设计理念就是使用户可以直接调用系统字体而不用拘泥于宏包，因此我个人还是偏向于<code>setmainfont</code>的解决方案。</p>
<h2 id="宋体粗体">宋体粗体</h2>
<p>CTeX在Windows系统下宋体采用的是中易的字库，而不幸的是中易的宋体并不包括粗体。Word之所以可以给中易宋体加粗，是因为它有在标准字重基础之上自动加粗的算法。而高贵的<span class="math inline">\(\LaTeX\)</span>显然是不屑于用这种歪门邪道加粗字体的，所以你惊喜地发现在Windows下你似乎无论怎么<code>\textbf</code>/<code>\bfseries</code>都得不到加粗的宋体（于是CTeX就机智地把黑体作为粗体时的字体）。如果因为种种原因迫不得已一定要使用粗体，CTeX给出了两个解决方案：</p>
<ol type="1">
<li>伪粗体：通过对于一个汉字堆叠若干个微距平移标准字号的宋体实现视觉上的粗体效果。这种伪粗体效果肯定不如专门的宋体效果好，而且在PDF内选词的时候偶尔会遇到问题，因此我是没有使用过。</li>
<li>使用带有粗体的宋体：可以使用<code>\setCJKmainfont</code>命令转而使用例如思源黑体等设计时考虑粗体的字体。这在Windows下其实也不简单。最傻瓜的做法是在<code>\documentclass&#123;ctexart&#125;</code>前加上<code>[fontset = fandol]</code>选项，使得CTeX采用Fandol的字库。这家的字库可以在GPL协议下自由使用，但是缺点是缺的字不少。</li>
<li>不是解决办法的办法：装一台Ubuntu的虚拟机，Ubuntu下的默认宋体是带有粗字号的，问题直接解决。</li>
</ol>
<h1 id="标题格式的修改">标题格式的修改</h1>
<p>一般来说，LaTeX内修改标题格式最合适的宏包是<a target="_blank" rel="noopener" href="https://www.ctan.org/pkg/titlesec"><code>titlesec</code></a>。<code>titlesec</code>的文档相当详细，SE上也有非常多的教程，所以在这类就不多赘述了。我想记一笔的是CTeX内部自带的格式设置功能：这个功能在CTeX的<a target="_blank" rel="noopener" href="https://www.ctan.org/pkg/titlesec">官方手册</a>上确有记载，但是在网上却不是很好找。个人认为用法比<code>titlesec</code>简洁明了，对于一般的中文文档已是相当够用了。这里举一个例子：</p>
<pre class="line-numbers"><code class="language-latex">\ctexset&#123;
    section/format = \songti\sffamily\zihao&#123;-4&#125;\bfseries, % 中文宋体，英文无衬线体，字号小四，加粗
    section/afterskip = 0pt, % 标题下方不留空，直接接段落，更紧凑
    subsection/format = \songti\sffamily\zihao&#123;5&#125;\bfseries, % 中文宋体，英文无衬线体，字号五号，加粗
    subsection/beforeskip = 0pt, % 标题上方不留空，直接在上一段下方，更紧凑
    subsection/afterskip = 0pt, % 标题上方不留空
    subsubsection/format = \songti\sffamily\zihao&#123;5&#125;\bfseries, % 中文宋体，英文无衬线体，字号五号，加粗
    subsubsection/beforeskip = 0pt,
    subsubsection/afterskip = 0pt   
&#125;</code></pre>
<h1 id="参考文献标题格式的修改">“参考文献”标题格式的修改</h1>
<p>和上节相同，只需要在<code>\thebibliography</code>之前修改<code>section</code>的格式就行了（如果还有附录的话不要忘记改回来）。</p>
<p>如果要修改“参考文献”这四个字本身，CTeX提供了<code>refname</code>选项。</p>
<h1 id="自动引号配对">自动引号配对</h1>
<p>使用<code>csquotes</code>宏包：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage[autostyle=false, style=english]&#123;csquotes&#125;
\MakeOuterQuote&#123;&quot;&#125;</code></pre>
<h1 id="中文的定理环境">中文的定理环境</h1>
<p>CTeX会自动将<code>amsthm</code>包当中的证明环境从“Proof”改成“证明”，但在<code>ctexart</code>类型下不会对定理，引理，定义等环境进行汉化，因此需要手动加入如下代码：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;amsthm&#125;
\newtheorem&#123;theorem&#125;&#123;定理&#125;[section]
\newtheorem&#123;definition&#125;&#123;定义&#125;[section]
\newtheorem&#123;corollary&#125;&#123;推论&#125;[section]
\newtheorem*&#123;remark&#125;&#123;注&#125;
\newtheorem&#123;lemma&#125;&#123;引理&#125;[section]</code></pre>
<h1 id="列表环境下的间距">列表环境下的间距</h1>
<h2 id="一般列表去除间距">一般列表去除间距</h2>
<p>使用<code>enumitem</code>宏包的<code>nosep</code>选项让<code>enumerate</code>和<code>itemize</code>中相邻项之间的垂直间距为0：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;enumitem&#125;

\begin&#123;enumerate&#125;[nosep]

\end&#123;enumerate&#125;</code></pre>
<h2 id="文献列表去除间距">文献列表去除间距</h2>
<p>通过以下代码去除文献列表中相邻项的垂直间距：</p>
<pre class="line-numbers"><code class="language-latex">% 去除参考文献一节文献项之间过大的间隙
\let\OLDthebibliography\thebibliography
\renewcommand\thebibliography[1]&#123;
    \OLDthebibliography&#123; #1 &#125;
    \setlength&#123;\parskip&#125;&#123;0pt&#125;
    \setlength&#123;\itemsep&#125;&#123;0pt plus 0.3ex&#125;
&#125;</code></pre>
<h1 id="图注格式修改">图注格式修改</h1>
<p>最为通用，最为灵活的方法：</p>
<pre class="line-numbers"><code class="language-latex">% 宋体五号粗体，#1#2#3分别是“图xxx”，“：”，以及图注文字本身
\DeclareCaptionFormat&#123;mycaptionformat&#125;&#123;\songti\zihao&#123;-5&#125;\bfseries#1#2#3\par&#125;
\captionsetup&#123;format = mycaptionformat&#125;</code></pre>
<h1 id="页眉页脚相关">页眉页脚相关</h1>
<h2 id="首页特殊">首页特殊</h2>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;fancyhdr&#125;
\fancypagestyle&#123;firststyle&#125;&#123;
    \fancyhf&#123;&#125;
    \renewcommand&#123;\headrule&#125;&#123;\hrule height 0.5pt \vspace&#123;0.8pt&#125;\hrule height 0.5pt&#125;
    \renewcommand&#123;\footrule&#125;&#123;\hrule height 0.5pt width 0.3\textwidth&#125;
    ...
&#125;

% 在\begin&#123;document&#125;之后
\thispagestyle&#123;firststyle&#125;</code></pre>
<h2 id="装饰线">装饰线</h2>
<pre class="line-numbers"><code class="language-latex">% 页眉双线
\renewcommand&#123;\headrule&#125;&#123;\hrule height 0.5pt \vspace&#123;0.8pt&#125;\hrule height 0.5pt&#125;
% 页脚部分装饰线
\renewcommand&#123;\footrule&#125;&#123;\hrule height 0.5pt width 0.3\textwidth&#125;</code></pre>
<p>参数可以视情况自行调整；可以写在<code>\fancypagestyle</code>内部。</p>
<h1 id="在一行内同时包括左中右对齐的文本">在一行内同时包括左中右对齐的文本</h1>
<pre class="line-numbers"><code class="language-latex">\newcommand&#123;\headerline&#125;[3]&#123;
    \par\medskip\noindent
    \makebox[\textwidth][s]&#123;\rlap&#123;#1&#125;\hfill#2\hfill\llap&#123;#3&#125;&#125;%
    \par\medskip
&#125;
% 用例：
\headerline&#123;•栏目•&#125;&#123;doi: 10.3866/PKU.DXHX20xxxxxxx&#125;&#123;www.dxhx.pku.edu.cn&#125;</code></pre>
<h1 id="在表格环境内改变表线宽度">在表格环境内改变表线宽度</h1>
<p>鉴于许多办法可能不适用于除<code>tabular</code>之外的环境，这里提供一个简单粗暴的办法：</p>
<pre class="line-numbers"><code class="language-latex">\setlength&#123;\doublerulesep&#125;&#123;0pt&#125;
...

\hline\hline % 两倍标准线宽</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/02/02/KCP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/02/KCP/" class="post-title-link" itemprop="url">Rust实现带BBR的高效魔改KCP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-02-02 21:18:31 / 修改时间：21:21:01" itemprop="dateCreated datePublished" datetime="2021-02-02T21:18:31+08:00">2021-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>完整的代码<a target="_blank" rel="noopener" href="https://github.com/alan20210202/ekho/blob/e2c24b4504/src/kcp.rs">在此</a>。</p>
<h1 id="背景">背景</h1>
<p>最近我在用Rust写一个ICMP隧道，因为ICMP包本身是不可靠的，于是需要在ICMP之上写一个可靠协议。一个完整的TCP协议栈显然过于臃肿了（何况也并没有现成的无IO的轮子），所以我就看上了skywind3000大佬的<a target="_blank" rel="noopener" href="https://github.com/skywind3000/kcp">KCP协议</a>——轻量、简洁、代码连我这种网路萌新都看得懂，实在是再好不过了。</p>
<p>一开始是我直接使用原版的C实现+FFI封装，在不开流控的情况下效果不错，但可惜原版的拥塞控制用的是最朴素的TCP Tahoe（作者也表明出于简洁性考虑不准备在标准实现当中使用复杂的流控算法），其在国际网络环境下的表现实在差强人意。想改进，但自己对于自己C的编程水平实在是不抱信心。既然Rust也是性能一流的系统编程语言，我最终还是决定用Rust再写了一个实现。本实现具有以下特点：</p>
<ul>
<li>相较于C实现进行了架构上的些许调整。</li>
<li>在C实现的基础之上，使用链表+滚动数组优化大窗口下的发送性能。</li>
<li>在C实现的基础之上，使用小根堆优化RTO计时器的效率，提升重传性能。</li>
<li>将著名的BBR拥塞控制算法进行一定修改后试验性地运用到KCP中。</li>
</ul>
<h1 id="依赖的包">依赖的包</h1>
<p>为了使编写更加简便，我们的实现依赖以下Rust crates：</p>
<ul>
<li><code>bytes</code>——简便的字节处理（代替原来C实现当中的<code>encode_xxx</code>/<code>decode_xxx</code>）。</li>
<li><code>num_enum</code>——简化Rust枚举与字节的互相转换。</li>
<li><code>derivative</code>——简化一些trait的实现。</li>
<li><code>thiserror</code>——简化错误类型的定义。</li>
<li><code>rand</code>——用于BBR随机相位初始化。</li>
</ul>
<h1 id="架构上的调整">架构上的调整</h1>
<h2 id="常量与配置">常量与配置</h2>
<p>相对于C实现，本实现大幅减少了常量的数量。最后仅剩的常量有五：</p>
<pre class="line-numbers"><code class="language-rust">/// KCP包头大小
const OVERHEAD: u32 = 24;
/// 最大分段
const MAX_FRAGMENTS: u16 = 128;
/// KCP段类型
#[derive(Debug, Clone, Copy, TryFromPrimitive, IntoPrimitive)]
#[repr(u8)]
enum Command &#123;
    Push = 81,
    Ack = 82,
    AskWnd = 83,
    TellWnd = 84,
&#125;
/// BBR各阶段的增益
const BBR_GAIN_CYCLE: [usize; 8] = [5, 3, 4, 4, 4, 4, 4, 4];
/// BDP增益的分母，见后文
const BDP_GAIN_DEN: usize = 1024;</code></pre>
<p>常量少了，变量自然就多了，原来C实现的常量在本实现中成为可配置项：</p>
<pre class="line-numbers"><code class="language-rust">/// 大部分配置的意思如字面
#[derive(Clone, Debug, Deserialize, Derivative)]
#[derivative(Default)]
pub struct Config &#123;
    #[derivative(Default(value = &quot;536&quot;))]
    pub mtu: u32,
    #[derivative(Default(value = &quot;200&quot;))]
    pub rto_default: u32,
    #[derivative(Default(value = &quot;100&quot;))]
    pub rto_min: u32,
    #[derivative(Default(value = &quot;6000&quot;))]
    pub rto_max: u32,
    #[derivative(Default(value = &quot;7000&quot;))]
    pub probe_min: u32,
    #[derivative(Default(value = &quot;120000&quot;))]
    pub probe_max: u32,
    #[derivative(Default(value = &quot;1024&quot;))]
    pub send_wnd: u16,
    #[derivative(Default(value = &quot;1024&quot;))]
    pub recv_wnd: u16,
    #[derivative(Default(value = &quot;40&quot;))]
    pub interval: u32,
    /// 若一个包重传dead_link_thres次后依然失败，则视作底层链路失效。
    #[derivative(Default(value = &quot;20&quot;))]
    pub dead_link_thres: u32,
    /// nodelay模式下, rto_min = 0且rto在重传失败后不指数增长。
    #[derivative(Default(value = &quot;false&quot;))]
    pub nodelay: bool,
    /// stream模式下, 多个数据包可以被合并在同一段内从而减少开销。
    #[derivative(Default(value = &quot;false&quot;))]
    pub stream: bool,
    /// 如果指定，则一个包在fast_resend_thres个在其之后的包ACK之后会直接重传
    #[derivative(Default(value = &quot;None&quot;))]
    pub fast_resend_thres: Option&lt;u32&gt;,
    /// 快速重传的次数上限
    #[derivative(Default(value = &quot;None&quot;))]
    pub fast_resend_limit: Option&lt;u32&gt;,
    /// 是否启用BBR控制算法
    #[derivative(Default(value = &quot;false&quot;))]
    pub bbr: bool,
    /// BBR中RTprop（往返时间）滑动窗口的时间长度（单位：毫秒）
    #[derivative(Default(value = &quot;10000&quot;))]
    pub rt_prop_wnd: u32,
    /// BBR中BtlBw（瓶颈带宽）滑动串口的长度（单位：RTT）
    #[derivative(Default(value = &quot;10&quot;))]
    pub btl_bw_wnd: u32,
    /// BBR中一次RTT/RTprop探测的时间（单位：RTT），减少该值可以减轻RTT探测对于流量的影响。
    #[derivative(Default(value = &quot;200&quot;))]
    pub probe_rtt_time: u32,
    /// BDP增益，见后文
    #[derivative(Default(value = &quot;1024&quot;))]
    pub bdp_gain: usize,
&#125;

impl Config &#123;
    pub fn mss(&amp;self) -&gt; usize &#123;
        (self.mtu - OVERHEAD) as usize
    &#125;
&#125;

impl ControlBlock &#123;
    pub fn new(conv: u32, config: Config) -&gt; ControlBlock &#123;
        ...
    &#125;
&#125;</code></pre>
<h2 id="异常类型">异常类型</h2>
<p>KCP原本的C实现仅使用负数表达异常值，虽简介但其含义并不明晰，在本实现中我们对于异常进行了清晰定义：</p>
<pre class="line-numbers"><code class="language-rust">#[derive(Debug, Error)]
pub enum Error &#123;
    #[error(&quot;packet to be sent too large to be fragmented&quot;)]
    OversizePacket,
    #[error(&quot;incomplete KCP packet&quot;)]
    IncompletePacket,
    #[error(&quot;invalid KCP command: &#123;0&#125;&quot;)]
    InvalidCommand(u8),
    #[error(&quot;empty queue (try again later)&quot;)]
    NotAvailable,
    #[error(&quot;wrong conv. (expected &#123;expected&#125;, found &#123;found&#125;)&quot;)]
    WrongConv &#123; expected: u32, found: u32 &#125;,
&#125;

pub type Result&lt;T&gt; = std::result::Result&lt;T, Error&gt;;</code></pre>
<p>以上异常类型还有更精确的空间，但是目前应该已经堪堪够用了。</p>
<h2 id="发包方式">发包方式</h2>
<p>在原来的C实现在发包时直接调用callback，其优点是简洁，但其缺点在于callback的运行时间不定以及异常处理不明对运行产生的影响。<del>何况在Rust当中安全存储callback需要和borrow checker拼命。</del>在本实现中，我们将flush出去的包暂存在一个队列中，然后通过外部不断poll的方式拉出去。一方面，主动poll的方式和底层收到包时的push呼应；另一方面，这有助于分离底层发包和KCP逻辑本身，是“<a target="_blank" rel="noopener" href="https://sans-io.readthedocs.io/">无IO/Sans IO</a>”理念的一种体现。缺点是缓存队列可能会膨胀得厉害。当中tradeoff见仁见智。</p>
<pre class="line-numbers"><code class="language-rust">impl ControlBlock &#123;
    ...
    /// 底层收包push
    pub fn input(&amp;mut self, mut data: &amp;[u8]) -&gt; Result&lt;usize&gt; &#123; ... &#125;
    /// 底层发包poll
    pub fn output(&amp;mut self) -&gt; Option&lt;Vec&lt;u8&gt;&gt; &#123; ... &#125;
&#125;</code></pre>
<h2 id="去除check和update">去除<code>check</code>和<code>update</code></h2>
<p>这是一个比较大胆的改动，未必适合所有情形。去除的原因是在数据结构的优化下计算重传、更新发送窗口的开销大幅度减小，已经可以在每一次调用<code>input</code>和<code>send</code>的时候进行一次，没有必要去不断<code>check</code>再<code>update</code>。上层只需要按照固定的时间间隔调用<code>flush</code>就行了。我进行这样的设计是为了简化上层的代码，而且我的应用情形恰好是高流量的反正都要一直<code>flush</code>，也无所谓。</p>
<p><code>flush</code>的代码也其实很简单：</p>
<pre class="line-numbers"><code class="language-rust">pub fn flush(&amp;mut self) &#123;
    self.sync_now(); // 更新now
    self.flush_probe(); // 更新窗口探测
    self.flush_push(); // 计算重传以及更新发送窗口
    self.flush_ack(); // 发ACK
    if !self.buffer.is_empty() &#123;
        let mut new_buf = Vec::with_capacity(self.config.mtu as usize);
        std::mem::swap(&amp;mut self.buffer, &amp;mut new_buf);
        self.output.push_back(new_buf);
    &#125;
&#125;</code></pre>
<p>既然<code>sync_now</code>、<code>flush_push</code>在<code>input</code>和<code>send</code>当中都可以廉价地调用，那为什么还需要不断<code>check</code>再<code>update</code>呢？直接调用<code>flush</code>了事。</p>
<p>如果要参考有<code>check</code>和<code>update</code>的实现，可以参照<a target="_blank" rel="noopener" href="https://github.com/alan20210202/ekho/blob/caaeb5f55d/src/kcp.rs">早些时候的commit</a>。</p>
<h1 id="窗口数据结构的改进">窗口数据结构的改进</h1>
<p>KCP原版的实现中发送/接收的队列/窗口全部使用队列作为数据结构，这固然使得代码变简单了，但也一定程度上降低了性能：在队列中查找KCP段最差需要线性时间，这在某些情形下未必是最优的。在本实现中，我们优化数据结构，以最优的复杂度实现发送/接受窗口需要的若干操作：</p>
<ul>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>以分段的序号为键查找分段。</li>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>插入分段。</li>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>以分段的序号为键查找分段。</li>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>以分段的序号为键删除分段。</li>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>查询/弹出最早插入的分段（在发送窗口中，最早插入的分段自然是序号最小的分段）。</li>
<li><span class="math inline">\(\mathcal{O}(k)\)</span>遍历以插入顺序为序，某分段的所有<span class="math inline">\(k\)</span>个前驱（在发送窗口中，分段插入顺序即序号顺序，因此该操作可直接用于快速重传的计算）。</li>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>查询大小。</li>
</ul>
<p>考虑到任何时刻窗口内分段序号之差不会大于窗口大小这一常数，符合上述要求的数据结构就可以用链表+滚动数组高效实现。代码不长，百行左右：</p>
<pre class="line-numbers"><code class="language-rust">struct Element&lt;T&gt; &#123;
    /// 前驱下标
    prev: usize,
    /// 后继下标
    next: usize,
    data: T,
&#125;

pub struct Window&lt;T&gt; &#123;
    size: usize,
    entry: Vec&lt;Option&lt;Element&lt;T&gt;&gt;&gt;,
    end: Option&lt;usize&gt;,
    len: usize,
&#125;

impl&lt;T&gt; Window&lt;T&gt; &#123;
    pub fn with_size(size: usize) -&gt; Self &#123;
        Self &#123;
            size,
            entry: (0..size).map(|_| None).collect(),
            end: None,
            len: 0,
        &#125;
    &#125;

    pub fn is_empty(&amp;self) -&gt; bool &#123;
        self.end.is_none()
    &#125;

    pub fn get_mut(&amp;mut self, index: usize) -&gt; Option&lt;&amp;mut T&gt; &#123;
        match self.entry[index % self.size].as_mut() &#123;
            Some(elem) =&gt; Some(&amp;mut elem.data),
            None =&gt; None,
        &#125;
    &#125;

    pub fn push(&amp;mut self, index: usize, data: T) &#123;
        let index = index % self.size;
        if self.entry[index].is_some() &#123;
            return;
        &#125;
        self.entry[index] = Some(match self.end &#123;
            Some(prev) =&gt; &#123;
                let prev_elem = self.entry[prev].as_mut().unwrap();
                let next = prev_elem.next;
                prev_elem.next = index;
                self.entry[next].as_mut().unwrap().prev = index;
                Element &#123; prev, next, data &#125;
            &#125;
            None =&gt; Element &#123; prev: index, next: index, data &#125;,
        &#125;);
        self.end = Some(index);
        self.len += 1;
    &#125;

    pub fn remove(&amp;mut self, index: usize) -&gt; Option&lt;T&gt; &#123;
        let index = index % self.size;
        let elem = self.entry[index].take()?;
        let (prev, next) = (elem.prev, elem.next);
        self.entry[index] = None;
        self.len -= 1;
        if index == self.end.unwrap() &#123;
            if prev == index &#123;
                self.end = None;
                return Some(elem.data);
            &#125; else &#123;
                self.end = Some(prev);
            &#125;
        &#125;
        self.entry[prev].as_mut().unwrap().next = next;
        self.entry[next].as_mut().unwrap().prev = prev;
        Some(elem.data)
    &#125;

    pub fn front(&amp;self) -&gt; Option&lt;&amp;T&gt; &#123;
        self.end.map(|end| &#123;
            let head = self.entry[end].as_ref().unwrap().next;
            &amp;self.entry[head].as_ref().unwrap().data
        &#125;)
    &#125;

    pub fn pop_unchecked(&amp;mut self) -&gt; T &#123;
        let end = self.end.unwrap();
        let head = self.entry[end].as_ref().unwrap().next;
        self.remove(head).unwrap()
    &#125;

    pub fn len(&amp;self) -&gt; usize &#123;
        self.len
    &#125;

    pub fn for_preceding(&amp;mut self, index: usize, mut action: impl FnMut(&amp;mut T)) &#123;
        let mut index = index % self.size;
        index = match self.entry[index].as_ref() &#123;
            Some(elem) =&gt; elem.prev,
            None =&gt; return,
        &#125;;
        while index != self.end.unwrap() &#123;
            let elem = self.entry[index].as_mut().unwrap();
            action(&amp;mut elem.data);
            index = elem.prev;
        &#125;
    &#125;
&#125;</code></pre>
<p>因为滚动数组是连续空间，在内存布局上相较于链表对于缓存更加友好，所以速度应该还可以再快一点。唯一的不足是<code>unwrap</code>有点多看着心惊肉跳，并且用指针可能会比用下标快一丁点，但是用Rust写数据结构大约就是这个尿性。</p>
<p>有这个打底，窗口大小开到8192实测是一点问题都没有的，更大的没试过。</p>
<p>但KCP的设计本质上是不适合大流量的，因为快速重传无论如何优化数据结构最坏的线性复杂度就在那里无法消除，除非可以限制快速重传向后看的范围，但后者又削弱了快速重传的意义与效用。</p>
<h1 id="重传计时器的改进">重传计时器的改进</h1>
<p>原版的KCP实现在<code>check</code>的时候需要遍历发送窗口来确定最近的重传时间，在<code>flush</code>的时候又要遍历才能重传，这在窗口较大的时候显然是比较吃性能的。原作者记得在issues里的讨论中提过可以用时间轮进行优化。诚然，时间轮是最好的方案，但是实现起来较为复杂。因此，本实现使用借助Rust的标准库实现起来相对简单的小根堆进行优化：</p>
<pre class="line-numbers"><code class="language-rust">use std::cmp::Reverse;
use std::collections::BinaryHeap;

pub struct Timer(BinaryHeap&lt;Reverse&lt;u64&gt;&gt;);

impl Timer &#123;
    pub fn with_capacity(capacity: usize) -&gt; Self &#123;
        Self(BinaryHeap::with_capacity(capacity))
    &#125;

    pub fn schedule(&amp;mut self, ts: u32, sn: u32) &#123;
        self.0.push(Reverse(((ts as u64) &lt;&lt; 32) | sn as u64));
    &#125;

    /// 获取截止到now发生的 一个 事件，应该重复调用
    pub fn event(&amp;mut self, now: u32) -&gt; Option&lt;(u32, u32)&gt; &#123;
        let key = (now as u64 + 1) &lt;&lt; 32;
        match self.0.peek() &#123;
            Some(&amp;Reverse(val)) if val &lt; key =&gt; &#123;
                let sn = val &amp; (u32::max_value() as u64);
                let ts = val &gt;&gt; 32;
                self.0.pop();
                Some((ts as u32, sn as u32))
            &#125;
            _ =&gt; None,
        &#125;
    &#125;
&#125;</code></pre>
<p>计时器只需要存时间和分段序号即可。调用的代码如下：</p>
<pre class="line-numbers"><code class="language-rust">fn flush_push(&amp;mut self) &#123;
    // ... 省去流控以及把队列里的分段加入发送窗口的部分
    let mut send_buf = std::mem::take(&amp;mut self.send_buf);
    while let Some((ts, sn)) = self.timer.event(self.now) &#123;
        if sn &lt; self.send_una || sn &gt;= self.send_nxt &#123;
            continue; // 分段被ACK于是不在发送窗口里了，自然跳过
        &#125;
        if let Some(seg) = send_buf.get_mut(sn as usize) &#123;
            if ts == seg.ts &#123;
                seg.ts = self.prepare_send(seg); // 更新RTO并计算下一次重传的时间
                seg.ts_last_send = ts;
                self.dead_link |= seg.sends &gt;= self.config.dead_link_thres;
                self.flush_segment(Command::Push, seg.frg, seg.sn, ts, seg.payload.len());
                self.buffer.extend_from_slice(&amp;seg.payload);
                self.timer.schedule(seg.ts, seg.sn); // 安排下一次重传
            &#125;
        &#125;
    &#125;
    self.send_buf = send_buf;
&#125;</code></pre>
<p>由于查看小根堆堆顶是<span class="math inline">\(\mathcal{O}(1)\)</span>的，因此在没有重传的时候<code>flush_push</code>的开销确实很小。足以在<code>input</code>和<code>send</code>时都调用一次。真的要重传时，更新小根堆的时间复杂度也是对数级别的，这就给去除<code>check</code>和<code>update</code>提供了基础。</p>
<h1 id="bbr">BBR</h1>
<p>最后的改进是用BBR取代了KCP原版实现中朴素的基于丢包的流控算法。</p>
<p>我试图参照<a target="_blank" rel="noopener" href="https://research.google/pubs/pub45646/">原论文</a>实现BBR，但因为计时精度的问题packet pacing是做不到了。实现的部分有</p>
<ul>
<li>基于单调队列的滑动窗口BtlBw max-filter。</li>
<li>基于单调队列的滑动窗口RTprop min-filter。</li>
<li>BBR状态机。</li>
<li>基于以上三者计算inflight limit进行流控。</li>
</ul>
<p>和BBR有分歧的一点在于在ProbeRTT状态采用BDP的一半作为拥塞窗口而不是原文的4个包。</p>
<p>此外，本实现只对只传输一次的分段计算BBR的各项参数，如RTT，带宽，更新各个filter等。原因是实际上大部分的分段都在看到包头的UNA之后就被ACK掉了而不是被单独的ACK包ACK的。ACK包带有分段的序号与时间戳，所以可以清楚知道ACK的是哪一次传输，但被UNA ACK掉的就不清楚，唯一的例外是分段只被传输了一次。如果对于多次传输的包仍然直接计算BBR，那么万一ACK恰好在重传之后到达，那么误算出的RTT就非常小，导致RTprop非常小，进而BDP非常小，整个BBR就堵住了。诚然，可以把每一次传输的时间戳都存起来，然后在被UNA时选择最接近<code>now - srtt</code>的传输，但这就增加了代码的复杂度。考虑到丢包的毕竟是少数，如此未必会有特别大的优势（实现这个的代码在这个<a target="_blank" rel="noopener" href="https://github.com/alan20210202/ekho/blob/01b1d72b7e/src/kcp.rs">commit</a>，也可作为参考）。</p>
<p>实测效果还行。一个比较重要的问题是在间歇性<code>flush</code>的情况下对于带宽的计算并不准确甚至有低估的倾向，往往导致BDP过于保守，即使ProbeBW状态有一个1.25x的激进phase也解决不了问题。我想到的一个解决方案是将拥塞窗口不是简单的设置为BDP，而是乘上一个增益，也就是配置里面的<code>bdp_gain</code>。为了避免浮点数运算，<code>bdp_gain</code>使用1024为基数。一般来说设置成1280就差不多了——其实就是主动创造轻微的拥塞来确保占有带宽。这对于其他的TCP连接固然有些不公平的，是否采用见仁见智。</p>
<h1 id="真背景">真·背景</h1>
<p>其实一开始，只是为了编译的时候能够不带着<code>unsafe</code>和C编译器而选择把原版实现移植到Rust，当时代码大部分几乎一模一样。</p>
<p>后来引入BBR魔改了一回。</p>
<p>为了代码更Rust魔改了一回。</p>
<p>再后来做配置分离魔改了一回。</p>
<p>再后来数据结构优化又魔改了一回。</p>
<p>来来回回地改，到最后除了架子还和原版实现相似，内部的代码已经大变样了。</p>
<p>但是在ICMP隧道上试验下来仍然不是最令人满意，CPU占用仍然不少，带宽仍然不能跑满，goodput仍然不高。</p>
<p>我不知道是我应用层以及底层的代码写的有问题，还是KCP本身就不是很适合高流量大窗口的应用场景。</p>
<p>或许二者兼有之？</p>
<p>前两天突然想起了QUIC，找了一下，Cloudflare有一个优秀的QUIC实现，是Rust的，而且是Sans IO的。大概QUIC才是最适合我的应用情形的吧。我准备这几天试验一下。</p>
<p>或许之后就转QUIC了呢？（笑）</p>
<p>那我魔改的KCP就放在这吃灰？</p>
<p>于是乎，就有了这篇文章。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/11/25/Wallis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/25/Wallis/" class="post-title-link" itemprop="url">数学课划水整活之Wallis乘积公式的一种证明</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-25 17:06:04" itemprop="dateCreated datePublished" datetime="2020-11-25T17:06:04+08:00">2020-11-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-16 13:07:26" itemprop="dateModified" datetime="2021-03-16T13:07:26+08:00">2021-03-16</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>今天数学课讲了一点组合数的性质，因为太简单了所以稍微划了一会水。</p>
<p>结果发现自己整出来了一个算<span class="math inline">\(\pi\)</span>的式子？</p>
<p>化简以后发现是传说中的Wallis公式？</p>
<p>虽然原理一样的证明Wiki上有提到但是还是当场惊了。</p>
<p>简单记一笔吧。</p>
<p>一切的开端是今年寒假做夏校申请的时候证明过的一个极限 <span class="math display">\[
\lim_{n\to\infty} 2^{-2n}\binom{2n}{n} = 0
\]</span> 当时是用斯特林近似暴力代换进行证明（现在看来并不严谨） <span class="math display">\[
\begin{aligned}
    \lim_{n\to\infty} \binom{2n}{n} \frac{\left[\sqrt{2\pi n} \left(n \over e\right)^n \right]^2} {\sqrt{4\pi n} \left(2n \over e\right)^{2n}} &amp;= \lim_{n\to\infty} \left[\frac{\sqrt{2\pi n} \left(n \over e\right)^n}{n!}\right]^2 \frac{(2n)!}{\sqrt{4\pi n} \left(2n \over e\right)^{2n}} \\
    &amp;= 1 \\     
    \Rightarrow 
    \lim_{n\to\infty} 2^{-2n}\binom{2n}{n} &amp;= \lim_{n\to\infty} 2^{-2n}\frac {\sqrt{4\pi n} \left(2n \over e\right)^{2n}}{\left[\sqrt{2\pi n} \left(n \over e\right)^n\right]^2} \cdot \lim_{n\to\infty} \binom{2n}{n} \frac{\left[\sqrt{2\pi n} \left(n \over e\right)^n\right]^2} {\sqrt{4\pi n} \left(2n \over e\right)^{2n}} \\
    &amp;=  \lim_{n\to\infty} 2^{-2n}\frac {\sqrt{4\pi} 2^{2n}n^{2n+\frac{1}{2}}e^{-2n}}{2\pi n^{2n+1}e^{-2n}} \\
    &amp;= \lim_{n\to\infty} \frac{1}{\sqrt{\pi n}}\\
    &amp;= 0
\end{aligned}
\]</span> 今天划水的时候发现由以上过程，这个极限可以加强为 <span class="math display">\[
\lim_{n\to\infty} \frac{\sqrt{\pi n}\binom{2n}{n}}{2^{2n}} = 1
\]</span> 稍作整理即得 <span class="math display">\[
\lim_{n\to\infty} \frac{2^{4n}}{n\binom{2n}{n}^2} = \pi
\]</span> 拿卡西欧摁了一下，发现式子没有假，虽然收敛得有亿点点慢但确实是收敛到了<span class="math inline">\(\pi\)</span>。</p>
<p>关键是这个式子我似乎没见过啊？<del>内心直接膨胀，可把我牛逼坏了。</del></p>
<p>因为形式看起来较复杂，接着我就想可不可以通过邻项作比的方式变换一下形态 <span class="math display">\[
\begin{aligned}
\frac{2^{4n}}{n\binom{2n}{n}^2} \Bigg / \frac{2^{4(n-1)}}{(n-1)\binom{2n-2}{n-1}^2} &amp;= \frac{16(n-1)}{n} \left[\binom{2n-2}{n-1} \bigg/ \binom{2n}{n}\right]^2 \\
&amp;= \frac{16(n-1)}{n} \left[\frac{n^2}{2n(2n-1)}\right]^2 \\
&amp;= \frac{16n(n-1)}{(4n-2)^2} \\
&amp;= \frac{2n}{2n-1}\cdot \frac{2n-2}{2n-1}
\end{aligned}
\]</span> 这个形式似曾相识，结合上式把式子化为连乘积的形式，要素察觉！ <span class="math display">\[
\begin{aligned}
\frac{2^{4n}}{n\binom{2n}{n}^2} &amp;= \frac{2^{4}}{1\binom{2}{1}^2} \cdot \frac{2}{3} \cdot \frac{4}{3} \cdot \frac{4}{5} \cdot \frac{6}{5} \cdots \frac{2n-2}{2n-1}\cdot \frac{2n}{2n-1} \\
&amp;= 4\cdot \frac{2}{3} \cdot \frac{4}{3} \cdot \frac{4}{5} \cdot \frac{6}{5} \cdots \frac{2n-2}{2n-1}\cdot \frac{2n}{2n-1}
\end{aligned}
\]</span> 这不就是Wallis乘积公式嘛？翻出Wikipedia一看： <span class="math display">\[
\begin{aligned}
\frac{\pi}{2} &amp;=\prod_{n=1}^{\infty} \frac{4 n^{2}}{4 n^{2}-1}=\prod_{n=1}^{\infty}\left(\frac{2 n}{2 n-1} \cdot \frac{2 n}{2 n+1}\right) \\
&amp;=\left(\frac{2}{1} \cdot \frac{2}{3}\right) \cdot\left(\frac{4}{3} \cdot \frac{4}{5}\right) \cdot\left(\frac{6}{5} \cdot \frac{6}{7}\right) \cdot\left(\frac{8}{7} \cdot \frac{8}{9}\right) \cdots
\end{aligned}
\]</span> 完全一致，直接得证。</p>
<p>哇，也就是说我划着水就把Wallis公式不严谨地整了一遍？</p>
<p><em>果然还是要膨胀.jpg</em></p>
<p>以前觉得这个式子很高端的，现在有种莫名的幻灭感。</p>
<p>但是写到这的时候多看了一眼，发现斯特林逼近的一个推导里用到了Wallis公式？</p>
<p>突然有点不确定这算不算是循环论证了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/08/28/Minecraft%20ILP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/28/Minecraft%20ILP/" class="post-title-link" itemprop="url">Designing Computational Redstone Circuits Automatically in Minecraft with Integer Programming: Preliminary Thoughts and Tests</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-28 13:48:50" itemprop="dateCreated datePublished" datetime="2020-08-28T13:48:50+08:00">2020-08-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-25 17:05:52" itemprop="dateModified" datetime="2020-11-25T17:05:52+08:00">2020-11-25</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>UNFINISHED ARTICLE -- WORK IN PROGRESS</strong></p>
<p><strong>UNFINISHED ARTICLE -- WORK IN PROGRESS</strong></p>
<p><strong>UNFINISHED ARTICLE -- WORK IN PROGRESS</strong></p>
<p>This was a project I worked on two months ago, but it wasn't until now that I have the time to write it down and share it on my blog.</p>
<h1 id="intro">Intro</h1>
<p>Redstone has been a core element in the game Minecraft for quite some years. It is presumably the most untrivial one as well: while anyone could master nearly all Minecraft mechanics through experiences, it takes not only experience but also ingenuity to design a good redstone circuit. Few of us are bold enough to claim "I master redstone", even after playing Minecraft for a decade.</p>
<p>So here comes the question: <strong>Can the design of redstone circuits, the core of Minecraft automations, be automated?</strong> and <strong>If so, how?</strong> (appreciate how meta this is :)</p>
<p>Theoretically, the answer is "yes...but". Minecraft has a finite world, and each position has a finite number of possible blockstates. We can write a program to enumerate all possible placements of blocks until we find some placement corresponding to the desired redstone circuit. However, this needs exponential time and we may need to wait for a century before it could give us, for instance, a decent piston door. Moreover, if a circuit involves manipulation of entities (which could have infinite many states), then we are easily screwed.</p>
<p>Well, perhaps it is difficult to let a program design any redstone circuit. But there is indeed a subset of redstone circuits whose design can very likely be automated -- <strong>computational redstone circuits</strong>, aka. logic gates, calculators, CPUs etc. Why? Because software that design their real world electronic counterparts are readily available -- they are called "EDA".</p>
<p>As a high school student I, of course, know little about the inner workings of real-world EDA applications (and there doesn't seem to be a lot of resources out there). I am convinced that this problem is NPC (further articulated below), so designing an efficient polytime combinatorial algorithm doesn't seem plausible. That said, what about reducing this problem to some other NPC problems which we can solve relatively quickly with optimized algorithms / heuristics -- say, ILP? This is what I am trying to do here.</p>
<h1 id="formulating-the-problem">Formulating the problem</h1>
<p>"Designing computational redstone circuit automatically" is a vague idea, so it is necessary that we know what this truly means.</p>
<h2 id="whats-the-input">What's the input?</h2>
<p>The input should describe the intended functionality of a circuit. Recall how we usually describe a circuit: we draw a <strong>circuit diagram</strong>. I here characterize a redstone circuit diagram by the assumptions and constraints below:</p>
<ol type="1">
<li>A circuit contains two parts: <strong>wires and components</strong>.</li>
<li>Components are the <strong>primitives</strong> of a circuit. E.g. A torch or a wire junction.</li>
<li>A component has <strong>interfaces</strong>, either <strong>in or out</strong>, as where the component receives signals from and sends signals to.</li>
<li>A wire connects <strong>an</strong> out-interface from a component ("source") to <strong>an</strong> in-interface of another component ("target").</li>
<li>Wires are <strong>directed</strong>.</li>
<li>Components are <strong>independent</strong>. i.e. they do not interfere with other components in any way other than being connected by wires from interfaces.</li>
</ol>
<p>A circuit diagram can be represented in a directed graph, with components as vertices and wires as edges. Source/target interfaces as extra information stored on edges.</p>
<h2 id="whats-the-output">What's the output?</h2>
<p>We want our program to tell us how the circuit we described in the input can be built in the Minecraft world. Therefore, we could define the the output to be a set of position - blockstate pairs, (which, in implementation, can be stored in a schematic file).</p>
<p>However, we don't want to jump straight from a circuit diagram to a detailed Minecraft schematic because that means taking interference between components, quasi connectivity, update order -- basically everything that makes redstone engineering complex -- into consideration in the first place.</p>
<p>Instead, we could first build our circuit in an <strong>ideal world</strong>, in which we forget about all those factors above, and then convert the ideal placement into an actual Minecraft schematic.</p>
<p>What's an idea world?</p>
<ol type="1">
<li>A circuit consists of multiple ideal blocks.</li>
<li>A component fully occupies a set of ideal blocks, some of which are its interfaces. How many and which blocks a certain type of component occupies depend on its size in Minecraft and how we plan to convert the ideal placement to a real schematic.</li>
<li>A wire is a chain of blocks, where any adjacent two share a face. The first block is always the source interface and the last is always the target interface.</li>
<li><strong>Exclusiveness: </strong>All components and all wires (ignoring their first and last block) mustn't overlap.</li>
<li><strong>Mutual Independence: </strong>Unless both blocks are occupied by the same component / wire, anything in two adjacent cells do not interfere with each other.</li>
<li>Wire junctions are special components and are exceptions to rule 2 and 3. A wire junction always have three interfaces (1 in &amp; 2 outs, or 2 ins &amp; 1 out). Multiple junctions can overlap and they can overlap with an interface of some component.</li>
<li>There are times when we want to fix the location of some components in the input. These components are usually just placeholders that mark the position of IO. (We don't want to produce a circuit with an unreachable input/output in the center of everything else, right?)</li>
</ol>
<h2 id="the-objective">The Objective</h2>
<ol type="1">
<li>The circuit represented by the output must have the same functionality as described by the input circuit diagram.</li>
<li>The delay of the circuit should be minimized.</li>
</ol>
<h2 id="example-the-and-gate">Example: the AND gate</h2>
<p>Let's see how we design a simple AND gate.</p>
<p>Suppose the only primitive components we have are NOT gate (torch), wire junction, and IO placeholder. The circuit diagram of AND gate is:</p>
<p><img src="/2020/08/28/Minecraft%20ILP/ANDCD.svg" class=""></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/08/20/NOI%202020/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/20/NOI%202020/" class="post-title-link" itemprop="url">蒟蒻的NOI 2020退役记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-08-20 16:23:58 / 修改时间：16:18:17" itemprop="dateCreated datePublished" datetime="2020-08-20T16:23:58+08:00">2020-08-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="day--1">Day -1</h1>
<p>在中午太阳晒得最狠的时候到了学校。宿舍爬楼累死人，也不知道为啥学校楼要建那么高。幸好宿舍里的空调给力，好评。</p>
<p>宿舍的环境还行。个人觉得比当年WC2018的要好。</p>
<p>信号出奇地差，必须在直接靠窗的地方才有4G，不然连2G也别想收到，听宿管和小卖部阿姨说当初就是设计成这个样子的。差评。</p>
<p>插座很多好评。</p>
<p>但是还是没有桌子，无论用什么姿势看电脑都贼难受。同寝室的jtl带了一个床上架的桌子，看了直呼内行。床板贼硬，差评。</p>
<p>伙食还可以，豆浆我觉得挺好喝的，就是湖南菜多多少少带点辣个人不是很能接受，而且菜很细碎的样子。</p>
<p>睡前随随便便背了点笔试题。</p>
<h1 id="day-0">Day 0</h1>
<p>早上迷迷糊糊地去参加了开幕式。听到dzd说有剩饭扣1分大惊。其他就没啥印象了=_=。</p>
<p>结束后拱火mr押题，mr说看到才艺表演一个跳舞的转来转去暗示会考平衡树，一本正经胡说八道.jpg。</p>
<p>感觉周围大佬都贼多，互相之间也都认识，我一个蒟蒻在当中不知所措。自己看来对于在竞赛圈内的信息闭塞的可以。</p>
<p>中午又背了一会笔试题，然后下午就去试机了。笔试没有想象中的难，但是确实是有超纲的，纠结了很久。幸好最后还是满分飘过了。唯一值得吐槽的或许是CCF十年不变的远古测评系统。</p>
<p>随后在试机场上敲了一波LCT和FFT。看到jtl在写MTT有想敲三模数的冲动但是最后的合并调了好一会才勉强调出来，于是就很慌。</p>
<p>晚上寝室里大家都在欢快地打板子。对面两个人都在打带花树，然后惊奇地发现带花树的代码似乎也没有想象中那么长。三个人讨论了一下觉得似乎有概率考分块的样子，但是笑一笑也就过去了。我自己把各种字符串的算法全部过了一遍。</p>
<h1 id="day-1">Day 1</h1>
<p>看到T1愣了好一会，愣是没有第一时间看出DP。不知道为什么当时满脑子都是Tarjan和缩点然后沿着这个方向陷入了死胡同。于是先敲了一个DFS，觉得自己要完蛋。</p>
<p>看了T2又愣了一会，先敲了个暴力，然后觉得<span class="math inline">\(m\)</span>比较小的情况可以动态维护链并+容斥解决。先放着。</p>
<p>看到T3深切地感受到这或许是个数据结构毒瘤？先敲了一个二维树状数组的暴力。当时脑子大概是坏掉了不是枚举矩形直接算而是枚举点算贡献。总之暴力复杂度似乎<span class="math inline">\(\mathcal O(nm\log^2 n)\)</span>非常差。然后认真思考了一下部分分，发现可以莫队。于是基于二维树状数组写了一个<span class="math inline">\(\mathcal O\left(n\sqrt m \log^2 n\right)\)</span>的算法。然后觉得<span class="math inline">\(\mathcal O(\log ^2n)\)</span>的二维数点不妥，改成了<span class="math inline">\(\mathcal O(\log n)\)</span>的可持久化线段树，于是暴力和莫队的复杂度都少了一个<span class="math inline">\(\log\)</span>。再一看发现莫队我可以用树状数组干嘛要二维数点，于是莫队的常数又降下来一点。瞄了一眼后面觉得应该可以用<span class="math inline">\(\mathcal O(n^{7/4})\)</span>的四维莫队，可惜当初没认真学高维莫队不知道块大小咋算了，于是作罢。最后敲了一个莫队和暴力的对拍放着。</p>
<p>回到T2开始敲树剖和容斥，写了一个<span class="math inline">\(\mathcal O\left(m2^m\log^2n\right)\)</span>的算法。和暴力结合在一起觉得至少能拿<span class="math inline">\(32\)</span>分，常数小一点也可以冲冲<span class="math inline">\(40\)</span>样子。</p>
<p>然后回到T1，突然发现这不就一个裸的DP吗，直骂自己前面傻逼。于是花5分钟敲完朴素DP，然后再花10分钟敲完环的部分分。</p>
<p>然后发现边权至多为<span class="math inline">\(5\)</span>，意识到正解显然是用max-plus algebra下的矩阵快速幂进行优化，于是开始敲。此时离考试结束还有60分钟，心中贼慌。等到敲完离考试结束还有30分钟，心态爆炸，然后死活调不出来。只能把这个正解例程写在程序里作为最后之选。离交卷还有5分钟的时候不改了。检查其他两题的程序无误后就开始坐着怀疑自己前三个小时脑子到底在想什么……</p>
<p>出考场觉得自己已经成为了时代的眼泪（笑）。</p>
<p>下午三点去查分。听jtl说这次CCF准时出分没有咕简直是奇迹。结果就是<span class="math inline">\(50+32+40=122\)</span>。和预想的完全一致。这个时候就很后悔。如果当初早点看出矩阵快速幂把T1的正解调出来就好了。这个分觉得铁牌已经在向我招手。</p>
<p>晚上讲题。T1的确是快速幂正解。T2的正解是线段树合并维护树形DP这个之前也在寝室里有了大概的想法，但是一看这个DP的状态设计果然神仙。出题人怒斥了我们打<span class="math inline">\(32\)</span>分树剖暴力的，说是什么数据结构学傻了……然后说写个虚树不就<span class="math inline">\(40\)</span>了吗。我下面听着就很无语：我也想打虚树，但是我不会啊…… T3的出题人原来就是各种OJ上人们一直吐槽的lxl。这个题目的内部名称似乎叫“第十三分块”？正解似乎是先建一个树套树然后再分治再分块……讲到一半就lost了，内心大骂出题人毒瘤。</p>
<p>回寝室后所有人都是颓废的状态，gyc在打Splay的板子。剩下我们两个人开始摸鱼。</p>
<h1 id="day-2">Day 2</h1>
<p>T1一看给人一种网络流的既视感，然后发现图建不出来。退而求其次试图写出线性规划进行代数化建图，发现线性规划必须使用Big M的办法才能建出来，而且直观一看integrity gap大的离谱是不可能建图的。因为是求可行解也不知道目标函数咋写，所以也不能从对偶下手，只能作罢。敲了一个非常粗暴的DFS暴力枚举每道菜用哪两个原材料分别用多少，发现这个DFS在最坏情况下跑得巨慢无比——难不成我暴力骗分都不成？</p>
<p>这个时候有了一个乱搞的intuition，就是枚举原料的排列然后按照排列来确定所用的原料。然后发现过不了样例，于是作罢。</p>
<p>之后稍微改进了一点暴力，只枚举每道菜用哪两个原材料，最后时候用多少最后用网络流来判。这下终于拿到了<span class="math inline">\(15\)</span>分的暴力。顺便基于这个敲了一个随机化，但是似乎表现也不佳的样子。</p>
<p>T2题面长度属实劝退。读完题面之后觉得似乎不是很可做。看了样例之后有了一点暴力的想法，写了一个复杂度为<span class="math inline">\(\mathcal O\left(2^{2^{h_{\text{max}}-1}}\right)\)</span>的算法。简单来说就是把输入的树补成最大树高然后枚举能否扩张成最大树高下的所有可能的二叉树形态。觉得除了<span class="math inline">\(12\)</span>分纯暴力还可以拿<span class="math inline">\(h_{\text{max}}=4\)</span>的分？之后就不会了。</p>
<p>T3一看给我整懵了。可真就暴力不会写呗。直觉上似乎可以写Dijkstra然后在转移的时候排除掉当前路径下的割边。但是很快意识到Dijkstra的本质是DP而这个转移方案是有后效性的。事实上也是如此，样例都没有过。然后试验性地写了一个不可行的判定方法：求出最短路，如果把最短路去掉之后全图不连通，则不可行——也不知道这样对不对。</p>
<p>5个小时就在三个题目的来回懵逼当中度过。</p>
<p>这次CCF出分直接咕了将近两个小时。我们很明智地从一开始就待在寝室里，那些下去等分的就苦逼了。分数出来是<span class="math inline">\(15+12+5=32\)</span>、也差不多是我预想的这个水平，T2树高为<span class="math inline">\(4\)</span>的点我还是超时了，大概还是没有判同构去重的原因？</p>
<p>下午去听讲题。T1正解的思路源于<span class="math inline">\(m=n-1\)</span>的思考，其他的情况都是向<span class="math inline">\(m=n-1\)</span>情况的规约，感觉是非常巧妙的。T2的最优算法居然是线性的？有点听蒙了。听到T3讲解的时候才意识到T3当中的图叫做弦图，而正解源于对于弦图性质的思考，最后用过两次类Dijkstra来解决，感觉是非常非常神奇，不明觉厉，自愧不如。</p>
<p>讲的时候就出榜了，一看果然Cu，心情复杂，但是一开始也没有期望，所以也没有太沮丧。感觉心态真正崩盘的大概是jtl，人家Cu第一……差一分就Ag了。但是看榜还是有<span class="math inline">\(500\)</span>分以上的，觉得这些人真的很厉害。我或许不比他们笨，但是他们确实历练的比我这种多多了。我这种常年边缘划水的OIer果然不能和这些人比。</p>
<h1 id="day-3">Day 3</h1>
<p>看着手中的铜牌，意识到自己划水的OI之路至少到此为止暂时地画上了句号，颇有些不真实感。</p>
<p>我一直在想，如果D1T1的正解我调出来了，我就是Ag了，会不会好一点呢？但是这终究也只是一个幻想而已罢了。一是比赛不能重来，二是我似乎也不知道缓存矩阵乘方的套路所以真写快速幂有可能复杂度还是会炸的样子。</p>
<p>一如既往，自己复习的算法完美地和考试算法错开了。没有LCT，没有FFT，没有字符串。我深切意识到OI果然还是靠平时积累的，这种比赛临时抱佛脚很大概率是不靠谱的。</p>
<p>还是要谢谢NOI最后给了我一个意识到自己有多菜的机会。还有那么多我没有学的啊~</p>
<p>大概在没有竞赛压力之后我还是会对这些算法认真地研究一番的吧。觉得自己的心态是一个很奇妙的东西。在被父母逼着学竞赛的时候总觉得这些算法很烦，但是意识到自己远离竞赛之后，反而又觉得它们有趣起来了。</p>
<p>网上看过很多这样的游记，一般到最后作者不是Au就是进队了，这种好事终究不会发生在我身上。</p>
<p>唉。这就退役了。</p>
<p>写于Day 3从长沙回上海的火车上。自己的思路一如既往地混乱。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/08/14/TreapMultiset/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/14/TreapMultiset/" class="post-title-link" itemprop="url">Reinventing the Wheel: A Drop-in STL Multiset Alternative Using Treap</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-14 15:20:55" itemprop="dateCreated datePublished" datetime="2020-08-14T15:20:55+08:00">2020-08-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-16 11:30:48" itemprop="dateModified" datetime="2021-03-16T11:30:48+08:00">2021-03-16</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>It turns out that writing a STL container from scratch is mostly a tedious physical labor.</p>
</blockquote>
<p>STL is created to save C++ programmers the time of reinventing wheels. Unfortunately, many STL data structures, most notably self-balancing BSTs (aka. <code>std::(multi)set</code>), are not extendable and are by itself too limited to be used in the context of competitive programming, forcing us to write our own BSTs again and again in competitions.</p>
<p>There comes the fact I find really interesting: A quick and dirty self-balancing BST implementation written during a competition is only about 50-60 lines long, while the STL implementation of <code>std::set</code> and <code>std::multiset</code> is usually more than a thousand-lines long in total.</p>
<p>It does make me wonder: what makes this huge difference? And, will the code of our BST bloat as well if we write it the STL way -- with generics, iterators, and all the necessary bits and pieces as specified in the reference?</p>
<p>To answer my question, I have here tried creating my implementation of multiset using treap as the underlying data structure. The result, <code>treap_multiset</code>, is almost a drop-in replacement to <code>std::multiset</code>. The few places where it does not conform to the C++ standard are:</p>
<ol type="1">
<li>It is currently not allocator-aware, so all allocator-related features are not implemented.</li>
<li><code>emplace</code> and <code>emplace_hint</code> are not implemented.</li>
<li>All operations that have logarithmic time complexity in <code>std::multiset</code> still have logarithmic time complexity here, but only in the average sense (because treap is a randomized data structure), and could have linear worst-case time complexity (though very, very, very unlikely).</li>
<li><code>void erase(iterator)</code> takes amortized logarithmic time instead of constant time.</li>
<li>A few uncommonly-used member types are missing.</li>
</ol>
<p><code>treap_multiset</code> also supports two new operations that are not supported in the original <code>std::multiset</code>:</p>
<ol type="1">
<li><pre class="line-numbers"><code class="language-cpp">   size_type rank(iterator it) const;
   size_type rank(const_iterator it) const;</code></pre>
<p>Both take average logarithmic time and return the rank / position of the iterator.</p></li>
<li><pre class="line-numbers"><code class="language-cpp">   iterator at(size_type index);
   const iterator at(size_type index) const;</code></pre>
<p>Both take average logarithmic time and return the iterator at the specified index/position.</p></li>
</ol>
<p>The code is shown below:</p>
<pre class="line-numbers"><code class="language-cpp">#include &lt;stdexcept&gt;
#include &lt;random&gt;
#include &lt;algorithm&gt;

static std::random_device random_device;
static std::mt19937_64 random_engine(random_device());

template &lt;typename T&gt;
struct treap_node &#123;
    using rand_weight_type = decltype(random_engine)::result_type;
    using size_type = std::size_t;

    treap_node *left, *right, *parent;
    rand_weight_type weight;
    size_type size;
    T value;

    treap_node(const T &amp;value): left(nullptr), right(nullptr), parent(nullptr),
        weight(random_engine()), size(1), value(value) &#123;&#125;

    treap_node(treap_node *left, treap_node *right, treap_node *parent, 
        rand_weight_type weight, size_type size, const T &amp;value): 
        left(left), right(right), parent(parent), weight(weight),
        size(size), value(value) &#123;&#125;

    void update_size() &#123;
        size = 1 + (left ? left-&gt;size : 0) + (right ? right-&gt;size : 0);
    &#125;
&#125;;

#define IMPL_ITERATOR_MOVE_NEXT do &#123; \
    if (!node) break; \
    if (node-&gt;right) &#123; \
        node = node-&gt;right; \
        while (node &amp;&amp; node-&gt;left) node = node-&gt;left; \
    &#125; else &#123; \
        bool from_right = true; \
        while (from_right) &#123; \
            if (!node-&gt;parent) &#123; node = nullptr; break; &#125; \
            from_right = node-&gt;parent-&gt;right == node; \
            node = node-&gt;parent; \
        &#125; \
    &#125; \
&#125; while (0)

#define IMPL_ITERATOR_MOVE_PREV do &#123; \
    if (!node) break; \
    if (node-&gt;left) &#123; \
        node = node-&gt;left; \
        while (node &amp;&amp; node-&gt;right) node = node-&gt;right; \
    &#125; else &#123; \
        bool from_left = true; \
        while (from_left) &#123; \
            if (!node-&gt;parent) &#123; node = nullptr; break; &#125; \
            from_left = node-&gt;parent-&gt;left == node; \
            node = node-&gt;parent; \
        &#125; \
    &#125; \
&#125; while (0)

#define TREAP_ITERATOR_DECL(name, qualifier, inc, dec) \
template &lt;typename T&gt; struct name &#123; \
    qualifier treap_node&lt;T&gt; *node; bool past_the_end; \
    name(): node(nullptr), past_the_end(true) &#123;&#125; \
    name(qualifier treap_node&lt;T&gt; *node, bool past_the_end) \
        : node(node), past_the_end(past_the_end) &#123;&#125; \
    name(qualifier treap_node&lt;T&gt; *node): node(node), past_the_end(false) &#123;&#125; \
    qualifier T &amp;operator *() qualifier &#123; \
        if (!node || past_the_end) \
            throw std::runtime_error(&quot;dereferencing null/past-end iterator&quot;); \
        return node-&gt;value; \
    &#125; \
    bool operator ==(const name&lt;T&gt; &amp;b) const &#123; \
        return node == b.node &amp;&amp; past_the_end == b.past_the_end; \
    &#125; \
    bool operator !=(const name&lt;T&gt; &amp;b) const &#123; \
        return node != b.node || past_the_end != b.past_the_end; \
    &#125; \
    name&lt;T&gt; &amp;operator ++() &#123; \
        qualifier treap_node&lt;T&gt; *backup = node; \
        IMPL_ITERATOR_MOVE_##inc; \
        if (!node) past_the_end = true, node = backup; \
        return *this; \
    &#125; \
    name&lt;T&gt; operator ++(int) &#123; \
        name&lt;T&gt; ret(*this); \
        return ++(*this), ret; \
    &#125; \
    name&lt;T&gt; &amp;operator --() &#123; \
        if (past_the_end) past_the_end = false; \
        else IMPL_ITERATOR_MOVE_##dec; \
        if (!node) \
            throw std::runtime_error(&quot;can&#39;t decrement at the beginning&quot;); \
        return *this; \
    &#125; \
    name&lt;T&gt; operator --(int) &#123; \
        name&lt;T&gt; ret(*this); \
        return --(*this), ret; \
    &#125; \
&#125;

TREAP_ITERATOR_DECL(treap_iterator, /* NO QUALIFIER */, NEXT, PREV);
TREAP_ITERATOR_DECL(reverse_treap_iterator, /* NO QUALIFIER */, PREV, NEXT);
TREAP_ITERATOR_DECL(const_treap_iterator, const, NEXT, PREV);
TREAP_ITERATOR_DECL(const_reverse_treap_iterator, const, PREV, NEXT);

template &lt;typename T, typename Compare = std::less&lt;T&gt;&gt;
class treap_multiset &#123;
public:
    using key_type = T;
    using value_type = T;
    using size_type = typename treap_node&lt;T&gt;::size_type;
    using key_compare = Compare;
    using value_compare = Compare;
    using node_type = treap_node&lt;T&gt;*;
    using iterator = treap_iterator&lt;T&gt;;
    using reverse_iterator = reverse_treap_iterator&lt;T&gt;;
    using const_iterator = const_treap_iterator&lt;T&gt;;
    using const_reverse_iterator = const_reverse_treap_iterator&lt;T&gt;;

    treap_multiset(): root(nullptr) &#123;&#125;

    treap_multiset(const treap_multiset &amp;b): root(deep_copy(b.root)), comp(b.comp) &#123;&#125;

    treap_multiset(treap_multiset &amp;&amp;b): root(b.root), comp(b.comp) &#123;&#125;

    ~treap_multiset() &#123; if (root) recursive_free(root); &#125;

    bool empty() const &#123; return root == nullptr; &#125;

    size_type size() const &#123; return root ? root-&gt;size : 0; &#125;

    size_type max_size() const &#123; return 0x7FFFFFFF; &#125;

    key_compare key_comp() const &#123; return comp; &#125;

    value_compare value_comp() const &#123; return comp; &#125;

    iterator begin() 
        &#123; return iterator(leftmost(root)); &#125;

    const_iterator begin() const 
        &#123; return const_iterator(leftmost(root)); &#125;

    const_iterator cbegin() const 
        &#123; return const_iterator(leftmost(root)); &#125;

    iterator end() 
        &#123; return iterator(rightmost(root), true); &#125;

    const_iterator end() const 
        &#123; return const_iterator(rightmost(root), true); &#125;

    const_iterator cend() const 
        &#123; return const_iterator(rightmost(root), true); &#125;

    reverse_iterator rbegin() 
        &#123; return reverse_iterator(rightmost(root)); &#125;

    const_reverse_iterator rbegin() const 
        &#123; return const_reverse_iterator(rightmost(root)); &#125;

    const_reverse_iterator crbegin() const 
        &#123; return const_reverse_iterator(rightmost(root)); &#125;

    reverse_iterator rend() 
        &#123; return reverse_iterator(leftmost(root), true); &#125;

    const_reverse_iterator rend() const 
        &#123; return const_reverse_iterator(leftmost(root), true); &#125;

    const_reverse_iterator crend() const 
        &#123; return const_reverse_iterator(leftmost(root), true); &#125;

    iterator insert(const value_type &amp;value) &#123;
        node_type left, right;
        split_le(root, value, left, nullptr, right, nullptr);
        node_type temp = new treap_node&lt;T&gt;(value);
        root = join(join(left, temp), right);
        return iterator(temp);
    &#125;

    iterator insert(iterator position, const value_type &amp;value) 
        &#123; return insert(value); &#125;

    template &lt;typename II&gt;
    void insert(II first, II last) &#123; 
        for (; first != last; first++) 
            insert(*first); 
    &#125;

    size_type rank(iterator it) const &#123; return rank(it.node); &#125;
    
    size_type rank(const_iterator it) const &#123; return rank(it.node); &#125;

    iterator at(size_type index) &#123;
        if (index &lt; 0 || index &gt; size()) return end();
        return iterator(at_internal(index));
    &#125;

    const_iterator at(size_type index) const &#123;
        if (index &lt; 0 || index &gt; size()) return end();
        return const_iterator(at_internal(index));
    &#125;

    void erase(iterator pos) &#123;
        assert_valid(pos);
        node_type a, b, c;
        size_type rank = this-&gt;rank(pos.node);
        split_size(root, rank, a, nullptr, c, nullptr);
        split_size(a, rank - 1, a, nullptr, b, nullptr);
        root = join(a, c);
        // assert(b == pos.node);
        delete b;
    &#125;

    size_type erase(const value_type &amp;key) &#123;
        node_type a, b, c;
        split_le(root, key, a, nullptr, c, nullptr);
        split_re(a, key, a, nullptr, b, nullptr);
        root = join(a, c);
        if (b) &#123;
            size_type ret = b-&gt;size;
            recursive_free(b);
            return ret;
        &#125;
        return 0;
    &#125;

    void erase(iterator first, iterator last) &#123;
        size_type rank_first = rank(first);
        size_type rank_last = rank(last);
        node_type a, b, c;
        split_size(root, rank_last, a, nullptr, c, nullptr);
        split_size(a, rank_last - 1, a, nullptr, b, nullptr);
        root = join(a, c);
        if (b) recursive_free(b);
    &#125;

    void clear() &#123; if (root) recursive_free(root); &#125;

    void swap(treap_multiset &amp;b) &#123; swap(root, b.root); &#125;

    iterator find(const value_type &amp;key) &#123;
        node_type ret = find_internal(key);
        return ret ? iterator(ret) : end();
    &#125;

    const_iterator find(const value_type &amp;key) const &#123;
        node_type ret = const_cast&lt;treap_multiset&lt;T&gt;*&gt;(this)-&gt;find_internal(key);
        return ret ? const_iterator(ret) : end();
    &#125;

    size_type count(const value_type &amp;key) const &#123;
        node_type a, b, c;
        treap_multiset&lt;T&gt; *thiz = const_cast&lt;treap_multiset&lt;T&gt;*&gt;(this);
        thiz-&gt;split_le(root, key, a, nullptr, c, nullptr);
        thiz-&gt;split_re(root, key, a, nullptr, b, nullptr);
        size_type ret = b ? b-&gt;size : 0;
        thiz-&gt;root = thiz-&gt;join(thiz-&gt;join(a, b), c);
        return ret;
    &#125;

    iterator lower_bound(const value_type &amp;key) &#123;
        node_type ret = lower_bound_internal(key);
        return ret ? iterator(ret) : end();
    &#125;

    const_iterator lower_bound(const value_type &amp;key) const &#123;
        node_type ret = const_cast&lt;treap_multiset&lt;T&gt;*&gt;(this)-&gt;lower_bound_internal(key);
        return ret ? const_iterator(ret) : end();
    &#125;

    iterator upper_bound(const value_type &amp;key) &#123;
        node_type ret = upper_bound_internal(key);
        return ret ? iterator(ret) : end();
    &#125;

    const_iterator upper_bound(const value_type &amp;key) const &#123;
        node_type ret = const_cast&lt;treap_multiset&lt;T&gt;*&gt;(this)-&gt;upper_bound_internal(key);
        return ret ? const_iterator(ret) : end();
    &#125;

    std::pair&lt;iterator, iterator&gt; equal_range(const value_type &amp;key) &#123;
        return std::make_pair(lower_bound(key), upper_bound(key));
    &#125;

    std::pair&lt;const_iterator, const_iterator&gt; equal_range(const value_type &amp;key) const &#123;
        return std::make_pair(lower_bound(key), upper_bound(key));
    &#125;

    size_type depth(node_type node) &#123;
        if (!node) return 0;
        return 1 + std::max(depth(node-&gt;left), depth(node-&gt;right));
    &#125;
    
private:
    Compare comp;
    node_type root;

    void recursive_free(node_type root) &#123;
        if (root-&gt;left) 
            recursive_free(root-&gt;left);       
        if (root-&gt;right) 
            recursive_free(root-&gt;right);
        delete root;
    &#125;

    void split_le(node_type root, const value_type &amp;key, 
        node_type &amp;left, node_type left_parent,
        node_type &amp;right, node_type right_parent) &#123;
        if (!root) &#123; left = right = nullptr; return; &#125;
        if (!comp(key, root-&gt;value)) &#123;
            left = root; root-&gt;parent = left_parent;
            split_le(root-&gt;right, key, root-&gt;right, root, right, right_parent);
        &#125; else &#123;
            right = root; root-&gt;parent = right_parent;
            split_le(root-&gt;left, key, left, left_parent, root-&gt;left, root);
        &#125;
        root-&gt;update_size();
    &#125;

    void split_re(node_type root, const value_type &amp;key, 
        node_type &amp;left, node_type left_parent,
        node_type &amp;right, node_type right_parent) &#123;
        if (!root) &#123; left = right = nullptr; return; &#125;
        if (comp(root-&gt;value, key)) &#123;
            left = root; root-&gt;parent = left_parent;
            split_re(root-&gt;right, key, root-&gt;right, root, right, right_parent);
        &#125; else &#123;
            right = root; root-&gt;parent = right_parent;
            split_re(root-&gt;left, key, left, left_parent, root-&gt;left, root);
        &#125;
        root-&gt;update_size();
    &#125;

    void split_size(node_type root, size_type size, 
        node_type &amp;left, node_type left_parent,
        node_type &amp;right, node_type right_parent) &#123;
        if (!root) &#123; left = right = nullptr; return; &#125;
        size_type left_size = 1 + (root-&gt;left ? root-&gt;left-&gt;size : 0);
        if (left_size &lt;= size) &#123;
            left = root; root-&gt;parent = left_parent;
            split_size(root-&gt;right, 
                size - left_size, root-&gt;right, root, right, right_parent);
        &#125; else &#123;
            right = root; root-&gt;parent = right_parent;
            split_size(root-&gt;left, size, left, left_parent, root-&gt;left, root);
        &#125;
        root-&gt;update_size();
    &#125;

    node_type join(node_type left, node_type right) &#123;
        if (!left) return right;
        if (!right) return left;
        if (left-&gt;weight &lt;= right-&gt;weight) &#123;
            node_type temp = join(left-&gt;right, right);
            if (temp) temp-&gt;parent = left;
            left-&gt;right = temp;
            left-&gt;update_size();
            return left;
        &#125; else &#123;
            node_type temp = join(left, right-&gt;left);
            if (temp) temp-&gt;parent = right;
            right-&gt;left = temp;
            right-&gt;update_size();
            return right;
        &#125;
    &#125;

    node_type leftmost(node_type x) const &#123;
        if (!x) return nullptr;
        node_type ret = x; while (ret-&gt;left) ret = ret-&gt;left;
        return ret;
    &#125;

    node_type rightmost(node_type x) const &#123;
        if (!x) return nullptr;
        node_type ret = x; while (ret-&gt;right) ret = ret-&gt;right;
        return ret;
    &#125;

    node_type find_internal(const value_type &amp;key) &#123;
        node_type a, b, c;
        split_le(root, key, a, nullptr, c, nullptr);
        split_re(root, key, a, nullptr, b, nullptr);
        root = join(join(a, b), c);
        return b;
    &#125;

    node_type lower_bound_internal(const value_type &amp;key) &#123;
        node_type left, right;
        split_re(root, key, left, nullptr, right, nullptr);
        node_type ret = leftmost(right);
        root = join(left, right);
        return ret;
    &#125;

    node_type upper_bound_internal(const value_type &amp;key) &#123;
        node_type left, right;
        split_le(root, key, left, nullptr, right, nullptr);
        node_type ret = leftmost(right);
        root = join(left, right);
        return ret;
    &#125;

    node_type at_internal(size_type index) const &#123;
        node_type temp = root;
        while (true) &#123;
            size_type left_size = 1 + (temp-&gt;left ? temp-&gt;left-&gt;size : 0);
            if (index == left_size) return temp;
            else if (index &lt; left_size) temp = temp-&gt;left;
            else temp = temp-&gt;right, index -= left_size;
        &#125;
        return nullptr; // UNREACHABLE
    &#125;

    size_type rank(node_type node) &#123;
        bool from_right = true;
        size_type ret = 0;
        while (node) &#123;
            if (from_right)
                ret += 1 + (node-&gt;left ? node-&gt;left-&gt;size : 0);
            if (node-&gt;parent)
                from_right = node == node-&gt;parent-&gt;right;
            node = node-&gt;parent;
        &#125;
        return ret;
    &#125;

    node_type deep_copy(node_type node) &#123;
        if (!node) return nullptr;
        node_type left = deep_copy(node-&gt;left);
        node_type right = deep_copy(node-&gt;right);
        node_type ret = new treap_node&lt;T&gt;(
            left, right, nullptr,
            node-&gt;weight, node-&gt;size, node-&gt;value
        );
        if (left) left-&gt;parent = ret;
        if (right) right-&gt;parent = ret;
        return ret;
    &#125;

    void assert_valid(iterator it) &#123;
        if (!it.node || it.past_the_end)
            throw std::runtime_error(&quot;invalid iterator&quot;);
        node_type temp = it.node;
        while (temp-&gt;parent) temp = temp-&gt;parent;
        if (temp != root)
            throw std::runtime_error(&quot;invalid iterator&quot;);
    &#125;
&#125;;</code></pre>
<p>(The code above hasn't been thoroughly tested yet and could still contain bugs).</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chengyuan Ma</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js" integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha512-br8H6OngKoLht57WKRU5jz3Vr0vF+Tw4G6yhNN2F3dSDheq4JiaasROPJB1wy7PxPk7kV/+5AIbmoZLxxx7Zow==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-bash.min.js" integrity="sha512-JvRd44DHaJAv/o3wxi/dxhz2TO/jwwX8V5/LTr3gj6QMQ6qNNGXk/psoingLDuc5yZmccOq7XhpVaelIZE4tsQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-c.min.js" integrity="sha512-T6Lco61aWqCKSznWkd38lf159pD0+EwZ9UCEv6ARAvaWFiy/UHtYgOmlasT8lq5Ck17ZNHzbe5eHUablTGRXxw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cmake.min.js" integrity="sha512-M99z3be36IUB5pA3DWoJvjSYaZA9BiUqf1jXzVcjntASBZFNI53oDRzdJqGzH5voybcAx5Sg8F5QyryE6afD3g==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cpp.min.js" integrity="sha512-hxZJ6OUEpUl9/o4C1gMGvrAbeqDaldBiZbs08c/V8NcU7YImBFlqJAc7Uzjf3bh2W8Wx26/dVDyPk9cUMQY0Mw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-go.min.js" integrity="sha512-SgF1uayJ2/8TV+MhLasqygnm++vYRXswmrR2ZAmUCL4pXtf+6KzUgXPpn10Y6xca658sxOQEOsoP3MChfhke5A==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-java.min.js" integrity="sha512-PWHY6Vao4E9K4LsGBYCY0ttDeiWZwuUozTbJvSy9UFHRz2J4Bl7rcWML3wEnJTVuCJhSwGne/8My5gTo/gnbpg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-json.min.js" integrity="sha512-IC7rV8RslChgByOdUFC6ePqOGn+OwJhnKC3S5AezM8DAiOdGhJMwgsIvBChsa2yuxxoPbH2+W/kjNUM1cc+jUQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-kotlin.min.js" integrity="sha512-aTozTdtORp/xxS/dhRRDfmv/p1eyEMTje96MplkSOqdbKGGvOYIlogoGdtsh/BD91vaqKoAw9M7O/DodqqudIQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-julia.min.js" integrity="sha512-eTGeKQdDzC2rPAUVfM2Fa36s9B9wp138NEhzZqJpRSdJQ66BwLUot25r2YQveCRU5uYNVfX3gckDkl4byfBIWw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-latex.min.js" integrity="sha512-6D3l3Fy8g/hr6AeK2g1rcVZHyFjCqiqgUrwy0mBZTGFd8UwVcUDhzQeIIv3eYeXDecGPTtBOS9ctyRzJyUgypQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-rust.min.js" integrity="sha512-kgT7r2HlCEO4b+Rp3nJvm+/EMBwGMvv1WMdWkb3eNgnS91llMli8Y3T1CgnD8Hifqx50Q3XLUQXDd7PzKQQtUA==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-python.min.js" integrity="sha512-wK9tQmDrstGtZqTKcyVf3h457QGMlNriKs+fHmEkiCizrq0LVovfT3v1smeT1DlQetHhdRkkX1JSuZg5LoNHJg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-nginx.min.js" integrity="sha512-/MNzg8GlnVrAau/TZClh1jxgHNX0HDgidbGnHS5x1OtbKiNoK3e0XNd1oV16xmmeDHjisa3GKLArUau+43GZ4A==" crossorigin="anonymous"></script>
<script type = "text/javascript">
    document.addEventListener('pjax:complete', function() {
        if (typeof Prism !== 'undefined') {
            Prism.highlightAll();
        }
    });
</script>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  






  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    <div class="pjax">

  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



    </div>
</body>
</html>
