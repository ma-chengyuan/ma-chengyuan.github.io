<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ma-chengyuan.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="不务正业高中生一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="Chengyuan Ma&#39;s Blog">
<meta property="og:url" content="https://ma-chengyuan.github.io/index.html">
<meta property="og:site_name" content="Chengyuan Ma&#39;s Blog">
<meta property="og:description" content="不务正业高中生一枚">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chengyuan Ma">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ma-chengyuan.github.io/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.css" integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbggqjHJeyzx88I3rfwjS38WJag/ihH7lzuGlGHpDBymLirZQ==" crossorigin="anonymous" />
<title>Chengyuan Ma's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-65HSG5NCY6"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-65HSG5NCY6');
      }
    </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Chengyuan Ma's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-pagedewarp"><a href="/dewarp/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>PageDewarp</a></li>
        <li class="menu-item menu-item-english"><a href="/english/" rel="section"><i class="fa fa-globe-americas fa-fw"></i>English</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chengyuan Ma"
      src="/avatar.png">
  <p class="site-author-name" itemprop="name">Chengyuan Ma</p>
  <div class="site-description" itemprop="description">不务正业高中生一枚</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">95</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://kalasearch.cn/" title="https:&#x2F;&#x2F;kalasearch.cn&#x2F;" rel="noopener" target="_blank">卡拉搜索</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ma-chengyuan.github.io/2021/12/04/TeX%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/04/TeX%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">TeX源代码阅读笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-12-04 10:33:58 / 修改时间：17:23:27" itemprop="dateCreated datePublished" datetime="2021-12-04T10:33:58-05:00">2021-12-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近我因为个人项目的原因需要深入了解TeX。虽然<em>The TeXbook</em>和<em>TeX By Topic</em>两本书都很详尽地记述了TeX的运行机制机制，但读来仍然有一种雾里看花的感觉。要清晰了解一个程序的行为，终究没有比直接阅读其源代码更好的方法了<del>（屎山代码除外）</del>。好在Knuth一开始就公开了TeX的源代码并附上了非常完善的注释。然而无论如何，40年前的古董级代码理解起来也绝非易事，所以想着还是开一篇文章记录一下吧。这篇文章基本按照<em>TeX The Program</em>里面的章节顺序，对每一章略过细节进行简要的概述，其目的主要是帮助我回忆，当然，如果这篇文章能让其他读者对TeX的架构有个基本的了解，那也再好不过了。</p>
<h1 id="基本架构">基本架构</h1>
<p>TeX是用WEB语言编写的。WEB语言遵循Knuth提出的“文学编程/literate programming”的范式，夹杂文档和代码，可以看作是当今学术界常用的Jupyter Notebook的前身（当然，一个很大的区别是如今一个notebook不会超过20个cell，但TeX有1300多个……）。文档部分基于TeX，代码基于类Pascal（之所以说“类”，是因为当时Pascal的标准化还没完成）。如此一来，一个<code>tex.web</code>源文件，用<code>tangle</code>提取代码可以得到一份Pascal源文件用于构建程序本身，用<code>weave</code>提取文档则可以得到一份TeX源文件，编译成所谓的<em>TeX The Program</em>。</p>
<p>为了增加可读性，TeX源代码中每一个“cell”包含的代码都不超过一页纸（通常更是不超过20行），对于比较长的函数，Knuth会把一部分逻辑分离到其他“cell”中去并在原地插入引用。<code>tangle</code>提取代码的过程本质上就是把基于这些引用对代码块进行重排。除此以外，Knuth还通过WEB定义了一部分宏，这部分宏的替换也是由<code>tangle</code>在生成代码的时候完成的。</p>
<p>如果粗略地看，TeX的源代码是非常模块化的，但是实际上却未必然。后一章定义的宏可能只是前几章某个宏的别名，导致对一个模块的修改可能会导致意想不到的结果， 又或者是虽然抽象出来了一些可以复用的函数，但是这些函数接口的形式极大地约束了实现的方案，导致事实上灵活性的缺失。模块化的设计势必包含一定的抽象，而抽象都伴随这一定的代价。在TeX开发的时代系统资源相当受限，语言标准缺失，各种infrastructure也不成熟，效率和兼容性是第一目标，因此代码设计成这样是可以理解的——只是苦了像我一样被现代开发范式惯坏的后来者。</p>
<h1 id="tex的奇妙字符串处理">TeX的奇妙字符串处理</h1>
<p>TeX实现了自己的一套基于string pool的、极具特色的、动态储存字符串的方案。 简单来说，TeX有一个大的<code>char</code>数组<code>str_pool</code>，以及一个元素递增的下标数组<code>str_start</code>。TeX给每个字符串赋予一个编号。编号<code>s</code>的字符串存储于<code>str_pool</code>下标中的<code>str_start[s]</code>以及<code>str_start[s + 1]</code>之间。以下C伪代码可以将TeX的字符串转换为C风格的字符串：</p>
<pre class="line-numbers"><code class="language-c">char *texstr_to_cstr(short s) &#123;
    size_t len = str_start[s + 1] - str_start[s];
    char *ret = malloc(len + 1);
    memcpy(ret, str_pool + str_start[s], len);
    ret[len] = 0;
    return ret;
&#125;</code></pre>
<p>在运行过程中，TeX会维护<code>pool_ptr</code>和<code>str_ptr</code>两个变量，分别表示<code>str_pool</code>中最小可用的下标以及最小的可用的字符串编号。新建一个字符串大概是这样的：</p>
<pre class="line-numbers"><code class="language-c">short cstr_to_texstr(char *s) &#123;
    size_t len = strlen(s);
    assert(str_start[str_ptr] == pool_ptr);
    memcpy(str_pool + str_start[str_ptr], s, len);
    str_start[++str_ptr] = pool_ptr += len;
    return str_ptr - 1;
&#125;</code></pre>
<p>当然，实际上TeX在构建新字符串的时候是逐字符添加的，<code>pool_ptr</code>也是逐步递增。这又涉及到很多骚操作（例如append字符之后还能flush吐出来等等），在此略过。TeX有两个比较字符串的方法，<code>str_eq_buf</code>比较一个内部字符串和一个<code>char*</code>是否相等；<code>str_eq_str</code>比较两个内部字符串是否相等。</p>
<h1 id="tex的奇妙算术">TeX的奇妙算术</h1>
<p>还是时代的原因，TeX问世时IEEE754还没有出，当时各型机器、各个编译器上对于浮点数的算术运算都遵循不同的标准。因此，TeX为了规避这种不确定性，很大一部分计算都基于其自身定义的定点数——Knuth称之为scaled number。定点数长4字节，以<span class="math inline">\(2^{-16}\)</span>为最小单位。换而言之，如果直接把定点数当<code>int32_t</code>读，得到的是其所表示值的<span class="math inline">\(2^{16}\)</span>倍。除此以外，当时各个平台对于对负数的整除和取模运算的实现存在分歧，因此TeX除了几处非核心算法，其余的部分在整除和取模前都检查操作数的正负性，确保只对正整数进行这两个操作。</p>
<p>TeX的定点数计算函数里有很多令人啧啧称奇的操作，例如以下函数本质上就是计算<span class="math inline">\(100(t/s)^3\)</span>。放在现在像我估计直接就一行搞定了，TeX是怎么做的呢？（以下注释是我补的，原文没有解释7230584和1663497两个magic number的由来）。</p>
<pre class="line-numbers"><code class="language-c">typedef int16_t scaled;
const int16_t inf_bad = 10000;
int16_t badness(scaled t, scaled s) &#123;
    if (t == 0) return 0;
    if (s &lt;= 0) return inf_bad;
    int r; // 近似于2⁶ * ³√100 * t / s
    // 297³ ≈ 100 * 2¹⁸
    // 如果t &gt; 7230584则t * 297 &gt;= 2147483647会溢出
    if (t &lt;= 7230584) r = (t * 297) / s;
    // 此时t &gt;= 7230585，如果s / 297 &lt; 1663497 / 297 = 5601的话，
    // t / (s / 297) &gt;= 1291，此时（见下）一定会return inf_bad
    // 除法很慢，所以如果具体结果不重要就不要做
    else if (s &gt;= 1663497) r = t / (s / 297);
    else r = t;
    // 如果r &gt; 1290，则r * r * r  + (1 &lt;&lt; 17)会溢出
    if (r &gt; 1290) return inf_bad;
    return (r * r * r + (1 &lt;&lt; 17)) &gt;&gt; 18;
&#125;</code></pre>
<p>非常细致地考察了溢出的可能性，全程整数计算避免了浮点的不确定性，<code>s &gt;= 1663497</code>这个条件更是在一定情况下避免了耗时的除法运算——非常有Knuth的风格。</p>
<h1 id="tex的奇妙内存分配">TeX的奇妙内存分配</h1>
<p>（未完待续）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ma-chengyuan.github.io/2021/05/22/Docleaner-Optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/22/Docleaner-Optimization/" class="post-title-link" itemprop="url">科学白嫖“图档清洁专家”——优化篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-22 06:21:20" itemprop="dateCreated datePublished" datetime="2021-05-22T06:21:20-04:00">2021-05-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>书接<a href="/2021/05/19/Docleaner/" title="上文">上文</a>，我们使用Python + Selenium白嫖了原来要收费的图档清理大师，效果极好。然而，我们的代码还有很多可以优化之处，这就是写本文的由来。</p>
<h1 id="方法优化避免开启浏览器">方法优化：避免开启浏览器</h1>
<p>在写完代码发完朋友圈之后我才开始认真思考一个问题：</p>
<blockquote>
<p><strong>为啥不直接逆向在线体验的API啊？</strong></p>
</blockquote>
<p></p>
<p>我之前自己把自己给绕进去了。</p>
<p>Selenium模拟的好处是实现思路自然，只需要知道人工使用的方法而不需要知道内部的代码实现与网络通信。但缺点也很明显，需要开浏览器带来了一个明显的开销。浏览器的内存占用使得并行操作也存在一定的难度。</p>
<p>而直接模拟网络请求的好处就是确保没有资源浪费，存在并行化的潜质，而且相较于浏览器涉及到的不见耦合较少具有更高的稳定性（前提是API不变。Selenium则相较之下在内部API变化但界面不变的情况下具备跨版本的稳定性）。</p>
<p>试一试？</p>
<p><img src="/2021/05/22/Docleaner-Optimization/image-20210513174125304.png" class=""></p>
<p>打开开发者界面，定位到上传图片的按钮，Firefox的调试器很贴心地告诉我这里有一个event，于是点进去。</p>
<p><img src="/2021/05/22/Docleaner-Optimization/image-20210516112926163.png" class=""></p>
<p>网站的开发者很贴心地没有做minify也没有做混淆，甚至还留了注释。</p>
<p>我发现上传的主要逻辑其实在<code>$('.exeDaqw').click()</code>里，于是进一步在源码当中搜索<code>.exeDaqw</code>，发现如下片段：</p>
<p><img src="/2021/05/22/Docleaner-Optimization/image-20210516113209489.png" class=""></p>
<p>通过阅读片段可以发现，这个<code>.exeDaqw</code>元素是通过<code>layui.upload</code>渲染的。我孤陋寡闻，但Layui看起来是一个控件库，<a target="_blank" rel="noopener" href="https://www.layui.com/">事实</a>也是如此。通过<code>url</code>字段我得以确定上传图片的API地址。在随后的代码当中又可以发现图片清理的API地址。</p>
<p><img src="/2021/05/22/Docleaner-Optimization/image-20210516113732940.png" class=""></p>
<p>通过开发者窗口的网络监视器可以看到请求的实际情况：</p>
<p><img src="/2021/05/22/Docleaner-Optimization/image-20210516114103508.png" class=""></p>
<p>经过一波操作比对，摸索得到的API可以写成如下代码：</p>
<pre class="line-numbers"><code class="language-python">import requests

def clean_doc_requests(images: Generator[Tuple[bytes, str], None, None]) \
        -&gt; Generator[Image.Image, None, None]:
    &quot;&quot;&quot;
    Cleans the scanned document pages using docleaner&#39;s online service.

    :param images: A generator yielding (an image as raw bytes, its extension as string).
    &quot;&quot;&quot;
    for (image, ext) in images:
        # noinspection HttpUrlsUsage
        req = requests.post(&quot;http://service.docleaner.cn/attachCollect/upload&quot;,
                            files=&#123;&quot;file&quot;: (f&quot;image.&#123;ext&#125;&quot;, image)&#125;)
        data = &#123;
            # Weird typo in the API.
            &quot;paramers&quot;: &quot;降噪,去斑点,去黑边,去背景,自动纠斜&quot;,
            &quot;type&quot;: &quot;image&quot;,
            &quot;storePath&quot;: req.json()[&quot;data&quot;][&quot;storePath&quot;],
            &quot;userId&quot;: &quot;&quot;
        &#125;
        # noinspection HttpUrlsUsage
        req = requests.post(&quot;http://service.docleaner.cn/exe/daqw&quot;, data=data)
        result = base64.b64decode(req.json()[&quot;data&quot;][&quot;outFileStr&quot;])
        yield Image.open(io.BytesIO(result))</code></pre>
<p>和之前上面的<code>clean_doc_online</code>代码对比，可以看到代码和逻辑确实都简洁了很多，这就是扒API直接用的优点了。我很幸运，这个站点的代码和注释都很清楚，所以逆向还原出API还是很容易的，对于更加复杂的一些站点，Selenium可能不失为一个更简单粗暴的好办法。</p>
<p>但有意思的地方来了：上面的这串代码，跑的比Selenium要慢。原因在之前解释Selenium的时候大致讲过了。Selenium新开了一个浏览器进程，那里上传图片还是等待结果本质上不会阻塞Python的运行，所以通过优化循环的写法，可以上传图片和从PDF中获取下一页图片同时进行。而<code>requests</code>是Python库，在请求时是阻塞的，因此就慢了。</p>
<p>失之东隅收之桑榆，虽然我们的“优化”让我们的代码反而变慢了，但是也为进一步的优化铺平了道路：在用Selenium的时候，因为同时开几十个浏览器不仅视觉上很离谱而且内存占用很高，所以并行处理很难；而同时开几十个并发的请求却是再容易不过的事情了。因此我们下一步的优化就是利用Python的多进程库进行加速。</p>
<h1 id="速度优化多进程加速">速度优化：多进程加速</h1>
<p>Python写并行的格局，是和别处不同的。究其原因，GIL的存在硬是让多线程的并行成了并发。而绕过GIL的唯一途径就是多进程，这又涉及到了进程之间通信，同步等一连串复杂的逻辑，令人望而生畏（至少我是这样的）。</p>
<p>但Python有一个好——battery included。我去官方文档转了一圈，发现Python的标准库里有一个multiprocessing模块，应付我这里的需求已经完全够用。具体来说，multiprocessing提供了一个进程池<code>Pool</code>：对于一般的</p>
<pre class="line-numbers"><code class="language-python">output_iterator = map(function, input_iterator)</code></pre>
<p>只需要改写成</p>
<pre class="line-numbers"><code class="language-python">from multiprocessing import Pool
with Pool(process_count) as p:
    output_iterator = p.imap(function, input_iterator)</code></pre>
<p>就可以把map的函数分派到线程池的多个线程上进行运算，并在结果出来之后进行保序归并，最终得到和<code>map</code>一样的结果。</p>
<p>为了让我们的代码可以套用这个模式，我们需要把之前生成器套生成器的逻辑重构成单个函数：</p>
<pre class="line-numbers"><code class="language-python">def clean_single_page(args: Tuple[StrPath, int, int, bool, bool]) \
        -&gt; Union[Image.Image, bytes]:
    &quot;&quot;&quot;
    Cleans a single page.

    :param args: A tuple consisting of (in order):
        1. Path to the page (pdf or image),
        2. Index (image index or page index in PDF),
        3. DPI (-1 if an image is direcly supplied),
        4. Whether to perform OCR,
        5. Whether to actually clean the page.
    :return:  If OCR is enabled, an OCR-ed PDF in raw bytes, otherwise a PIL
        Image object representing the cleaned page.
    &quot;&quot;&quot;
    page, idx, dpi, ocr, clean = args
    ...</code></pre>
<p>如上所示，从PDF中提取页面图像、上传图像到图档清理大师进行清理、对于结果的OCR都是可以单独进行的，故合并。</p>
<p>逻辑的合并自然导致参数的合并，而<code>map</code>接受的函数应当是单入单出的，于是我们就需要把所有参数打包成一个tuple进行用，并在函数体内部解包，即上面代码的第15行。</p>
<p>把所有页面重新归并成PDF的函数也要进行一定的简化与修改：</p>
<pre class="line-numbers"><code class="language-python">def merge_to_pdf(pages: Iterable[Union[Image.Image, bytes]], output: StrPath):
    &quot;&quot;&quot;
    Converts and merges images to a one-page pdf file, performing optional
    OCR in the process.

    :param pages: A generator yielding PIL image objects.
    :param output: Path to the result pdf.
    &quot;&quot;&quot;
    doc = fitz.Document()
    for page in pages:
        if isinstance(page, Image.Image):
            # noinspection PyUnresolvedReferences
            doc_page = doc.new_page(width=page.width, height=page.height)
            buffer = io.BytesIO()
            page.save(buffer, format=&quot;jpeg&quot;)
            doc_page.insert_image(fitz.Rect(0, 0, page.width, page.height),
                              stream=buffer)
        else:
            page = fitz.Document(stream=page, filetype=&quot;pdf&quot;)
            doc.insert_pdf(page)
    doc.save(output)</code></pre>
<p>最后，从之前的代码应该可以看出，我在编写代码的时候一直把逻辑分得比较开，目的是在可能的情况下使脚本的使用能够更加灵活。例如，能不能以通配符的形式直接读取图片进行优化？能不能再输出的时候直接输出到文件夹中而跳过PDF归并从而便于其他软件？多进程的优化是一个重要的重构，因此趁这个重构的机会我也把之前提到的功能理了理和调用<code>Pool</code>的代码一起加在了CLI入口点：</p>
<pre class="line-numbers"><code class="language-python">@click.command()
@click.argument(&quot;input&quot;, type=click.Path())
@click.argument(&quot;output&quot;, type=click.Path())
@click.option(&quot;-d&quot;, &quot;--dpi&quot;, default=300, help=&quot;DPI for rasterization.&quot;)
@click.option(&quot;--first-page&quot;, type=int, help=&quot;First page to convert/clean.&quot;)
@click.option(&quot;--last-page&quot;, type=int, help=&quot;Last page to convert/clean.&quot;)
@click.option(&quot;--ocr/--no-ocr&quot;, default=True,
              help=&quot;Whether to perform OCR during the conversion.&quot;)
@click.option(&quot;--clean/--dont-clean&quot;, default=True,
              help=&quot;Whether to clean pdf using docleaner&#39;s online service.&quot;)
def main(input: str, output: str, dpi: int,
         first_page: Optional[int], last_page: Optional[int], ocr: bool,
         clean: bool):
    if os.path.splitext(input)[1].lower() == &quot;.pdf&quot;:
        # PDF mode
        assert os.path.exists(input)
        page_count = fitz.Document(input).page_count
        first_page = 0 if first_page is None else first_page - 1
        last_page = page_count if last_page is None else last_page
        args = zip(repeat(input), range(first_page, last_page),
                   repeat(dpi), repeat(ocr), repeat(clean))
    else:
        # Glob mode
        files = sorted(glob.glob(input, recursive=True))
        first_page = 0 if first_page is None else first_page - 1
        last_page = len(files) if last_page is None else last_page
        args = zip(files[first_page:last_page], repeat(0), repeat(-1),
                   repeat(ocr), repeat(clean))
    total = last_page - first_page
    with Pool() as p:
        results = tqdm(p.imap(clean_single_page, args), total=total)
        if os.path.splitext(output)[1].lower() == &quot;.pdf&quot;:
            merge_to_pdf(results, output)
        elif not os.path.exists(output) or os.path.isdir(output):
            if ocr:
                raise RuntimeError(&quot;the OCR flag is useless because we are &quot;
                                   &quot;writing images (not PDF) to the output &quot;
                                   &quot;directory.&quot;)
            if not os.path.exists(output):
                Path(output).mkdir(parents=True)
            for (index, page) in enumerate(results):
                file_path = os.path.join(output, f&quot;&#123;index&#125;.jpg&quot;)
                assert isinstance(page, Image.Image)
                page.save(file_path)
        else:
            raise RuntimeError(&quot;invalid output format.&quot;)</code></pre>
<p>在多进程优化之后，脚本花了11分21秒就把测试用的《态度改变与社会影响》一书全文清理完毕。和原来30-40分钟的耗时对比，显然我们的优化是卓有成效的。</p>
<h1 id="大小优化">大小优化</h1>
<p><strong>未完待续</strong></p>
<p>现在唯一一个比较明显的问题就是：清理之后的结果文件实在是太大了。</p>
<p>究其原因，现在的脚本是将PDF按一定的分辨率光栅化之后获得图像进行清理，而不是直接从PDF中提取本来存在的图像。现在方法的好处是实现简洁，无需考虑PDF内图像的存储方式（测试中发现直接提取PDF中图像提取出来可能是横的，这就说明PDF其实再显示的时候额外标注了旋转的信息，这在直接提取中会丢失），但坏处就是结果图像的大小和原本嵌入的图像大小无关，而且提取的过程中可能产生误差(artifact，不知道怎么翻最为恰当)。</p>
<p>因此，解决这个问题也有两种思路：</p>
<ol type="1">
<li>治本：使用更复杂一点的逻辑对PDF中内嵌的图片进行保真的提取。这样一来结果文件的大小就和原来的文件大致一致，可能还会更小一点（考虑到清理的时候很多区域都会整个变成白色）。</li>
<li>治标：使用更加优秀的图像压缩算法。</li>
</ol>
<p>第一种思路还未实验。关于第二种思路，我不禁想到Google出品的无脑图像压缩应用<a target="_blank" rel="noopener" href="https://squoosh.app/">Squoosh</a>。Squoosh提供CLI，而且压缩率可以达到30%-40%，很有的吸引力。进一步探究，Squoosh默认使用的压缩工具是<a target="_blank" rel="noopener" href="https://mozjpeg.com/">MozJPEG</a>。这款Mozilla出品的压缩编码器似乎也是唯一靠谱的我们脚本里能用的（Squoosh里其他的压缩器的输出格式无法嵌入到PDF中，而且耗时太长）。但我在Windows上测试MozJPEG的CLI，发现无法输出合法的JPEG文件。还在尝试中。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ma-chengyuan.github.io/2021/05/19/Docleaner/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/19/Docleaner/" class="post-title-link" itemprop="url">科学白嫖“图档清洁专家”</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-19 08:35:44" itemprop="dateCreated datePublished" datetime="2021-05-19T08:35:44-04:00">2021-05-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>代码仅作学习用途，请勿分享传播。</strong></p>
<p>代码在<a target="_blank" rel="noopener" href="https://github.com/alan20210202/docleaner-web">这里</a>。</p>
<h1 id="问题背景">问题背景</h1>
<p>因为实体书购买麻烦、厚重、占地空间大（对于国外的一些原版教材来说，价格高昂），我一直是电子书的忠实拥趸。一般来说，市面上下载的到的电子书大致可以分为以下几类：</p>
<ol type="1">
<li>基于原内容的排版可变格式：一般为EPUB、MOBI或TXT格式，动态排版，在任何屏幕大小下都适合阅读。有索引，文字与图像本地渲染，清晰可辨。这是电子书的理想格式，但这种格式的书大多是以小说，我几乎没有见到过用这种格式排版的学术的教科书。</li>
<li>基于原内容的PDF：基于书的源文件直接渲染得来，排版不可变，在没有重排软件的情况下需要大屏阅读器才能舒适阅读，并且需要适当对页边进行裁剪。大部分时候有索引，文字和图像本地渲染，清晰可辨。这种PDF可遇而不可求。有教授把这种格式的书放在官网上给学生们免费下载（比如说<a target="_blank" rel="noopener" href="https://www.designofapproxalgs.com/">这个</a>）——我愿称他们为大善人。</li>
<li>精修的扫描PDF：是基于实体书扫描而来，文字部分经过OCR和轮廓平滑化变得更加清晰，公式可能经过重写也很清楚。良心一点的制作者会顺便把目录也做了。这种PDF（有的时候是DJVU）见到的概率比较高，libgen上十本里面能有六七本。我的Introduction to Linear Algebra就是这种类型。</li>
<li><strong>三无的扫描PDF</strong>：PDF制作者只进行了基本的扫描。<strong>文字有倾斜，页面有阴影，页边缘出镜导致黑边</strong>，有些还会有铅笔的笔记。OCR是没有的，目录是不用指望的。这种是电子书里的下品，像我这样有一些轻微强迫症的会觉得很难受。</li>
</ol>
<p>最近自己要找的一本书搜遍了网上也只有三无版本，真的感觉头很大，体验极差。那么，有什么办法能把这种三无版本清理一下，使之朝精修PDF的方向上靠拢呢？</p>
<p><strong><a target="_blank" rel="noopener" href="http://www.docleaner.cn/">图档清洁专家</a></strong>是我前几天在网上发现的。实测效果拔群。缺点是要付60块钱买正版。60元不是什么大钱，但是人是要有追求的：</p>
<p><img src="/2021/05/19/Docleaner/%E7%99%BD%E5%AB%96.jpg" class=""></p>
<p>正好，图档清理专家提供了<a target="_blank" rel="noopener" href="http://www.docleaner.cn/experience.html">在线体验</a>，这个在线体验提供的功能已经涵盖了我的需求了，但是为了防止我们白嫖地太爽，在线体验限制只能上传图片文件。对于我手里这本460页的教科书，一页页手工操作能把人折磨死。怎么办呢？</p>
<p><img src="/2021/05/19/Docleaner/Python.jpg" class=""></p>
<p>用Python自动化试试看？似乎能学到很多东西的样子。</p>
<h1 id="代码实现">代码实现</h1>
<p>我们的脚本需要实现以下功能：</p>
<ol type="1">
<li>将输入的PDF按页转换成高清图片。</li>
<li>以某种方式程序化地调用在线体验的功能。</li>
<li>将结果的图片下载下来重新拼合成为PDF。</li>
<li>可以顺便使用<a target="_blank" rel="noopener" href="https://pypi.org/project/pytesseract/">pytesseract</a>实现OCR。</li>
</ol>
<h2 id="pdf光栅化">PDF光栅化</h2>
<p>如果只考虑“将PDF转化为图片”的功能，最切题的库是<a target="_blank" rel="noopener" href="https://pypi.org/project/pdf2image/">pdf2image</a>，底层调用的工具是poppler。这也是我一开始的选择。</p>
<p>但是后来转念一想，既然后面还有要将图片转PDF，PDF拼合的需求，寻找一款更为通用的PDF库是更明智的做法。</p>
<p>经过一番搜索，跳过已经五年没有出过新版本的的PyPDF2，我选择了目前维护勤快的<a target="_blank" rel="noopener" href="https://pypi.org/project/PyMuPDF/">PyMuPDF</a>。PyMuPDF调用的是MuPDF这个用C写的成熟的PDF库，功能与性能都是有保障的。MuPDF的license上说明对于开源项目免费授权，因此我就大胆地用了。</p>
<p>使用PyMuPDF进行PDF的光栅化，代码如下：</p>
<pre class="line-numbers"><code class="language-python">import fitz
from typing import Optional, Generator, Union
from pathlib import Path

StrPath = Union[str, os.PathLike]

def convert_pdf_to_images(pdf: StrPath, fmt: str, dpi: int,
                          output: Optional[StrPath] = None,
                          first_page: Optional[int] = None,
                          last_page: Optional[int] = None) \
        -&gt; Generator[StrPath, None, None]:
    &quot;&quot;&quot;
    Converts a pdf file to images. This a necessary pre-processing step
    because docleaner online only accepts images as inputs.
    
    :param pdf: The path to the pdf file.
    :param fmt: Image file format. jpg is the fastest but not lossless; png is
        lossless but slow; tiff is theoretically the best but occupies a lot of
        disk space.
    :param dpi: Pixel density of the output images.
    :param output: The output directory of intermediate images.
    :param first_page: First page to convert (starting from 1, inclusive).
    :param last_page: Last page to convert (starting from 1, inclusive).
    :return: A generator yielding the paths to the images.
    &quot;&quot;&quot;
    doc = fitz.Document(pdf)

    @contextmanager
    def normal_dir(dir_path):
        Path(dir_path).mkdir(parents=True, exist_ok=True)
        yield dir_path

    matrix = fitz.Matrix(dpi / 72, dpi / 72)
    first_page = 0 if first_page is None else first_page - 1
    last_page = doc.page_count if last_page is None else last_page
    with tempfile.TemporaryDirectory() if output is None else normal_dir(
            output) as path:
        for i in range(first_page, last_page):
            filename = os.path.join(path, f&quot;&#123;i&#125;.&#123;fmt&#125;&quot;)
            # noinspection PyUnresolvedReferences
            doc[i].get_pixmap(matrix=matrix).save(filename)
            yield filename
        if output is None:
            # Yield an empty string if we are using a temporary directory,
            # because without this, the temporary directory will be cleaned
            # up the moment the last filename is yielded, when the caller
            # hasn&#39;t done anything to the yielded temp file yet. Yielding an
            # emtpy string keeps the TemporaryDirectory object in memory
            # longer so the problem is solved.
            yield &quot;&quot;</code></pre>
<p>这个代码乍一看是比较复杂，有几个重点：</p>
<ol type="1">
<li>代码写成了生成器的形式，这样便于和后续的其他功能进行更好的耦合。个人认为生成器是一个很不错的语法糖。</li>
<li>为了方便静态检查，我这里给方法签名标注了类型。</li>
<li>为了同时处理输出图片到临时目录和正常目录（可以用于其他工具）的情形，这里定义了名为<code>normal_dir</code>的<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/contextlib.html">context manager</a>以和<code>TemporaryDirectory</code>保持形式上的一致。这样代码可以更加简短。要使用<code>TemporaryDirectory()</code>而不是<code>mkdtemp()</code>的原因是前者确保了临时文件夹最终会被删除。</li>
<li>但是<code>TemporaryDirectory()</code>在结束后删除临时文件夹会带来一个问题：在<code>yield</code>最后一页的图片的路径之后，临时文件夹马上就被删除了，刚返回的路径也就失效了。调用这个生成器的代码使用的时候就会产生找不到文件的错误。一个粗暴的解决方案就是让<code>with</code>块执行得再久一点——比如说在下次调用的时候再结束。这就是最后<code>yield ""</code>的意义。</li>
<li>PyMyPDF默认的<code>get_pixmap</code>方法输出的图片分辨率等于当前页面的边界矩形大小（bound rectangle）。这个边界矩形尺寸是以点数（pts）为单位的，1英寸等于72点，因此如果需要达到指定的DPI，<code>get_pixmap</code>在执行的时候就需要放大<code>dpi / 72</code>倍。这就是<code>matrix = fitz.Matrix(dpi / 72, dpi / 72)</code>的含义。</li>
</ol>
<p>剩下的无非就是看文档写代码。</p>
<h2 id="使用selenium自动化在线体验">使用Selenium自动化“在线体验”</h2>
<p>人工一页一页上传手抽筋怎么办？一个很自然的思路就是让代码来直接操控浏览器。在这方面，因为网站开发自动化测试的需求，有人已经帮我们写好轮子了——Selenium。</p>
<p><img src="/2021/05/19/Docleaner/image-20210511174658388.png" class=""></p>
<p>根据官网上的描述，Selenium和我们的需求完美对接，而且Selenium提供了Python的接口。</p>
<p>使用Selenium的第一步是打开浏览器并且访问目标网页：</p>
<pre class="line-numbers"><code class="language-python">from selenium import webdriver

browser = webdriver.Chrome()
# browser = webdriver.Firefox()
# browser = webdriver.Edge()
# browser = webdriver.Safari()
browser.get(&quot;http://www.docleaner.cn/experience.html&quot;)</code></pre>
<p>打开哪个浏览器就取决于个人喜好了。在这里需要注意：除了在Python环境里安装selenium包以外，还需要自行安装对应浏览器的WebDriver。具体如何装，怎么装，请参阅Selenium的文档。就我个人体验而言，Chrome的WebDriver启动得很快，但是默认会把日志写入控制台导致进度条显示混乱；Firefox得WebDriver要花一两秒启动，但默认会写日志到geckodriver.log里面。</p>
<p><img src="/2021/05/19/Docleaner/image-20210511180117997.png" class=""></p>
<p>在执行以上代码之后要做两件事：</p>
<ol type="1">
<li>等待页面加载完毕（废话），以及</li>
<li>打开去背景和自动纠斜这两个默认关闭但是很有用的开关。</li>
</ol>
<p>Selenium的API允许我们把两件事并在一起做，前提是我要知道两个开关的“路径”——CSS选择器或XPath都行。</p>
<pre class="line-numbers"><code class="language-python">from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.ui import WebDriverWait

WebDriverWait(browser, timeout).until(
    expected_conditions.visibility_of_element_located(
        (By.XPATH,
        &quot;开关的XPath&quot;)
    )
).click()</code></pre>
<p>以“自动纠斜”开关为例，其周围的HTML如下：</p>
<pre class="line-numbers"><code class="language-html">&lt;div style=&quot;position: relative;&quot;&gt;
    &lt;button type=&quot;button&quot; class=&quot;layui-btn layui-btn-primary buttoncss buttoncss0&quot; style=&quot;padding: 0 10px;&quot;&gt;
        &lt;img src=&quot;http://www.docleaner.cn/templets/1/qwsoft//resource/images/jiuxie.png&quot;&gt;自动纠斜
    &lt;/button&gt;
    &lt;div class=&quot;buttoncheckbox&quot;&gt;
        &lt;input type=&quot;checkbox&quot; name=&quot;exeConfig&quot; lay-filter=&quot;exeConfig&quot; value=&quot;自动纠斜&quot; lay-skin=&quot;primary&quot;&gt;
        &lt;div class=&quot;layui-unselect layui-form-checkbox&quot; lay-skin=&quot;primary&quot;&gt;&lt;i class=&quot;layui-icon layui-icon-ok&quot;&gt;&lt;/i&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>我们的目标是那个<code>&lt;button&gt;</code>元素，比较好找的是<code>&lt;input&gt;</code>元素，其XPath就是<code>//input[@value='自动纠斜']</code>。</p>
<p>接下来我们要使用XPath的Axes语义间接地定位到<code>&lt;button&gt;</code>：</p>
<p><code>//input[@value='自动纠斜']/parent::div/preceding-sibling::button</code></p>
<p>语义很清楚，就不多解释了。完整的Axes列表可以看<a target="_blank" rel="noopener" href="https://www.w3schools.com/xml/xpath_axes.asp">这里</a>。</p>
<p>类似地，我们可以定位上传按钮的位置：</p>
<pre class="line-numbers"><code class="language-python">uploader = WebDriverWait(browser, timeout).until(
    expected_conditions.presence_of_element_located(
        (By.CLASS_NAME, &quot;layui-upload-file&quot;)))</code></pre>
<p>注意到这里是<code>presence_of_element_located</code>，前面是<code>visibility_of_element_located</code>，区别在于后者必须要求元素在浏览器框里面可视，而前者只需要DOM里有就行了。我们之前需要点击开关，因此必须先看得见才行（而且可视是确保网页加载完毕的一个更靠谱的条件），而上传控件在网页里是一个隐藏起来的<code>&lt;input&gt;</code>，因此只要present in DOM就行了。</p>
<p>往上传控件上传东西调用的是<code>send_keys</code>函数，很有意思：</p>
<pre class="line-numbers"><code class="language-python">uploader.send_keys(file_path)</code></pre>
<p>然后等一会网页右边就会出现处理后的图像。其实显示结果的<code>&lt;img&gt;</code>一直都在，只是直到处理完成之后才可见，我们借此找到这个控件并且作为处理完成的依据：</p>
<pre class="line-numbers"><code class="language-python">result = WebDriverWait(browser, timeout).until(
    expected_conditions.visibility_of_element_located(
        (By.ID, &quot;dragImgRight&quot;)))</code></pre>
<p>开发者很好心地（？）在结果图像控件的<code>src</code>字段直接使用base64编码图片，连额外下载的代码都免了，我们直接得到结果图像：</p>
<pre class="line-numbers"><code class="language-python">import io
import base64
from PIL import Image

result = result.get_attribute(&quot;src&quot;)
result = base64.b64decode(
    result.replace(&quot;data:image/jpg;base64,&quot;, &quot;&quot;))
yield Image.open(io.BytesIO(result))</code></pre>
<p>最后，注意把结果的<code>&lt;img&gt;</code>再藏起来，这样通过可见性来判断是否处理完成的逻辑在下一张图片传上去的时候才有效。经查，结果的可见性通过<code>&lt;img&gt;</code>父元素<code>class</code>列表里<code>layui-hide</code>的存在与否来判定。我们选择通过Selenium让浏览器执行JavaScript进行这种有点复杂度的操作：</p>
<pre class="line-numbers"><code class="language-python">browser.execute_script(
    &quot;arguments[0].parentNode.classList.add(&#39;layui-hide&#39;);&quot;, result)</code></pre>
<p><code>arguments</code>自然就是后面传参的数组。</p>
<p>完整的代码如下：</p>
<pre class="line-numbers"><code class="language-python">def clean_doc_online(images: Generator[StrPath, None, None], browser: str) \
        -&gt; Generator[Image.Image, None, None]:
    &quot;&quot;&quot;
    Cleans the scanned document pages using docleaner&#39;s online service.
    
    :param images: A generator yielding paths to document pages.
    :param browser: Browser type, can be &quot;chrome&quot;, &quot;firefox&quot;, &quot;safari&quot;, or
        &quot;edge&quot;. Requires the browser and its webdriver to be installed.
    &quot;&quot;&quot;
    if browser == &quot;chrome&quot;:
        browser = webdriver.Chrome()
    elif browser == &quot;firefox&quot;:
        browser = webdriver.Firefox()
    elif browser == &quot;safari&quot;:
        browser = webdriver.Safari()
    elif browser == &quot;edge&quot;:
        browser = webdriver.Edge()
    else:
        raise RuntimeError(&quot;Unknown browser type&quot;)
    # Timeout for web driver waits. 10s is a reasonable value unless you have
    # a very high-res image / terrible network.
    timeout = 10
    browser.get(&quot;http://www.docleaner.cn/experience.html&quot;)

    # Turn on background removal and automatic deskewing.
    WebDriverWait(browser, timeout).until(
        expected_conditions.visibility_of_element_located(
            (By.XPATH,
             &quot;//input[@value=&#39;去背景&#39;]/parent::div/preceding-sibling::button&quot;)
        )
    ).click()
    WebDriverWait(browser, timeout).until(
        expected_conditions.visibility_of_element_located(
            (By.XPATH,
             &quot;//input[@value=&#39;自动纠斜&#39;]/parent::div/preceding-sibling::button&quot;)
        )
    ).click()
    # Wait for a while to ensure the changes take effect.
    time.sleep(1)

    uploader = WebDriverWait(browser, timeout).until(
        expected_conditions.presence_of_element_located(
            (By.CLASS_NAME, &quot;layui-upload-file&quot;)))

    try:
        uploader.send_keys(next(images))
        while True:
            # Write like this instead of a for loop enables us to fetch the
            # next image while the browser &amp; remote server are processing the
            # image just uploaded. Converting a pdf page to an image is slow,
            # so we here save a lot of time :)
            next_image = next(images)
            # Wait for the result image to be visible.
            result = WebDriverWait(browser, timeout).until(
                expected_conditions.visibility_of_element_located(
                    (By.ID, &quot;dragImgRight&quot;)))
            # Hide the result image again so the wait condition above can be
            # re-used.
            browser.execute_script(
                &quot;arguments[0].parentNode.classList.add(&#39;layui-hide&#39;);&quot;, result)
            result = result.get_attribute(&quot;src&quot;)
            result = base64.b64decode(
                result.replace(&quot;data:image/jpg;base64,&quot;, &quot;&quot;))
            yield Image.open(io.BytesIO(result))
            if next_image == &quot;&quot;:
                # See convert_pdf_to_images for the reason behind this weird
                # branch.
                break
            uploader.send_keys(next_image)
    except StopIteration:
        pass

    browser.quit()</code></pre>
<p>注意三点：</p>
<ol type="1">
<li>之前在PDF转图片的设计中有返回空路径的奇技淫巧需要特判。</li>
<li>在点击开关之后需要等一会来确保开关真的点下去了。</li>
<li>循环的写法最好不要写成标准的<code>for</code>循环，因为这样的话文件图片上去之后代码就是干等。现在的写法确保了图片传上去之后立刻就获取下一张图片，之后再判断等待是否当前图片处理完成。再调用<code>next(images)</code>的过程中，浏览器也在独立于Python进程运行，因此我们毫无损失。将PDF的一页转化为一张高清图片需要1-2秒钟，而网站处理图片大概也是这么长时间，因此在这里循环写法的改变是一个很不错的优化。</li>
</ol>
<h2 id="将下载下来的图片拼合回pdf">将下载下来的图片拼合回PDF</h2>
<p>这个功能的实现是相对简单，只要照着PyMuPDF的文档写就行了。</p>
<p>同时，我注意到pytesseract里面有输入图片直接输出PDF的函数，因此可以一并在这里完成。</p>
<p>顺便可以通过tqdm显示一个进度条，方便看清进度。</p>
<p>最终代码如下：</p>
<pre class="line-numbers"><code class="language-python">from tqdm import tqdm
import pytesseract

def convert_images_to_pdf(images: Generator[Image.Image, None, None],
                          output: StrPath,
                          ocr: bool = True, total: Optional[int] = None):
    &quot;&quot;&quot;
    Converts and merges images to a one-page pdf file, performing optional
    OCR in the process.

    :param images: A generator yielding PIL image objects.
    :param output: Path to the result pdf.
    :param ocr: Whether to perform OCR(Optical Character Recognition).
    :param total: An optional integer hinting the total number of images given.
        If supplied, a progress bar will be displayed during the conversion.
    &quot;&quot;&quot;
    doc = fitz.Document()
    for image in images if total is None else tqdm(images, total=total):
        if ocr:
            pdf = pytesseract.image_to_pdf_or_hocr(image)
            page = fitz.Document(stream=pdf, filetype=&quot;pdf&quot;)
            doc.insert_pdf(page)
        else:
            # noinspection PyUnresolvedReferences
            page = doc.new_page(width=image.width, height=image.height)
            buffer = io.BytesIO()
            image.save(buffer, format=&quot;jpeg&quot;)
            page.insert_image(fitz.Rect(0, 0, image.width, image.height),
                              stream=buffer)
    doc.save(output)</code></pre>
<h2 id="cli封装">CLI封装</h2>
<p>在最后的最后，可以通过<a target="_blank" rel="noopener" href="https://click.palletsprojects.com/en/7.x/">Click</a>库，为脚本进行一个CLI的封装：</p>
<pre class="line-numbers"><code class="language-python">import click

@click.command()
@click.argument(&quot;input&quot;, type=click.Path(exists=True))
@click.argument(&quot;output&quot;, type=click.Path())
@click.option(&quot;-f&quot;, &quot;--format&quot;, default=&quot;png&quot;,
              help=&quot;Intermediate image format.&quot;)
@click.option(&quot;-d&quot;, &quot;--dpi&quot;, default=300, help=&quot;DPI for rasterization.&quot;)
@click.option(&quot;-b&quot;, &quot;--browser&quot;, default=&quot;chrome&quot;,
              help=&quot;The browser selenium uses.&quot;)
@click.option(&quot;--first-page&quot;, type=int, help=&quot;First page to convert/clean.&quot;)
@click.option(&quot;--last-page&quot;, type=int, help=&quot;Last page to convert/clean.&quot;)
@click.option(&quot;--ocr/--no-ocr&quot;, default=True,
              help=&quot;Whether to perform OCR during the conversion.&quot;)
@click.option(&quot;--clean/--dont-clean&quot;, default=True,
              help=&quot;Whether to clean pdf using docleaner&#39;s online service.&quot;)
def main(input: str, output: str, format: str, dpi: int, browser: str,
         first_page: Optional[int], last_page: Optional[int], ocr: bool,
         clean: bool):
    images = convert_pdf_to_images(input, fmt=format, dpi=dpi,
                                   first_page=first_page, last_page=last_page)
    if clean:
        images = clean_doc_online(images, browser)
    doc = fitz.Document(input)
    total = (doc.page_count if last_page is None else last_page) \
        - (0 if first_page is None else first_page - 1)
    convert_images_to_pdf(images, output, ocr=ocr, total=total)


if __name__ == &quot;__main__&quot;:
    main()</code></pre>
<p>大功告成！</p>
<h1 id="测试">测试</h1>
<p>我选取的测试书籍是津巴多的《态度改变与心理影响》。原文扫描版460页98.4MB，自动化脚本耗时半个小时左右处理完毕，结果大小为325MB。对比如下（典型页面）：</p>
<p><img src="/2021/05/19/Docleaner/Comparison.jpg" class=""></p>
<p>可以看到，脚本做出了显著的优化，但在脚本运行中也发现了一些可以改进的地方：</p>
<ol type="1">
<li>过于激进的光栅化分辨率使得结果文档的大小显著增加。</li>
<li>基于Selenium的解决方案偶尔会出现开关没有开或者莫名其妙地关掉的情形。</li>
<li>脚本的运行效率有待提升。</li>
</ol>
<p>对于这三点，我们将在以后的文章中进行改进。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ma-chengyuan.github.io/2021/04/30/Determinant/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/30/Determinant/" class="post-title-link" itemprop="url">行列式笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-30 22:44:36" itemprop="dateCreated datePublished" datetime="2021-04-30T22:44:36-04:00">2021-04-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在看了<em>Introduction to Linear Algebra</em>之后我对于行列式真的是豁然开朗。</p>
<h1 id="行列式的性质">行列式的性质</h1>
<p>行列式被定义为具有一下三个核心性质的，关于一个方阵的值：</p>
<ol type="1">
<li><p><strong>单位阵的行列式为1。</strong></p></li>
<li><p><strong>两行交换，行列式变号。</strong></p></li>
<li><p><strong>行列式关于单行是线性的，即</strong></p>
<p><span class="math display">\[
\begin{vmatrix} \vdots \\ (\boldsymbol  a + \boldsymbol b)^{\mathrm T} \\ \vdots \end{vmatrix} = \begin{vmatrix} \vdots \\ \boldsymbol a^{\mathrm T} \\ \vdots \end{vmatrix} + \begin{vmatrix} \vdots \\ \boldsymbol b^{\mathrm T} \\ \vdots \end{vmatrix},\quad\quad
\begin{vmatrix} \vdots \\ (t\boldsymbol a)^{\mathrm T} \\ \vdots \end{vmatrix} = t\begin{vmatrix} \vdots \\ \boldsymbol a^{\mathrm T} \\ \vdots \end{vmatrix}
\]</span></p></li>
</ol>
<p>从这三个性质，可以导出行列式所有重要的性质：</p>
<ol start="4" type="1">
<li><p><strong>两行相等，行列式为<span class="math inline">\(0\)</span>。</strong>证明：交换相等两行，行列式不变，但又由性质2，行列式要变号，因此行列式只能是<span class="math inline">\(0\)</span>。</p></li>
<li><p><strong>初等行变换不改变行列式的值。</strong>证明：由性质3、4得：、</p>
<p><span class="math display">\[
\begin{vmatrix}
 \vdots \\
 \boldsymbol b^{\mathrm T} \\
 \vdots \\
 (\boldsymbol a -l \boldsymbol b)^{\mathrm T} \\
 \vdots
\end{vmatrix}
 = \begin{vmatrix}
 \vdots \\
 \boldsymbol b^{\mathrm T} \\
 \vdots \\
 \boldsymbol a^{\mathrm T} \\
 \vdots
\end{vmatrix}
-
l\begin{vmatrix}
 \vdots \\
 \boldsymbol b^{\mathrm T} \\
 \vdots \\
 \boldsymbol b^{\mathrm T} \\
 \vdots
\end{vmatrix}
= \begin{vmatrix}
 \vdots \\
 \boldsymbol b^{\mathrm T} \\
 \vdots \\
 \boldsymbol a^{\mathrm T} \\
 \vdots
\end{vmatrix}
-
l\cdot 0
= \begin{vmatrix}
 \vdots \\
 \boldsymbol b^{\mathrm T} \\
 \vdots \\
 \boldsymbol a^{\mathrm T} \\
 \vdots
\end{vmatrix}
\]</span></p></li>
<li><p><strong>有一行为<span class="math inline">\(\boldsymbol 0\)</span>，则行列式为<span class="math inline">\(0\)</span>。</strong>证明：将另一行加到零行上，出现相等的两行，由性质4，行列式的值为<span class="math inline">\(0\)</span>。又因为初等行变换不改变行列式的值，所以原来的行列式值也是<span class="math inline">\(0\)</span>。</p></li>
<li><p><strong>三角阵的行列式为其主对角线元素之积。</strong>证明：无论是上三角阵还是下三角阵，都可以简单地利用行变换消去非对角线上的元素，此时由性质1和性质3，行列式的值就是主对角线元素之积。</p></li>
<li><p><strong>矩阵可逆，则行列式非零。</strong>证明：考虑高斯消元，如果矩阵奇异则必然三角阵中有零行，行列式为<span class="math inline">\(0\)</span>。反之，则左右行都是主元行，三角阵的行列式非零。（高斯消元过程中的行变换不改变行列式，行交换只改变正负。）</p></li>
<li><p><strong>积的行列式等于行列式的积。</strong>证明：对于矩阵<span class="math inline">\(A,B\)</span>，考虑关于<span class="math inline">\(A\)</span>的函数<span class="math inline">\(D(A) = |AB|/|B|\)</span>。其有三个性质：</p>
<ol type="1">
<li><span class="math inline">\(D(I) = |B|/|B| = 1\)</span>。</li>
<li><span class="math inline">\(A\)</span>的两行交换，则<span class="math inline">\(AB\)</span>的两行交换，则<span class="math inline">\(|AB|\)</span>变号，则<span class="math inline">\(D(A)\)</span>变号。</li>
<li><span class="math inline">\(A\)</span>的单行线性变换即<span class="math inline">\(AB\)</span>的单行线性变换，因此<span class="math inline">\(|AB|\)</span>关于<span class="math inline">\(A\)</span>的单行是线性的，即<span class="math inline">\(D(A)\)</span>关于<span class="math inline">\(A\)</span>单行是线性的。</li>
</ol>
<p>因此，<span class="math inline">\(D(A)\)</span>满足行列式的核心性质，由行列式之定义，<span class="math inline">\(D(A) = |A|\)</span>。</p></li>
<li><p><strong>转置不改变行列式的值。</strong>若矩阵奇异，则其转置奇异，则二者行列式皆为<span class="math inline">\(0\)</span>。若矩阵可逆，则考虑LU分解<span class="math inline">\(PA=LU\)</span>。两边转置得<span class="math inline">\(A^{\mathrm T}P^{\mathrm T} = U^{\mathrm T}L^{\mathrm T}\)</span>。由性质9，有 <span class="math display">\[
|P||A|=|L||U|,\quad \left|A^{\mathrm T}\right|\left|P^{\mathrm T}\right| = \left|U^{\mathrm T}\right|\left|L^{\mathrm T}\right|
\]</span> 比较二式，<span class="math inline">\(L,U\)</span>为三角阵，因为转置不改变对角线，因而转置不改变二者行列式的值。<span class="math inline">\(P\)</span>为行交换的排列，行列式为<span class="math inline">\(\pm 1\)</span>，而<span class="math inline">\(P^{\mathrm T}P=I\)</span>，因此<span class="math inline">\(|P|\)</span>和<span class="math inline">\(\left|P^{\mathrm T}\right|\)</span>同正负，即相等。综上，由两等式，<span class="math inline">\(|A| = \left|A^{\mathrm T}\right|\)</span>。</p>
<p><strong>推论：</strong>性质2、3、4、5、6对于列也适用。</p></li>
</ol>
<h1 id="行列式的计算">行列式的计算</h1>
<h2 id="排列公式">排列公式</h2>
<p>由行列式的单行线性，可以逐行将行列式进行拆分，例如： <span class="math display">\[
\begin{aligned}
    \begin{vmatrix}
        a &amp;b\\
        c &amp;d
    \end{vmatrix} &amp;= \begin{vmatrix}
        a &amp;0\\
        c &amp;d
    \end{vmatrix} + \begin{vmatrix}
        0 &amp;b\\
        c &amp;d
    \end{vmatrix} \\
    &amp;= \begin{vmatrix}
        a &amp;0\\
        c &amp;0
    \end{vmatrix} + \begin{vmatrix}
        a &amp;0\\
        0 &amp;c
    \end{vmatrix} + \begin{vmatrix}
        0 &amp;b\\
        c &amp;0
    \end{vmatrix} + \begin{vmatrix}
        0 &amp;b\\
        0 &amp;d
    \end{vmatrix}
\end{aligned}
\]</span> 照此态势，<span class="math inline">\(n\)</span>行的行列式可以被分拆为<span class="math inline">\(n^n\)</span>个每行至多只有一个非零元素的行列式之和。而注意到，这些行列式有一些存在零列，他们的值一定为<span class="math inline">\(0\)</span>可以省略。因此，可能非零的只有那些每行至多只有一个非零元素，且非零元素所在列两两不同的行列式。对于这些行列式，存在排列矩阵可以将其对角化，进而我们得出这些行列式的值为每一行可能的非零元素之积乘以排列矩阵的行列式，后者只可能是<span class="math inline">\(\pm 1\)</span>——不妨将这正负定义为排列的“奇偶性”。则行列式的排列公式呼之欲出：</p>
<blockquote>
<p><span class="math display">\[
A_{n\times n} = \sum_{\pi \in S_n} (-1)^{\sigma(\pi)}\prod_{i=1}^na_{i, \pi(i)}
\]</span></p>
<p>其中<span class="math inline">\(S_n\)</span>表示所有<span class="math inline">\(n\)</span>排列的集合，<span class="math inline">\(\pi\)</span>表示一个排列，<span class="math inline">\(\sigma(\pi)\)</span>表示<span class="math inline">\(\pi\)</span>的逆序对数，即 <span class="math display">\[
\sigma(\pi)=\sum_{i&lt;j}[\pi(i) &gt; \pi(j)]
\]</span></p>
</blockquote>
<h2 id="行列展开">行列展开</h2>
<p>同样由行列式的单行线性，可以将行列式的某一行进行拆分成<span class="math inline">\(n\)</span>个该行只有至多一个非零元素的行列式之和。对于每一个这样的行列式考虑排列公式：显然有效的排列是正好在那一行选中了非零元素的那一列的（其他的排列都选到了<span class="math inline">\(0\)</span>，就没有贡献了），去掉选中这个元素的部分，这些排列恰好全部转化为<span class="math inline">\(n-1\)</span>长度的全排列，覆盖了矩阵中所有不在非零元素所在行所在列的元素——那这些是不是可以看作是一个小一点的<span class="math inline">\(n-1\)</span>阶行列式呢？这就是行列式行列展开的原理。</p>
<p>因为这个笔记主要是我复习自用，所以具体形式我就不多写了。</p>
<p>我记得自己两年之前写过一篇<a href="/2019/12/13/%E8%A1%8C%E5%88%97%E5%BC%8F%E8%AE%A1%E7%AE%97/" title="行列式值的按行列展开定义与排列定义等价性证明">行列式值的按行列展开定义与排列定义等价性证明</a>，那个时候觉得自己写了一大堆很厉害，现在一看，虽然比较严谨，但是格局小了。</p>
<h1 id="克拉默法则">克拉默法则</h1>
<p>克拉默法则提供了一种在形式上求解线性方程的工具，其证明如下： <span class="math display">\[
\left.
\begin{aligned}
A \boldsymbol x &amp;= \boldsymbol b \\
A I &amp;= A
\end{aligned}
\right\}
\Rightarrow 
A \cdot \begin{bmatrix}
1 &amp;0 &amp;\cdots &amp;0 &amp;x_1 &amp;0 &amp;\cdots &amp;0 \\
0 &amp;1 &amp;\cdots &amp;0 &amp;x_2  &amp;0&amp;\cdots &amp;0 \\
\vdots &amp;\vdots &amp;\ddots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\ddots  &amp;\vdots \\
0 &amp;0 &amp;\cdots &amp;1 &amp;x_{i-1} &amp;0 &amp;\cdots &amp;0 \\
0 &amp;0 &amp;\cdots &amp;0 &amp;x_{i} &amp;0 &amp;\cdots &amp;0 \\
0 &amp;0 &amp;\cdots &amp;0 &amp;x_{i+1} &amp;1 &amp;\cdots &amp;0 \\
\vdots &amp;\vdots &amp;\ddots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\ddots  &amp;\vdots \\
0 &amp; 0 &amp;\cdots &amp;0 &amp;x_n &amp;0 &amp;\cdots &amp;1
\end{bmatrix} = \begin{bmatrix}
    \vert &amp;\vert &amp;\cdots &amp;\vert &amp;\vert &amp;\vert &amp;\cdots &amp;\vert\\
    \boldsymbol{a_1} &amp;\boldsymbol{a_2} &amp;\cdots  &amp; \boldsymbol{a_{i - 1}} &amp;\boldsymbol b &amp; \boldsymbol{a_{i + 1}} &amp;\cdots &amp;\boldsymbol{a_n} \\
    \vert &amp;\vert &amp;\cdots &amp;\vert &amp;\vert &amp;\vert &amp;\cdots &amp;\vert\\
\end{bmatrix}
\]</span> 因此，由积的行列式为行列式的积，就有 <span class="math display">\[
|A| \cdot \begin{vmatrix}
1 &amp;0 &amp;\cdots &amp;0 &amp;x_1 &amp;0 &amp;\cdots &amp;0 \\
0 &amp;1 &amp;\cdots &amp;0 &amp;x_2  &amp;0&amp;\cdots &amp;0 \\
\vdots &amp;\vdots &amp;\ddots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\ddots  &amp;\vdots \\
0 &amp;0 &amp;\cdots &amp;1 &amp;x_{i-1} &amp;0 &amp;\cdots &amp;0 \\
0 &amp;0 &amp;\cdots &amp;0 &amp;x_{i} &amp;0 &amp;\cdots &amp;0 \\
0 &amp;0 &amp;\cdots &amp;0 &amp;x_{i+1} &amp;1 &amp;\cdots &amp;0 \\
\vdots &amp;\vdots &amp;\ddots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\ddots  &amp;\vdots \\
0 &amp; 0 &amp;\cdots &amp;0 &amp;x_n &amp;0 &amp;\cdots &amp;1
\end{vmatrix} = \begin{vmatrix}
    \vert &amp;\vert &amp;\cdots &amp;\vert &amp;\vert &amp;\vert &amp;\cdots &amp;\vert\\
    \boldsymbol{a_1} &amp;\boldsymbol{a_2} &amp;\cdots  &amp; \boldsymbol{a_{i - 1}} &amp;\boldsymbol b &amp; \boldsymbol{a_{i + 1}} &amp;\cdots &amp;\boldsymbol{a_n} \\
    \vert &amp;\vert &amp;\cdots &amp;\vert &amp;\vert &amp;\vert &amp;\cdots &amp;\vert\\
\end{vmatrix}
\]</span> 而注意到 <span class="math display">\[
\begin{vmatrix}
1 &amp;0 &amp;\cdots &amp;0 &amp;x_1 &amp;0 &amp;\cdots &amp;0 \\
0 &amp;1 &amp;\cdots &amp;0 &amp;x_2  &amp;0&amp;\cdots &amp;0 \\
\vdots &amp;\vdots &amp;\ddots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\ddots  &amp;\vdots \\
0 &amp;0 &amp;\cdots &amp;1 &amp;x_{i-1} &amp;0 &amp;\cdots &amp;0 \\
0 &amp;0 &amp;\cdots &amp;0 &amp;x_{i} &amp;0 &amp;\cdots &amp;0 \\
0 &amp;0 &amp;\cdots &amp;0 &amp;x_{i+1} &amp;1 &amp;\cdots &amp;0 \\
\vdots &amp;\vdots &amp;\ddots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\ddots  &amp;\vdots \\
0 &amp; 0 &amp;\cdots &amp;0 &amp;x_n &amp;0 &amp;\cdots &amp;1
\end{vmatrix} = x_i
\]</span> 因此就有 <span class="math display">\[
x_i = \frac{\begin{vmatrix}
    \vert &amp;\vert &amp;\cdots &amp;\vert &amp;\vert &amp;\vert &amp;\cdots &amp;\vert\\
    \boldsymbol{a_1} &amp;\boldsymbol{a_2} &amp;\cdots  &amp; \boldsymbol{a_{i - 1}} &amp;\boldsymbol b &amp; \boldsymbol{a_{i + 1}} &amp;\cdots &amp;\boldsymbol{a_n} \\
    \vert &amp;\vert &amp;\cdots &amp;\vert &amp;\vert &amp;\vert &amp;\cdots &amp;\vert\\
\end{vmatrix}}{|A|}
\]</span> 即克拉默法则得证。</p>
<h1 id="行列式体积">行列式体积</h1>
<p>行列式的几何意义为：以行列式的行向量为边的高维盒体（box，不知道怎么翻最合适，就是矩形，平行六面体等）的“带号体积”。</p>
<p>为什么？因为这个几何意义是满足行列式的三条根本性质的：</p>
<ol type="1">
<li>单位阵的行向量组成的盒体就是单位盒体，体积显然是一。</li>
<li>交换行列式的行不会改变盒体的形状，所以带号体积的绝对值不变，但符号是改变的（这姑且是带号体积的“定义”吧，带号体积的绝对值就是常规意义下的体积，这是自然的）。</li>
<li>对行列式一行的向量进行线性拉伸，对应盒体的体积显然也会线性拉伸。把行列式一行的行向量分拆成两个行向量之和……这个似乎有些复杂，在二维的情况下容易画图理解，在高维的情况下类似。</li>
</ol>
<p>因此，以原点为一个顶点，另外两个顶点为<span class="math inline">\((x_1, y_1), (x_2, y_2)\)</span>的三角形面积就是 <span class="math display">\[
\frac{1}{2}\left|\begin{vmatrix}x_1 &amp;y_1 \\ x_2 &amp;y_2\end{vmatrix}\right|
\]</span> 三个顶点为<span class="math inline">\((x_1,y_2),(x_2,y_2),(x_3, y_3)\)</span>的三角形面积就是 <span class="math display">\[
\frac{1}{2}\left|\begin{vmatrix}x_1 &amp;y_1 &amp; 1\\ x_2 &amp;y_2 &amp;1 \\ x_3 &amp;y_3 &amp;1\end{vmatrix}\right|
\]</span> 上面这个公式可以想象三个三维向量感性理解一波（脑补割补和祖暅原理），也可以通过对<span class="math inline">\(1\)</span>列的展开归约到上式。</p>
<h1 id="三维向量的叉积">三维向量的叉积</h1>
<p>两个三维向量的叉积<span class="math inline">\(\boldsymbol u \times \boldsymbol v\)</span>定义为另外一个三维向量，其模为<span class="math inline">\(|\boldsymbol u||\boldsymbol v||\sin \theta|\)</span>，其方向垂直<span class="math inline">\(\boldsymbol u, \boldsymbol v\)</span>。叉积的公式可以通过如下的伪·行列式进行记忆： <span class="math display">\[
\boldsymbol u \times \boldsymbol v = \begin{vmatrix}
    \boldsymbol i &amp;\boldsymbol j &amp;\boldsymbol k \\
    \boldsymbol u_1 &amp;\boldsymbol u_2 &amp;\boldsymbol u_3 \\
    \boldsymbol v_1 &amp;\boldsymbol v_2 &amp;\boldsymbol v_3 \\    
\end{vmatrix}
\]</span> 其中<span class="math inline">\(\boldsymbol i = (1, 0, 0), \boldsymbol j = (0, 1, 0), \boldsymbol k = (0, 0, 1)\)</span>。</p>
<p>显然，从上面的行列式形式我们看出叉积具有反对称性：<span class="math inline">\(\boldsymbol u \times \boldsymbol v = -\boldsymbol v \times \boldsymbol u\)</span>。</p>
<p>叉积在物理上具有比较重要的应用。</p>
<p>最后，有一种有意思的写法：叉积再点积 <span class="math display">\[
(\boldsymbol u \times \boldsymbol v)\cdot \boldsymbol w = \begin{vmatrix}
    \boldsymbol w_1 &amp;\boldsymbol w_2 &amp;\boldsymbol w_3 \\
    \boldsymbol u_1 &amp;\boldsymbol u_2 &amp;\boldsymbol u_3 \\
    \boldsymbol v_1 &amp;\boldsymbol v_2 &amp;\boldsymbol v_3 \\    
\end{vmatrix}
\]</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ma-chengyuan.github.io/2021/04/29/Four%20Spaces/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/29/Four%20Spaces/" class="post-title-link" itemprop="url">线性代数四大空间笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-29 21:05:06" itemprop="dateCreated datePublished" datetime="2021-04-29T21:05:06-04:00">2021-04-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>以下是读Gilbert Strang的<em>Introduction to Linear Algebra</em>的后回忆整理的笔记。内容大概包括第三节和第四节开头的一部分。</p>
<h1 id="四大空间">四大空间</h1>
<p>对于矩阵<span class="math inline">\(A\in \mathbb{R}^{m\times n}\)</span>，定义</p>
<ol type="1">
<li><span class="math inline">\(A\)</span>的列空间为其所有列向量的张成空间，<span class="math inline">\(A\)</span>的列向量的线性组合记作<span class="math inline">\(A\boldsymbol{x}=\boldsymbol b\)</span>——因此所有这个形式的<span class="math inline">\(\boldsymbol b\)</span>都属于<span class="math inline">\(A\)</span>的列空间。记作<span class="math inline">\(C(A)\)</span>。<span class="math inline">\(C(A)\subset\mathbb{R}^m\)</span>。</li>
<li><span class="math inline">\(A\)</span>的零空间为令其列向量线性组合为零的组合构成的空间，即所有满足<span class="math inline">\(A\boldsymbol{x}=\boldsymbol 0\)</span>的向量<span class="math inline">\(\boldsymbol x\)</span>。记作<span class="math inline">\(N(A)\)</span>。<span class="math inline">\(N(A)\subset \mathbb{R}^n\)</span>。</li>
<li><span class="math inline">\(A\)</span>的行空间为其所有行向量的张成空间。因为<span class="math inline">\(A\)</span>的行向量都是<span class="math inline">\(A^{\mathrm{T}}\)</span>的列空间，所以行空间可以记作<span class="math inline">\(C\left(A^{\mathrm T}\right)\)</span>。<span class="math inline">\(C\left(A^{\mathrm T}\right) \subset \mathbb{R}^{n}\)</span>。</li>
<li><span class="math inline">\(A\)</span>的左零空间为令其行向量线性组合为零的组合构成的空间，即所有满足<span class="math inline">\(\boldsymbol{x}^{\mathrm T}A = \boldsymbol 0^{\mathrm T}\)</span>的向量<span class="math inline">\(\boldsymbol{x}\)</span>，现在<span class="math inline">\(\boldsymbol x\)</span>在左边，所以和零空间相比就叫左零空间了。左零空间自然可以记作<span class="math inline">\(C\left(A^{\mathrm T}\right)\)</span>。<span class="math inline">\(C\left(A^{\mathrm T}\right) \subset \mathbb{R}^{m}\)</span>。</li>
</ol>
<p>以上就是线性代数当中比较重要的四个空间。虽然有四个，但本质只有“列空间”和“零空间”两种。基于矩阵的定义是颇有些枯燥的。矩阵只是线性变换比较常用且典型的形式，列空间和零空间的定义并不局限于此。归根结底，<strong>列空间是线性变换的“值域”，零空间是线性变换的“零点”</strong>。</p>
<p><sub>注：列空间在一些地方也叫做像空间（image），零空间在一些地方也叫做核（kernel）。个人认为，对于一般的线性变换，像空间的称谓比列空间更为恰当，但kernel这个词就有些莫名奇妙——我没有了解过相关的背景，但我觉得零空间的叫法更为直观。</sub></p>
<h1 id="向量空间的维度">向量空间的维度</h1>
<p>向量空间的维度定义为这个空间任何一组基包含的向量个数。这个定义蕴含的一个事实是：对于同一个向量空间，无论其基如何选取，其大小都是相同的。这里摘录一个书上的证明：</p>
<p><strong>证明：</strong> 假设向量空间<span class="math inline">\(\mathbf V\)</span>的两组基为<span class="math inline">\(\boldsymbol{v_1},\boldsymbol{v_2},\cdots,\boldsymbol{v_n}\)</span>和<span class="math inline">\(\boldsymbol{w_1}, \boldsymbol{w_2}, \cdots ,\boldsymbol{w_m}\)</span>。运用反证法，不失一般性，设<span class="math inline">\(n &lt; m\)</span>。因为<span class="math inline">\(\boldsymbol{v_1},\boldsymbol{v_2},\cdots,\boldsymbol{v_n}\)</span>是基，所以任意<span class="math inline">\(\boldsymbol{w_k}\)</span>都可以用他们的线性组合表示。即 <span class="math display">\[
\boldsymbol{w_k} = \begin{bmatrix}
    \boldsymbol{v_1} &amp;\boldsymbol{v_2} &amp;\cdots &amp;\boldsymbol{v_n}  
\end{bmatrix}\cdot \boldsymbol{a}
\]</span> （回忆一下，矩阵左乘向量等于按照向量的系数对矩阵的列向量进行线性组合）</p>
<p>进一步地， <span class="math display">\[
\begin{bmatrix}
    \boldsymbol{w_1} &amp;\boldsymbol{w_2} &amp;\cdots &amp;\boldsymbol{w_m}  
\end{bmatrix}= 
\begin{bmatrix}
    \boldsymbol{v_1} &amp;\boldsymbol{v_2} &amp;\cdots &amp;\boldsymbol{v_n}  
\end{bmatrix}\cdot A
\]</span> 不难发现，<span class="math inline">\(A\)</span>是<span class="math inline">\(n\)</span>行<span class="math inline">\(m\)</span>列的矩阵，而<span class="math inline">\(n &lt; m\)</span>，所以<span class="math inline">\(A\)</span>是扁的。在代数上，齐次线性方程组的变量多于方程数，也就是说<span class="math inline">\(A\boldsymbol{x} = \boldsymbol{0}\)</span>有非平凡解。 <span class="math display">\[
\begin{aligned}
    A\boldsymbol{x} &amp;= \boldsymbol{0} \\
    \Rightarrow \begin{bmatrix}
    \boldsymbol{v_1} &amp;\boldsymbol{v_2} &amp;\cdots &amp;\boldsymbol{v_n}  
\end{bmatrix} A\boldsymbol{x} &amp;= \boldsymbol{0} \\
    \Rightarrow \begin{bmatrix}
    \boldsymbol{w_1} &amp;\boldsymbol{w_2} &amp;\cdots &amp;\boldsymbol{w_m}  
\end{bmatrix} \boldsymbol{x} &amp;= \boldsymbol{0}
\end{aligned}
\]</span> 也就是说，<span class="math inline">\(\boldsymbol{w_1}, \boldsymbol{w_2}, \cdots ,\boldsymbol{w_m}\)</span>线性相关，推出矛盾，证毕。</p>
<h1 id="四大空间的维度">四大空间的维度</h1>
<p>一个矩阵四大空间的维度可以通过将其化简为行简化阶梯型（reduced row echelon form）来计算。行简化阶梯型的定义</p>
<ol type="1">
<li>阶梯型/上三角型矩阵</li>
<li>主元位置都是<span class="math inline">\(1\)</span></li>
<li>主元正上方都是<span class="math inline">\(0\)</span></li>
</ol>
<p>例如 <span class="math display">\[
\operatorname{rref}\left(
\begin{bmatrix}
    1 &amp;1 &amp;2 &amp;4\\
    1 &amp;2 &amp;2 &amp;5\\
    1 &amp;3 &amp;2 &amp;6
\end{bmatrix}
\right)
=
\begin{bmatrix}
    1 &amp;0 &amp;2 &amp;3\\
    0 &amp;1 &amp;0 &amp;1\\
    0 &amp;0 &amp;0 &amp;0
\end{bmatrix}
\]</span> 行简化阶梯型矩阵可以通过原矩阵的初等行变换得到（高斯消元）。</p>
<p>行简化阶梯型矩阵当中主元的个数称为矩阵的<strong>秩</strong>（rank）。我们首先注意到，对于一个行简化阶梯型矩阵<span class="math inline">\(A\)</span>，</p>
<ol type="1">
<li><strong>它列空间的维度是它的秩</strong>：主元列显然是线性无关的，而非主元列显然可以用主元列的线性组合表示（系数就写在列里面呢，比如说在上面的例子中，第四列是第一列的<span class="math inline">\(3\)</span>倍和第二列的<span class="math inline">\(1\)</span>倍之和）。</li>
<li><strong>它行空间的维度也是它的秩</strong>：行简化阶梯型的形态让我们不难发现每一个非零行都是线性无关的。原因在于每个非零行都包含一个主元，而只有那一行在主元的那一列是<span class="math inline">\(1\)</span>。</li>
<li><strong>它零空间的维度是列数与秩之差</strong>，即非主元列的个数：从方程<span class="math inline">\(A\boldsymbol x = \boldsymbol 0\)</span>的角度看，非主元列代表自由变量。通过令一个自由变量为<span class="math inline">\(1\)</span>，令其余自由变量为<span class="math inline">\(0\)</span>，并依此计算主元，我们可以得到和自由变量同样数目的若干“解向量”。这些解向量线性无关，都处在零空间中，且张成整个零空间，因此是零空间的一个基。</li>
<li><strong>它左零空间的维度是行数与秩之差</strong>，即零行的个数：非零行线性无关，因此要使行的线性组合为零所有非零行的系数必须为零，零行的系数任意，因此左零空间的维度就是零行的个数。</li>
</ol>
<p>接下来，我们观察到<strong>从一般矩阵化简为行简化阶梯型的过程不会改变矩阵的四个空间的维度</strong>：</p>
<ol type="1">
<li>初等行变换不会改变列向量之间的线性关系——对于所有列来说，行变换是“一荣俱荣，一损俱损”的。如果原来矩阵的第三列是第一列的两倍，那么行变换之后第三列还是第一列的两倍。如果原来矩阵的第二列是第一列和第三列的和，那么行变换之后这个和的关系不变。</li>
<li>因为列向量之间的线性关系没有变，所以零空间不会变，列空间的维数也不会变（但列空间本身会变）。</li>
<li>行变换是对行的线性组合，所以行简化阶梯型的行空间是原矩阵行空间的子集；而高斯消元的行变换是可逆的，所以原矩阵的行空间也是行简化阶梯型行空间的子集。因此，化简到行简化阶梯型的过程当中，行空间不变。</li>
<li>行简化阶梯型只是揭示而并非改变行向量之间的线性相关关系（行简化阶梯型中的零行表示原来的行向量和上面几行的行向量线性相关）。原来线性无关的行不会因为行变换就线性相关，反之亦然。因此左零空间的维数是不会变的。</li>
</ol>
<p>所以，一般矩阵的秩也就可以定义为其对应行简化阶梯形矩阵的秩，一般矩阵的四大空间的维度也可以用其秩计算了。</p>
<h1 id="四大空间维度的奇妙关联">四大空间维度的奇妙关联</h1>
<p>简要地总结一下，对于一个<span class="math inline">\(m\)</span>行<span class="math inline">\(n\)</span>列秩<span class="math inline">\(r\)</span>的矩阵<span class="math inline">\(A\)</span>，有</p>
<ol type="1">
<li><span class="math inline">\(\dim\left(C(A)\right) = r\)</span></li>
<li><span class="math inline">\(\dim\left(N(A)\right) = n - r\)</span></li>
<li><span class="math inline">\(\dim\left(C\left(A^{\mathrm T}\right)\right) = r\)</span></li>
<li><span class="math inline">\(\dim\left(N\left(A^{\mathrm T}\right)\right) = m - r\)</span></li>
</ol>
<p>然后我们整理一下就发现 <span class="math display">\[
\begin{aligned}
    \dim\left(C(A)\right) + \dim\left(N(A)\right) &amp;= n = \dim\left(\mathbb{R}^n\right) \\
    \dim\left(C\left(A^{\mathrm T}\right)\right) + \dim\left(N\left(A^{\mathrm T}\right)\right) &amp;= m = \dim\left(\mathbb{R}^m\right)
\end{aligned}
\]</span> 有什么意义？注意到<span class="math inline">\(A\)</span>可以看作一个线性变换，其定义域所在的空间是<span class="math inline">\(\mathbb{R}^n\)</span>。<span class="math inline">\(A^{\mathrm T}\)</span>也是如此。结合零空间和列空间的意义，我们发现了这样一个关系：</p>
<p><strong>线性变换定义域（输入）的维度，等于零空间与值域（输出）维度之和。</strong></p>
<p>好理解不？一个输入的部分维度在线性变换中“卷入零空间”消失了，只有剩下的维度反映在输出中。</p>
<p>高屋建瓴，妙不可言。这个关系具有震撼人心的力量。自己前几天在学校阅览室读到这一行，差点拍案叫绝。</p>
<p>线性代数是简洁的。</p>
<p>线性代数是优美的。</p>
<p>莫不如是。</p>
<p>这有啥用处？</p>
<p>书后有一个习题</p>
<blockquote>
<p>定义两个子向量空间<span class="math inline">\(\mathbf{V}\)</span>和<span class="math inline">\(\mathbf W\)</span>的和<span class="math inline">\(\mathbf{V} + \mathbf{W}\)</span>为二者中任意向量组合形成的空间（即二者基的并的张成空间）。</p>
<p>求证： <span class="math display">\[
\dim(\mathbf V) + \dim(\mathbf W) = \dim(\mathbf V + \mathbf W) + \dim(\mathbf V \cap \mathbf W)
\]</span></p>
</blockquote>
<p>朴素的做法设出两向量空间交的基，然后在此基础上分别拓展形成<span class="math inline">\(\mathbf V\)</span>，<span class="math inline">\(\mathbf W\)</span>，然后再证明这些分别拓展的基和两空间交的基一起是线性无关的。步骤倒也不是特别复杂。</p>
<p>但是格局低了。</p>
<p>Mike Artin提出的证明是这样的：考虑二元运算<span class="math inline">\(+\)</span>把二元组 <span class="math inline">\((\boldsymbol v\in \mathbf V, \boldsymbol w\in \mathbf W)\)</span>变换到<span class="math inline">\(\boldsymbol v + \boldsymbol w\)</span>。易证这个变换是线性的。其输入维度是<span class="math inline">\(\dim(\mathbf V) + \dim(\mathbf W)\)</span>。其值域的维度是<span class="math inline">\(\dim(\mathbf V + \mathbf W)\)</span>。其零空间是<span class="math inline">\((\boldsymbol v, \boldsymbol -v)\)</span>其中<span class="math inline">\(v\in \mathbf V \cap \mathbf W\)</span>，维度自然是<span class="math inline">\(\dim(\mathbf V \cap \mathbf W)\)</span>。因为线性变换输入的维度等于输出的维度与零空间维度之和，得证。</p>
<p><img src="/2021/04/29/Four%20Spaces/v2-d3a9348b3a938c79f5998c5bc40a1d82_hd.webp" class=""></p>
<p>太高了，我恐高症都犯了。</p>
<h1 id="四大空间的正交性">四大空间的正交性</h1>
<p>还有一点很妙的是：<strong>四大空间是两两正交的</strong>！</p>
<p>什么是正交？两个子向量空间正交当且仅当两个空间中的任意两个向量都互相垂直。（说“子向量空间”是因为两个向量谈论垂直不垂直的前提条件自然是两个向量维数一样，即同属于一个更大的向量空间）</p>
<ol type="1">
<li><p>在<span class="math inline">\(\mathbb R^n\)</span>内，零空间<span class="math inline">\(N(A)\)</span>和行空间<span class="math inline">\(C\left(A^{\mathrm T}\right)\)</span>互相正交 <span class="math display">\[
\forall A^{\mathrm T}\boldsymbol x \in C\left(A^{\mathrm T}\right),\boldsymbol y \in N(A),\quad \left(A^{\mathrm T}\boldsymbol x\right)^{\mathrm T}\boldsymbol y = \boldsymbol{x}^{\mathrm T}A\boldsymbol y = \boldsymbol{x}^{\mathrm T}\cdot \boldsymbol 0 = 0
\]</span> 又因为二者维度之和为<span class="math inline">\(n\)</span>，所以二者互补，即<span class="math inline">\(N(A) + C\left(A^{\mathrm T}\right) = \mathbb{R}^n\)</span>。</p></li>
<li><p>在<span class="math inline">\(\mathbb R^m\)</span>内，列空间<span class="math inline">\(C(A)\)</span>和左零空间<span class="math inline">\(N\left(A^{\mathrm T}\right)\)</span>互相正交 <span class="math display">\[
\forall A\boldsymbol x \in C(A),\boldsymbol y \in N\left(A^{\mathrm T}\right),\quad \left(A\boldsymbol x\right)^{\mathrm T}\boldsymbol y = \boldsymbol{x}^{\mathrm T}A^{\mathrm T}\boldsymbol y = \boldsymbol{x}^{\mathrm T}\cdot \boldsymbol 0 = 0
\]</span> 又因为二者维度之和为<span class="math inline">\(m\)</span>，所以二者互补，即<span class="math inline">\(C(A)+ N\left(A^{\mathrm T}\right) = \mathbb{R}^m\)</span>。</p></li>
</ol>
<p>于是就可以祭出Introduction to Linear Algebra 封面上的神图<del>手绘重制以表敬意</del></p>
<p><img src="/2021/04/29/Four%20Spaces/image-20210417155102490.png" class=""></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ma-chengyuan.github.io/2021/04/29/Projection%20and%20Least%20Square/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/29/Projection%20and%20Least%20Square/" class="post-title-link" itemprop="url">投影、最小二乘拟合与QR分解笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-29 21:01:42" itemprop="dateCreated datePublished" datetime="2021-04-29T21:01:42-04:00">2021-04-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="投影">投影</h1>
<p>高中的时候就学过，向量<span class="math inline">\(\boldsymbol b\)</span>在<span class="math inline">\(\boldsymbol a\)</span>上的投影为 <span class="math display">\[
\boldsymbol p = \frac{\boldsymbol a^{\mathrm T}\boldsymbol b}{\boldsymbol a^{\mathrm T}\boldsymbol a} \cdot \boldsymbol a
\]</span> 当时推导主要利用了点积的几何意义$a b = |a||b|$。在代数意义上上式是怎么推导的呢？</p>
<p>其实也不难：注意到<span class="math inline">\(\boldsymbol b\)</span>和其投影<span class="math inline">\(\boldsymbol p\)</span>的差一定是垂直于基向量<span class="math inline">\(\boldsymbol a\)</span>的。因为<span class="math inline">\(\boldsymbol p\)</span>与<span class="math inline">\(\boldsymbol a\)</span>平行，设<span class="math inline">\(\boldsymbol p = x\boldsymbol a\)</span> <span class="math display">\[
\begin{aligned}
    \boldsymbol a^{\mathrm T}\left(\boldsymbol b - x\boldsymbol a\right) &amp;= 0 \\
    \Rightarrow \boldsymbol a^{\mathrm T}x\boldsymbol a &amp;= \boldsymbol a^{\mathrm T}\boldsymbol b \\
    \Rightarrow x\boldsymbol a^{\mathrm T}\boldsymbol a &amp;= \boldsymbol a^{\mathrm T}\boldsymbol b \\
    \Rightarrow x &amp;= \frac{\boldsymbol a^{\mathrm T}\boldsymbol b}{\boldsymbol a^{\mathrm T}\boldsymbol a}
\end{aligned}
\]</span> 我们就得到了一开始的结论。如果把<span class="math inline">\(\boldsymbol a\)</span>写到左边（因为是向量的实数积所以可以交换） <span class="math display">\[
p = \boldsymbol a\cdot \frac{\boldsymbol a^{\mathrm T}\boldsymbol b}{\boldsymbol a^{\mathrm T}\boldsymbol a} = \frac{\boldsymbol a\boldsymbol a^{\mathrm T}}{\boldsymbol a^{\mathrm T}\boldsymbol a}\boldsymbol b
\]</span> 我们这下看清楚了：将<span class="math inline">\(\boldsymbol b\)</span>转变为其在<span class="math inline">\(\boldsymbol a\)</span>上的投影的是一个矩阵！这个矩阵<span class="math inline">\(P = \frac{\boldsymbol a\boldsymbol a^{\mathrm T}}{\boldsymbol a^{\mathrm T}\boldsymbol a}\)</span>被称为<strong>投影矩阵</strong>。</p>
<p>代数推导和投影矩阵有啥用？它们可以让我们把投影从投影到一个向量推广到投影到向量空间。</p>
<p>考虑如何把一个向量<span class="math inline">\(\boldsymbol b\)</span>投影到矩阵<span class="math inline">\(A = \begin{bmatrix} \boldsymbol {a_1} &amp;\boldsymbol {a_2} &amp;\cdots &amp;\boldsymbol {a_n}\end{bmatrix}\)</span>的列空间上（假设<span class="math inline">\(A\)</span>的列向量线性无关）。我们一样考虑<span class="math inline">\(\boldsymbol b\)</span>与<span class="math inline">\(\boldsymbol p\)</span>的差，其一定垂直于<span class="math inline">\(C(A)\)</span>，自然也垂直于<span class="math inline">\(\boldsymbol {a_1} \cdots \boldsymbol {a_n}\)</span>，于是就有： <span class="math display">\[
\boldsymbol {a_k} ^{\mathrm T}\left(\boldsymbol b - \boldsymbol p\right) = 0, \quad k = 1,2,\cdots,n
\]</span> 或者写在一起： <span class="math display">\[
\begin{bmatrix}
    \boldsymbol {a_1}^{\mathrm T} \\
    \boldsymbol {a_2}^{\mathrm T} \\
    \vdots \\
    \boldsymbol {a_n}^{\mathrm T} \\
\end{bmatrix}
\left(\boldsymbol b  - \boldsymbol p\right) = \boldsymbol 0 \Rightarrow 
A^{\mathrm T} \left(\boldsymbol b  - \boldsymbol p\right) = \boldsymbol 0
\]</span> 因为<span class="math inline">\(\boldsymbol p \in C(A)\)</span>，所以<span class="math inline">\(\boldsymbol p\)</span>是<span class="math inline">\(A\)</span>列向量的线性组合，可以写作<span class="math inline">\(\boldsymbol p = A\boldsymbol x\)</span>。于是我们就得到了方程 <span class="math display">\[
A^{\mathrm T} \left(\boldsymbol b  - A\boldsymbol x\right) = \boldsymbol 0 \Rightarrow A^{\mathrm T}A\boldsymbol x = A^{\mathrm T}\boldsymbol b
\]</span> 因为<span class="math inline">\(A\)</span>的列是线性无关的，所以<span class="math inline">\(A^{\mathrm T}A\)</span>是可逆的（这个我们待会证明），于是我们可以解得 <span class="math display">\[
\boldsymbol x = \left(A^{\mathrm T}A\right)^{-1}A^{\mathrm T}\boldsymbol b
\]</span> 即 <span class="math display">\[
\boldsymbol p = A\left(A^{\mathrm T}A\right)^{-1}A^{\mathrm T}\boldsymbol b
\]</span> 此时我们很清楚地看到，投影矩阵是<span class="math inline">\(P = A\left(A^{\mathrm T}A\right)^{-1}A^{\mathrm T}\)</span>。</p>
<hr />
<p>我们接下来证明之前我们用到的一个结论：<strong><span class="math inline">\(A^{\mathrm T}A\)</span>可逆的充分必要条件是<span class="math inline">\(A\)</span>的列向量线性无关</strong>。</p>
<p>我们发现这个结论等价于：<span class="math inline">\(A^{\mathrm T}A\)</span>和<span class="math inline">\(A\)</span>有相同的零空间。</p>
<p>怎么证明？一个方向是简单的： <span class="math display">\[
A\boldsymbol x = \boldsymbol 0 \Rightarrow A^{\mathrm T}\left(A\boldsymbol x\right) = \boldsymbol 0 \Rightarrow A^{\mathrm T} A\boldsymbol x = \boldsymbol 0
\]</span> 反方向的证明需要一些技巧： <span class="math display">\[
A^{\mathrm T} A\boldsymbol x = \boldsymbol 0 \Rightarrow \boldsymbol x^{\mathrm T} A^{\mathrm T} A\boldsymbol x = 0 \Rightarrow \left(A\boldsymbol x\right)^{\mathrm T}A\boldsymbol x = 0 \Rightarrow A\boldsymbol x = \boldsymbol 0
\]</span> 倒数第二步写得有点花里胡哨其实就是向量自己和自己的点积，如果是零的话显然原向量就是零。</p>
<p>证毕。</p>
<h1 id="最小二乘拟合">最小二乘拟合</h1>
<p>投影和最小二乘拟合是怎么联系起来的呢？</p>
<p>线性拟合的本质是用给定的若干列向量的线性组合表示另一个向量。</p>
<p>比如我有一组数据<span class="math inline">\(\boldsymbol x,\boldsymbol y\)</span>，我的模型是<span class="math inline">\(y = a + bx\)</span>，拟合的过程就是用向量<span class="math inline">\(\boldsymbol 1\)</span>和<span class="math inline">\(\boldsymbol x\)</span>的线性组合表示<span class="math inline">\(\boldsymbol y\)</span>的过程： <span class="math display">\[
\begin{bmatrix}
    1 &amp;x_1 \\
    1 &amp;x_2  \\
    \vdots &amp;\vdots\\
    1 &amp;x_n 
\end{bmatrix}
\begin{bmatrix}
    a \\
    b
\end{bmatrix} \stackrel{?}{=} 
\begin{bmatrix}
    y_1 \\
    y_2 \\
    \vdots \\
    y_n 
\end{bmatrix}
\]</span> “线性拟合”的线性指的是这种组合的线性，和模型本身的线性是没有关系的。模型里面有二次项不要紧，只要二次项和其他项是线性组合的，那也不过是在左边的矩阵里多了一个列向量而已： <span class="math display">\[
\begin{bmatrix}
    1 &amp;x_1 &amp;x_1^2 \\
    1 &amp;x_2 &amp;x_2^2 \\
    \vdots &amp;\vdots &amp;\vdots \\
    1 &amp;x_n &amp;x_n^2
\end{bmatrix}
\begin{bmatrix}
    a \\
    b \\
    c
\end{bmatrix} \stackrel{?}{=} 
\begin{bmatrix}
    y_1 \\
    y_2 \\
    \vdots \\
    y_n 
\end{bmatrix}
\]</span> 那么我们发现线性拟合的本质其实就是解一个形如<span class="math inline">\(A\boldsymbol x = \boldsymbol b\)</span>的方程组（这里的<span class="math inline">\(\boldsymbol x\)</span>表示模型中各项的系数，和上面表示自变量的<span class="math inline">\(\boldsymbol x\)</span>没有关系），这个我们老熟悉了。</p>
<p>但是事情不太妙的就是<span class="math inline">\(A\)</span>又高又瘦，方程组比未知数多，所以几乎肯定不存在准确解。</p>
<p>什么时候存在准确解？<span class="math inline">\(\boldsymbol b\)</span>要在<span class="math inline">\(A\)</span>的列空间<span class="math inline">\(C(A)\)</span>里。</p>
<p>所以如果只能求近似解，我们可以考虑把<span class="math inline">\(\boldsymbol b\)</span>“近似到”<span class="math inline">\(C(A)\)</span>中的一个最近的向量，然后就能求解了。</p>
<p>这个“近似”的过程其实就是投影。在<span class="math inline">\(C(A)\)</span>中<span class="math inline">\(\boldsymbol b\)</span>的投影肯定最接近<span class="math inline">\(\boldsymbol b\)</span>，因为只有二者的差是和<span class="math inline">\(C(A)\)</span>垂直的，这很符合我们的代数直觉。</p>
<p>所以联系之前的投影的推导，假设这个投影向量是<span class="math inline">\(A\boldsymbol{\hat{x}}\)</span>，我们直接写出方程和解： <span class="math display">\[
A^{\mathrm T} \left(\boldsymbol b  - A\boldsymbol{\hat{x}} \right) = \boldsymbol 0 \Rightarrow \boldsymbol{\hat{x}} = \left(A^{\mathrm T}A\right)^{-1}A^{\mathrm T}\boldsymbol b
\]</span> 这就叫“最小二乘拟合”。</p>
<hr />
<p>如果非要较真，从微积分的角度理解一波也是可以的：定义拟合的误差函数为 <span class="math display">\[
L= \left|\boldsymbol b - A\boldsymbol{\hat x}\right| = \sum_{i = 1}^n \left(\boldsymbol b_i - \left(A\boldsymbol{\hat x}\right)_i\right)^2
\]</span> 如果要最小化<span class="math inline">\(L\)</span>，那么<span class="math inline">\(L\)</span>关于<span class="math inline">\(\boldsymbol{\hat x}\)</span>的所有分量的导数都为<span class="math inline">\(0\)</span>： <span class="math display">\[
\frac{\mathrm d L}{\mathrm d\boldsymbol{\hat x}_k} = 2\sum_{i = 1}^n A_{i, k} \left(\left(A\boldsymbol{\hat x}\right)_i - \boldsymbol b_i\right) =  0, \quad \forall k = 1, 2, \cdots, n
\]</span> 令<span class="math inline">\(A\)</span>第<span class="math inline">\(i\)</span>列的列向量为<span class="math inline">\(\boldsymbol a_i\)</span>，那么上面也可以写成 <span class="math display">\[
\frac{\mathrm d L}{\mathrm d\boldsymbol{\hat x}_k} = 2\boldsymbol a_k^{\mathrm T} \left(A\boldsymbol{\hat x} - \boldsymbol b\right) =  0, \quad \forall k = 1, 2, \cdots, n
\]</span> 并在一起得 <span class="math display">\[
2A^{\mathrm T}\left(A\boldsymbol{\hat x} - \boldsymbol b\right) =  0
\]</span> 这就是上面我们通过投影推出的方程。</p>
<p><span class="math inline">\(L\)</span>中的平方项也是最小二乘中“二”的由来。</p>
<h1 id="矩阵的gram-schmidt正交化">矩阵的Gram-Schmidt正交化</h1>
<p>我们发现无论是投影还是最小二乘拟合，计算<span class="math inline">\(A^{\mathrm T}A\)</span>和它的逆都是绕不过去的一步。<span class="math inline">\(A^{\mathrm T}A\)</span>本身就有一些特殊的性质，比如说其一定是正方阵，一定是对称的（通过转置等于自身易证）。但是这些性质在计算的时候帮助不大。如果我们能够优化<span class="math inline">\(A\)</span>的形态从而简化<span class="math inline">\(A^{\mathrm T}A\)</span>和它的逆的计算，那么各种算法的效率都会高上不少。</p>
<p>注意到<span class="math inline">\(A^{\mathrm T}A\)</span>中的每一个位置都是<span class="math inline">\(A\)</span>两个列向量的点积。<strong>如果<span class="math inline">\(A\)</span>当中的列向量是两两正交的，那么<span class="math inline">\(A^{\mathrm T}A\)</span>就变成了一个对角阵。对角阵的逆不要太好算！更进一步，如果<span class="math inline">\(A\)</span>的每一个列向量都是单位向量，那么<span class="math inline">\(A^{\mathrm T}A\)</span>就是单位阵，连逆都不用求了</strong>！</p>
<p>所以说啊，正交是个好东西。那对于一个矩阵<span class="math inline">\(A\)</span>，通过什么样的方式将其列向量完成正交化呢？</p>
<p>比较简单的一个算法称为Gram-Schmidt正交化。设<span class="math inline">\(A\)</span>的列向量为<span class="math inline">\(\boldsymbol {a_1},\cdots, \boldsymbol{a_n}\)</span>，则向量正交化之后的结果<span class="math inline">\(\boldsymbol{q_i}\)</span>可以这么计算： <span class="math display">\[
\boldsymbol{q_i} = \boldsymbol{a_i} - \sum_{j = 1}^{i - 1} \frac{\boldsymbol{q_j}^{\mathrm T}\boldsymbol{a_i}}{\boldsymbol{q_j}^{\mathrm T}\boldsymbol{q_j}} \boldsymbol{q_j}
\]</span> 即对于第<span class="math inline">\(i\)</span>个列向量通过减去其在所有之前的（完成正交化的）向量上的投影来确保其和前面的向量都正交。</p>
<p>最后，把所有的<span class="math inline">\(\boldsymbol{q_i}\)</span>除以其模完成归一化，我们就可以得到一个标准正交列向量组成的矩阵<span class="math inline">\(Q\)</span>，满足<span class="math inline">\(Q^{\mathrm T}Q = I\)</span>。（线性代数中常使用<span class="math inline">\(Q\)</span>表示列向量标准正交的矩阵）</p>
<p>从<span class="math inline">\(A\)</span>变到<span class="math inline">\(Q\)</span>的过程没有改变列空间，所以不会改变投影矩阵，但计算投影矩阵的开销大大降低了： <span class="math display">\[
P = Q\left(Q^{\mathrm T}Q\right)^{-1}Q^{\mathrm T} = QQ^{\mathrm T}
\]</span></p>
<h1 id="qr分解">QR分解</h1>
<p>Gram-Schmidt正交化的过程可以看作是在原矩阵上进行列变换，而列变换是可以用矩阵表示的。类比从高斯消元导出LU分解的思路，我们可以从Gram-Schimidt正交化导出一个矩阵的QR分解： <span class="math display">\[
A = QR
\]</span> 我们有<span class="math inline">\(A\)</span>，可以通过Gram-Schmidt正交化算出<span class="math inline">\(Q\)</span>，但<span class="math inline">\(R\)</span>怎么计算呢？因为<span class="math inline">\(Q^{\mathrm T}Q=I\)</span>，所以只要在等式两边同时乘以<span class="math inline">\(Q^{\mathrm T}\)</span>，就得到<span class="math inline">\(R=Q^{\mathrm T}A\)</span>。或者用<span class="math inline">\(Q\)</span>和<span class="math inline">\(A\)</span>的列向量表示： <span class="math display">\[
R = \begin{bmatrix}
    \boldsymbol{q_1}^{\mathrm T} \\
    \boldsymbol{q_2}^{\mathrm T} \\
    \vdots \\
    \boldsymbol{q_n}^{\mathrm T}
\end{bmatrix}
\begin{bmatrix}
    \boldsymbol{a_1} &amp;\boldsymbol{a_2} &amp;\cdots &amp;\boldsymbol{a_n}
\end{bmatrix}
= \begin{bmatrix}
    \boldsymbol{q_1}^{\mathrm T}\boldsymbol{a_1} &amp;\boldsymbol{q_1}^{\mathrm T}\boldsymbol{a_2} &amp;\cdots &amp;\boldsymbol{q_1}^{\mathrm T}\boldsymbol{a_n} \\
    \boldsymbol{q_2}^{\mathrm T}\boldsymbol{a_1} &amp;\boldsymbol{q_2}^{\mathrm T}\boldsymbol{a_2} &amp;\cdots &amp;\boldsymbol{q_2}^{\mathrm T}\boldsymbol{a_n} \\
    \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\
    \boldsymbol{q_n}^{\mathrm T}\boldsymbol{a_1} &amp;\boldsymbol{q_n}^{\mathrm T}\boldsymbol{a_2} &amp;\cdots &amp;\boldsymbol{q_n}^{\mathrm T}\boldsymbol{a_n}
\end{bmatrix}
\]</span> 注意到，因为<span class="math inline">\(\boldsymbol{q_i}\)</span>正交于所有<span class="math inline">\(\boldsymbol {q_j}(i &lt; j)\)</span>，而<span class="math inline">\(\boldsymbol{a_j}\)</span>又是由<span class="math inline">\(\boldsymbol{q_1},\cdots,\boldsymbol{q_j}\)</span>表示的，所以<span class="math inline">\(i &gt; j\)</span>时，<span class="math inline">\(\boldsymbol{q_i}^{\mathrm T}\boldsymbol{a_j} = 0\)</span>。所以<span class="math inline">\(R\)</span><strong>其实是一个上三角阵</strong>： <span class="math display">\[
R = \begin{bmatrix}
    \boldsymbol{q_1}^{\mathrm T}\boldsymbol{a_1} &amp;\boldsymbol{q_1}^{\mathrm T}\boldsymbol{a_2} &amp;\cdots &amp;\boldsymbol{q_1}^{\mathrm T}\boldsymbol{a_n} \\
    0 &amp;\boldsymbol{q_2}^{\mathrm T}\boldsymbol{a_2} &amp;\cdots &amp;\boldsymbol{q_2}^{\mathrm T}\boldsymbol{a_n} \\
    \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\
    0 &amp;0 &amp;\cdots &amp;\boldsymbol{q_n}^{\mathrm T}\boldsymbol{a_n}
\end{bmatrix}
\]</span> 再观察<span class="math inline">\(R\)</span>的各个非零位置的值以及Gram-Schimidt的公式，其实<span class="math inline">\(R\)</span>是可以在计算Gram-Schmidt正交化的时候顺便算出来的。</p>
<p>QR分解有什么用呢？之前我们说正交化不改变投影矩阵，原因是“正交化不改变列空间”，QR分解能让我们在代数上证明这一点： <span class="math display">\[
\begin{aligned}
    P &amp;= A\left(A^{\mathrm T}A\right)^{-1}A^{\mathrm T} \\
    &amp;= QR\left(R^{\mathrm T}Q^{\mathrm T}QR\right)^{-1}R^{\mathrm T}Q^{\mathrm T} \\
    &amp;= QR\left(R^{\mathrm T}R\right)^{-1}R^{\mathrm T}Q^{\mathrm T} \\
    &amp;= QRR^{-1}\left(R^{\mathrm T}\right)^{-1}R^{\mathrm T}Q^{\mathrm T} \\
    &amp;= QQ^{\mathrm T}
\end{aligned}
\]</span> 注：因为<span class="math inline">\(R\)</span>是一个方阵，所以我们这里能够把<span class="math inline">\(\left(R^{\mathrm T}R\right)^{-1}\)</span>改写成<span class="math inline">\(R^{-1}(R^{\mathrm T})^{-1}\)</span>。<span class="math inline">\(\left(A^{\mathrm T}A\right)^{-1}\)</span>是不能这么转换的，因为长方阵不存在常规意义上的逆。</p>
<p>类似地，QR分解还简化了最小二乘拟合的计算： <span class="math display">\[
\boldsymbol{\hat{x}} = \left(A^{\mathrm T}A\right)^{-1}A^{\mathrm T}\boldsymbol b = R^{-1}Q^{\mathrm T}\boldsymbol b
\]</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ma-chengyuan.github.io/2021/04/26/%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E8%BF%B7%E6%80%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/26/%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E8%BF%B7%E6%80%9D/" class="post-title-link" itemprop="url">中文编程迷思</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-26 23:43:58" itemprop="dateCreated datePublished" datetime="2021-04-26T23:43:58-04:00">2021-04-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>又一次在网上看到中文编程的日经贴后，我觉得这似乎会是一个不错的博文题目。</p>
<p>这篇文章我计划讲的内容在标题里写得很明白——“迷思”。</p>
<p>迷思，经常被用作英文myth的音译，衍生出“神话”、“传言”的意项。在这个定义下，“中文编程”或许可以称得上是一个迷思了，初学编程的萌新和温饱思扯淡的键盘程序语言设计家（我或许可以忝列后者）一天到晚在讲，Github上偶尔有个小项目也会有不少的曝光率，但是也就止步于笑谈中了，现实的应用几乎没有（唯一勉强成气候的易语言常年处于鄙视链的最低端）。这样一种现状，似乎和动漫当中的“都市传说”颇有共同点。可是动漫的“都市传说”最后都是真的，“中文编程”则未必然。</p>
<p>若纯粹地拆字组词，“迷思”又有一种“胡思乱想”的意项在，这是我对于我想法的总结——胡思乱想。这篇文章就是胡思乱想，想着想着觉得有暴论出现可以写一下，仅此而已。我会尽力组织自己的逻辑，但是要这篇文章变成如同高考作文一般逻辑严密，既非我愿，也非我力所能及。</p>
<p>对中文编程我一直保有比较浓厚的兴趣，记得小学刚毕业的时候简短地用过所谓易语言。后来自己以前闲着无聊的时候写过自己脚本语言的解释器所以对于语言设计实现大约还算有一点点心得。恰好最近手痒又想写parser，我就想：为什么不试试看写一个中文的脚本语言呢？</p>
<p>然而思前想后，哪怕只是纸上谈兵的幻想，结果都不算乐观。</p>
<p>做个暴论吧：<strong>目前的所谓中文编程语言不过花瓶，真正实用的中文编程（如果真的有必要的话）任重而道远。</strong></p>
<hr />
<p>我一直认为，要大致把握一个编程语言的特征，写一段快速排序的代码是一个非常好的选择。快排是一个不简单且不平凡的算法，在传统命令式语言的理论框架内，顺序，分支和循环结构都用到了；如果更特殊的特性，快排的复杂度也勉强允许一些语言施展一下其特殊的语言构造。例如Haskell经典的四行快排我觉得就是对函数式语言哲学的一种不错的体现，C++或许也可以炫一波模板元编程和新出的concept。与此同时快速排序也不是特别复杂，让人能够多花心思在语言的特征而不是辨认算法本身上。最后的最后，它还能让我复习一下快排咋写，何乐而不为？</p>
<p>先放一段快排的C代码，代码是我从网上随手拉来的，显然还有很大的优化空间，但这并不重要：</p>
<pre class="line-numbers"><code class="language-c">void quick_sort(int *arr, int left, int right) &#123;
    if (left &gt;= right) return; 
    int p = arr[left];
    int i = left, j = right;
    while (i &lt; j) &#123;
        while (arr[j] &gt;= p &amp;&amp; i &lt; j) j--;         
        while (arr[i] &lt;= p &amp;&amp; i &lt; j) i++;
        int temp = arr[j];
        arr[j] = arr[i];
        arr[i] = temp;
    &#125;
    arr[left] = arr[i]; 
    arr[i] = p;
    quick_sort(arr, left, j - 1);
    quick_sort(arr, j + 1, right);
&#125;</code></pre>
<p>那么问题来了：<strong>人们心目中与上面这一段C对应的“中文代码”应该是什么个样子呢？</strong></p>
<p>是这样吗？</p>
<pre class="line-numbers"><code class="language-none">定义 函数 快速排序（输入：整数 数组，左边界：整数，右边界：整数）：
    如果（左边界 &gt;= 右边界）：返回
    令 基准 为 输入【左边界】
    令 甲 为 左边界
    令 乙 为 左边界
    当（甲 &lt; 乙）时循环：
        当（输入【乙】 &gt;= 基准 且 甲 &lt; 乙）时循环：
            乙 自减
        当（输入【甲】 &lt;= 基准 且 甲 &lt; 乙）时循环：
            甲 自增
        交换（输入【甲】，输入【乙】）
    令 输入【左边界】 为 输入【甲】
    令 输入【甲】 为 基准
    快速排序（输入，左边界，乙 - 1）
    快速排序（输入，乙 + 1，右边界）</code></pre>
<p><strong>中文编程是为了接地气，不是接地府</strong></p>
<p>以上文法的所谓“中文编程语言”在现实开发中是极为不便的。</p>
<p>但很遗憾，这就是现在网络上通行的“中文编程”的现状。</p>
<p>有错吗？乍一看似乎是没有的，在某种意义上这还是“要素完全”的：</p>
<ol type="1">
<li>上面的代码一个拉丁字母都没有用到——“完全汉化”</li>
<li>尽量使用全角字符——“贴合国人使用习惯”</li>
<li>可读性勉强令人满意。</li>
</ol>
<p>然而上面这坨东西我写的时候血压直线飙升。是哪里出了问题？</p>
<p>不妨再看看下一种可能的情况：</p>
<pre class="line-numbers"><code class="language-none">定义快排（整数组输入，整数左界，整数右界）：
    若左界&gt;=右界：返回
    基准赋输入于左界
    甲赋左界；乙赋右界
    当甲&lt;乙：
        当输入于乙&gt;=基准且甲&lt;乙：
            乙自减
        当输入于甲&lt;=基准且甲&lt;乙：
            甲自增
        交换（输入于甲，输入于乙）
    输入于左界赋输入于甲
    输入于甲赋基准
    快排（输入，左界，乙-1）
    快排（输入，乙+1，右界）</code></pre>
<p>看起来似乎比最上面一个例子要好一点是不是？</p>
<p>如果在这个基础上进行一定的代码高亮，那感觉就更上一个台阶：</p>
<p><img src="/2021/04/26/%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E8%BF%B7%E6%80%9D/%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E6%BC%94%E7%A4%BA.svg" class=""></p>
<p>虽然一开始的那一版“中文编程”也可以通过适当的代码高亮在效果上进行优化，但各位试一试就知道，效果应当还是不如上图的。那么，两种文法，都是“中文编程”，是什么导致了舒适度上的巨大差异？</p>
<hr />
<p>回顾编程语言的历史，我们发现，编程语言正逐渐以语言本身的定位为基础，探寻如下三者的最优平衡：</p>
<ol type="1">
<li>对于机器来说好读：文法无二义性，且运行效率高</li>
<li>对于人类来说好读：文法大致贴合阅读习惯，或者说，在训练之后可以快速阅读</li>
<li>对于人类来说好写：文法“废话少”，开发效率高。</li>
</ol>
<p>在文法解析技术、编译器优化技术、以及硬件技术如此发达的当下，第一点的重要性正在逐渐被弱化。那么剩下的，就只有对人好读好写的要求了。既然是“对人”，就自然需要考虑编程语言所依附的自然语言的语言特性。所有人都知道英语和中文无论是在直觉上还是在语言学意义上都有着巨大的差异，因此基于中文的编程语言，又怎么可以生搬硬套基于英语的编程语言的结构呢？以上示例中的两门语言之所以在观感上具有差距，就是因为前者是可以通过直接的单词替换预处理还原为另一门语言的“套皮”，而后者则做了一定程度上的“本地化”。</p>
<p>我们首先注意到，<strong>中文当中是没有空格分词的</strong>。在输入大段中文的时候，空格键往往只作为输入法选词的快捷键而本身不进入文本。这是很多中文编程语言所忽视的。例如</p>
<blockquote>
<p>每 个 中文 词 之间 都有 空格， 写 起来 很 别扭， 读 起来 也 不 习惯。</p>
</blockquote>
<blockquote>
<p>每个中文词之间没有空格读写起来会更为自然。</p>
</blockquote>
<p>这是很多中文编程语言所忽视的一点。然而也必须承认，空格的存在给词法分析提供了极大的便利。联系到当下对于大段中文的分词往往采用，也只能采用启发式的算法的现状，可以说<strong>在一门中文编程语言当中删去空格，虽然可以让读写更为顺畅，但对文法的设计与解析提出了更大的挑战</strong>。（同时，空格的去除让代码开起来更为紧凑，在汉字本身就结构相对复杂的情况下就更会对可读性产生一定的影响，因此在这种情况下，<strong>代码高亮是必要的</strong>）</p>
<p>我们还发现，当下的编程语言在英语的基础上对于关键词进行大量的<strong>简化</strong>。例如，define在Python中被简化为<code>def</code>；function在Go中被简化为<code>func</code>，在Kotlin中被简化为<code>fun</code>，在Rust中更是被简化到<code>fn</code>；integer在很多语言当中都被简化到<code>int</code>，structure被简化到<code>struct</code>……对于英语等拼音文字，这种简化往往是通过去除辅音，删去末音节等完成的，较为简单。但是对于中文象形文字，这种简化就很难了，因为一个词往往就双音节两个字，去了哪个都不行，而仿照去除辅音搞去除笔画之类的毫无意义：<code>结构</code>变成<code>吉勾</code>？还是两个汉字不说，词本身的辨识性已经被破坏殆尽。</p>
<p>然而，我们关注的是目的而不是手段，抛开如此简单粗暴的类比，事情就豁然开朗了。编程语言简化关键词拼写的目的何在？一方面是<strong>让代码更加简洁，阅读效率更高</strong>。另一方面则是<strong>提升输入效率</strong>。中文或许在阅读效率方面已经无可挑剔，但是在输入效率上一直差强人意——我不是说中文本身的输入效率，而是写代码本身的效率。二者有何区别？</p>
<p>如今不用代码补全写代码的人已经不多了。代码补全的本质，是在用户敲击键盘进行原始输入的同时，结合上下文，给出符合编程语言语法以及（理想情况下）代码语义的代码建议。仔细想想，这和中文的输入法何其相似！然而现在并没有专为写代码而生的输入法。要写中文代码，就必须先敲键盘，再输入法选词，等到中文字实实在在地落到了编辑器里，代码补全才会出现，然后用户就要再次选词，如图</p>
<p><img src="/2021/04/26/%E4%B8%AD%E6%96%87%E7%BC%96%E7%A8%8B%E8%BF%B7%E6%80%9D/Completion.svg" class=""></p>
<p>显然，在上例中，如果能把输入法整合进自动补全（或者反过来），使得在键入<code>ks</code>时就自动跳出<code>快速排序</code>的提示项，对于开发效率和流畅性会有可观的提升（在没有空格分词的中文编程语言中，这样的融合自动补全可以综合考虑到关键词以及文法结构，这种流畅性提升会更为显著）。否则，对于针对自然语言输入而设计的输入法而言，编程的上下文不免会让提词非常别扭；对于代码补全而言，变量名一般就三四个字个字，在输入法打完两个字后再补全一般似乎也如同鸡肋。两者没有沟通各自为战，折磨的就是开发者。理想情况下，<strong>中文编程中的输入法和代码补全不说是合二为一也应当是互相合作的</strong>。相比于独立地弹出一个下拉框，代码补全应当使用一个输入法提供的接口访问用户在键盘上的原始输入并给出建议，这样用户在输入法的选词界面就可以直接看到代码提示，效率何止提升了两倍。然而，现实中的各输入法都热衷于闭门造车，即使是以开源闻名的Rime都不提供这种动态提词接口。因此，如果要实现前文的创想，倒是IDE的开发者自己从零写一个兼容自动补全的输入法更现实一点。而后者可就造轮子造大了去了。</p>
<p>简单的总结一下，如果要实现我心目中理想的中文编程语言，应当有这两个特点：</p>
<ol type="1">
<li><strong>本土化的语言文法：</strong>在不引入二义性的前提下，降低空格分词的必要性，或更多地从中文本身借鉴一部分文法结构，使得汉字的输入和阅读更符合自然语言的习惯。不满足这一点，则不免对于阅读的流畅性产生影响，产生生硬之观感，被好事者讥为“套皮”。</li>
<li><strong>高效率的开发环境：</strong>在开发环境上完成输入法和自动补全的整合，提升写代码的流畅性，同时提供靠谱的代码高亮方案以辅助阅读。不满足这一点，则读起来再赏心悦目的编程语言写起来都有不便，难免花瓶一个，华而不实。</li>
</ol>
<p>这两点的难度不是一般的大，因此我觉得实用的中文编程任重而道远。当然，考虑到中文编程除了看着一乐以外未必有其他特殊的吸引力，实际上这种编程语言大概是遥遥无期了。</p>
<p>迷思迷思，思到这大概也就结束了。整篇文章想到哪里写到哪里，估计很乱吧（笑），如果有人读着这个觉得摸不着头脑，实在是抱歉。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ma-chengyuan.github.io/2021/04/26/LaTeX%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/26/LaTeX%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">LaTeX小技巧整理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-26 23:43:26" itemprop="dateCreated datePublished" datetime="2021-04-26T23:43:26-04:00">2021-04-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这篇文章是在经历<span class="math inline">\(\LaTeX\)</span>改格式改得死去活来后对于以后可能经常会用到的格式调整小技巧的一个汇总。许多片段的来源是TeX StackExchange, 源链接就不一一表明了。这些技巧在XeTeX上编译通过，对于其他的引擎尚未测试。</p>
<p>该列表预计会随着我被<span class="math inline">\(\LaTeX\)</span>虐的次数增加而不断更新。</p>
<h1 id="页边距设置">页边距设置</h1>
<p>使用<code>geometry</code>宏包：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;geometry&#125;
\geometry&#123;a4paper, top = 34.4mm, bottom = 45mm, left = 23mm, right = 23mm&#125;</code></pre>
<p>更高级的用途可以参阅其官方文档。</p>
<h1 id="字体设置">字体设置</h1>
<h2 id="times-new-roman">Times New Roman</h2>
<p>为了全局设置Times New Roman字体，我们需要<code>fontspec</code>宏包：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;fontspec&#125;
\setmainfont&#123;Times New Roman&#125;</code></pre>
<p>如果希望数学公式的字体也使用Times New Roman，可以使用<code>newtx</code>宏包：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;newtxmath&#125;</code></pre>
<p>注：<code>newtx</code>宏包下还有<code>newtxtext</code>可以代替<code>fontspec</code>和<code>setmainfont</code>的功能，但是不知为何在Windows的XeTeX上编译错误。归根结底，XeTeX以及LuaTeX的一个设计理念就是使用户可以直接调用系统字体而不用拘泥于宏包，因此我个人还是偏向于<code>setmainfont</code>的解决方案。</p>
<h2 id="宋体粗体">宋体粗体</h2>
<p>CTeX在Windows系统下宋体采用的是中易的字库，而不幸的是中易的宋体并不包括粗体。Word之所以可以给中易宋体加粗，是因为它有在标准字重基础之上自动加粗的算法。而高贵的<span class="math inline">\(\LaTeX\)</span>显然是不屑于用这种歪门邪道加粗字体的，所以你惊喜地发现在Windows下你似乎无论怎么<code>\textbf</code>/<code>\bfseries</code>都得不到加粗的宋体（于是CTeX就机智地把黑体作为粗体时的字体）。如果因为种种原因迫不得已一定要使用粗体，CTeX给出了两个解决方案：</p>
<ol type="1">
<li>伪粗体：通过对于一个汉字堆叠若干个微距平移标准字号的宋体实现视觉上的粗体效果。这种伪粗体效果肯定不如专门的宋体效果好，而且在PDF内选词的时候偶尔会遇到问题，因此我是没有使用过。</li>
<li>使用带有粗体的宋体：可以使用<code>\setCJKmainfont</code>命令转而使用例如思源黑体等设计时考虑粗体的字体。这在Windows下其实也不简单。最傻瓜的做法是在<code>\documentclass&#123;ctexart&#125;</code>前加上<code>[fontset = fandol]</code>选项，使得CTeX采用Fandol的字库。这家的字库可以在GPL协议下自由使用，但是缺点是缺的字不少。</li>
<li>不是解决办法的办法：装一台Ubuntu的虚拟机，Ubuntu下的默认宋体是带有粗字号的，问题直接解决。</li>
</ol>
<h1 id="标题格式的修改">标题格式的修改</h1>
<p>一般来说，LaTeX内修改标题格式最合适的宏包是<a target="_blank" rel="noopener" href="https://www.ctan.org/pkg/titlesec"><code>titlesec</code></a>。<code>titlesec</code>的文档相当详细，SE上也有非常多的教程，所以在这类就不多赘述了。我想记一笔的是CTeX内部自带的格式设置功能：这个功能在CTeX的<a target="_blank" rel="noopener" href="https://www.ctan.org/pkg/titlesec">官方手册</a>上确有记载，但是在网上却不是很好找。个人认为用法比<code>titlesec</code>简洁明了，对于一般的中文文档已是相当够用了。这里举一个例子：</p>
<pre class="line-numbers"><code class="language-latex">\ctexset&#123;
    section/format = \songti\sffamily\zihao&#123;-4&#125;\bfseries, % 中文宋体，英文无衬线体，字号小四，加粗
    section/afterskip = 0pt, % 标题下方不留空，直接接段落，更紧凑
    subsection/format = \songti\sffamily\zihao&#123;5&#125;\bfseries, % 中文宋体，英文无衬线体，字号五号，加粗
    subsection/beforeskip = 0pt, % 标题上方不留空，直接在上一段下方，更紧凑
    subsection/afterskip = 0pt, % 标题上方不留空
    subsubsection/format = \songti\sffamily\zihao&#123;5&#125;\bfseries, % 中文宋体，英文无衬线体，字号五号，加粗
    subsubsection/beforeskip = 0pt,
    subsubsection/afterskip = 0pt   
&#125;</code></pre>
<h1 id="参考文献标题格式的修改">“参考文献”标题格式的修改</h1>
<p>和上节相同，只需要在<code>\thebibliography</code>之前修改<code>section</code>的格式就行了（如果还有附录的话不要忘记改回来）。</p>
<p>如果要修改“参考文献”这四个字本身，CTeX提供了<code>refname</code>选项。</p>
<h1 id="自动引号配对">自动引号配对</h1>
<p>使用<code>csquotes</code>宏包：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage[autostyle=false, style=english]&#123;csquotes&#125;
\MakeOuterQuote&#123;&quot;&#125;</code></pre>
<h1 id="中文的定理环境">中文的定理环境</h1>
<p>CTeX会自动将<code>amsthm</code>包当中的证明环境从“Proof”改成“证明”，但在<code>ctexart</code>类型下不会对定理，引理，定义等环境进行汉化，因此需要手动加入如下代码：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;amsthm&#125;
\newtheorem&#123;theorem&#125;&#123;定理&#125;[section]
\newtheorem&#123;definition&#125;&#123;定义&#125;[section]
\newtheorem&#123;corollary&#125;&#123;推论&#125;[section]
\newtheorem*&#123;remark&#125;&#123;注&#125;
\newtheorem&#123;lemma&#125;&#123;引理&#125;[section]</code></pre>
<h1 id="列表环境下的间距">列表环境下的间距</h1>
<h2 id="一般列表去除间距">一般列表去除间距</h2>
<p>使用<code>enumitem</code>宏包的<code>nosep</code>选项让<code>enumerate</code>和<code>itemize</code>中相邻项之间的垂直间距为0：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;enumitem&#125;

\begin&#123;enumerate&#125;[nosep]

\end&#123;enumerate&#125;</code></pre>
<h2 id="文献列表去除间距">文献列表去除间距</h2>
<p>通过以下代码去除文献列表中相邻项的垂直间距：</p>
<pre class="line-numbers"><code class="language-latex">% 去除参考文献一节文献项之间过大的间隙
\let\OLDthebibliography\thebibliography
\renewcommand\thebibliography[1]&#123;
    \OLDthebibliography&#123; #1 &#125;
    \setlength&#123;\parskip&#125;&#123;0pt&#125;
    \setlength&#123;\itemsep&#125;&#123;0pt plus 0.3ex&#125;
&#125;</code></pre>
<h1 id="图注格式修改">图注格式修改</h1>
<p>最为通用，最为灵活的方法：</p>
<pre class="line-numbers"><code class="language-latex">% 宋体五号粗体，#1#2#3分别是“图xxx”，“：”，以及图注文字本身
\DeclareCaptionFormat&#123;mycaptionformat&#125;&#123;\songti\zihao&#123;-5&#125;\bfseries#1#2#3\par&#125;
\captionsetup&#123;format = mycaptionformat&#125;</code></pre>
<h1 id="页眉页脚相关">页眉页脚相关</h1>
<h2 id="首页特殊">首页特殊</h2>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;fancyhdr&#125;
\fancypagestyle&#123;firststyle&#125;&#123;
    \fancyhf&#123;&#125;
    \renewcommand&#123;\headrule&#125;&#123;\hrule height 0.5pt \vspace&#123;0.8pt&#125;\hrule height 0.5pt&#125;
    \renewcommand&#123;\footrule&#125;&#123;\hrule height 0.5pt width 0.3\textwidth&#125;
    ...
&#125;

% 在\begin&#123;document&#125;之后
\thispagestyle&#123;firststyle&#125;</code></pre>
<h2 id="装饰线">装饰线</h2>
<pre class="line-numbers"><code class="language-latex">% 页眉双线
\renewcommand&#123;\headrule&#125;&#123;\hrule height 0.5pt \vspace&#123;0.8pt&#125;\hrule height 0.5pt&#125;
% 页脚部分装饰线
\renewcommand&#123;\footrule&#125;&#123;\hrule height 0.5pt width 0.3\textwidth&#125;</code></pre>
<p>参数可以视情况自行调整；可以写在<code>\fancypagestyle</code>内部。</p>
<h1 id="在一行内同时包括左中右对齐的文本">在一行内同时包括左中右对齐的文本</h1>
<pre class="line-numbers"><code class="language-latex">\newcommand&#123;\headerline&#125;[3]&#123;
    \par\medskip\noindent
    \makebox[\textwidth][s]&#123;\rlap&#123;#1&#125;\hfill#2\hfill\llap&#123;#3&#125;&#125;%
    \par\medskip
&#125;
% 用例：
\headerline&#123;•栏目•&#125;&#123;doi: 10.3866/PKU.DXHX20xxxxxxx&#125;&#123;www.dxhx.pku.edu.cn&#125;</code></pre>
<h1 id="在表格环境内改变表线宽度">在表格环境内改变表线宽度</h1>
<p>鉴于许多办法可能不适用于除<code>tabular</code>之外的环境，这里提供一个简单粗暴的办法：</p>
<pre class="line-numbers"><code class="language-latex">\setlength&#123;\doublerulesep&#125;&#123;0pt&#125;
...

\hline\hline % 两倍标准线宽</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ma-chengyuan.github.io/2021/03/17/MITAdmitted/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/17/MITAdmitted/" class="post-title-link" itemprop="url">被MIT录取杂感</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-17 20:44:31" itemprop="dateCreated datePublished" datetime="2021-03-17T20:44:31-04:00">2021-03-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-27 04:17:58" itemprop="dateModified" datetime="2021-03-27T04:17:58-04:00">2021-03-27</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>3月15日清晨6:30分</p>
<p>某人迷迷糊糊地刚刚从被窝里爬出来</p>
<p>迷迷糊糊地唤醒一夜没关的电脑</p>
<p>迷迷糊糊地点进MIT的portal</p>
<p>啊，果然status更新了呢，虽然不该抱什么期待的</p>
<p>自己这个水平申请纯属做分母哦，大概一定是thank you for applying to MIT这种套路话罢（确信）</p>
<p>为了彻底让自己死心点了进去并开始阅读</p>
<blockquote>
<p>On behalf of the Admissions Committee, it is my pleasure to offer you admission to the MIT Class of 2025! You stood out ...</p>
</blockquote>
<p>嗯？（要素察觉）</p>
<p><img src="/2021/03/17/MITAdmitted/%E5%9C%B0%E9%93%81%E8%80%81%E4%BA%BA%E6%89%8B%E6%9C%BA.jpg" class=""></p>
<p><strong>嗯？！？！？</strong></p>
<p><img src="/2021/03/17/MITAdmitted/%E8%BF%99%E5%9C%BA%E9%9D%A2%E6%88%91%E7%9C%9F%E6%B2%A1%E8%A7%81%E8%BF%87.jpg" class=""></p>
<p>千言万语在早晨上学的急忙中汇成一句话</p>
<blockquote>
<p>草，居然录了？</p>
</blockquote>
<p>然后简单地发了个朋友圈，吃完饭，开开心心上学去了。</p>
<p>学校申请的竞争是残酷的，所谓成王败寇莫不如是。抢救性写感言，各路学弟开始问经验，然后我其实一时半会并答不出来。另一方面，我在学姐的帮助下倒是在一个小时内就找到了组织见到了前几届MIT的学长，然后发现群里面个个都是集训队级别的大佬，区区国铜瑟瑟发抖。</p>
<p>一切都引向了一个我必须思考的问题：</p>
<blockquote>
<p>我这么菜，为啥会被MIT看上呢？</p>
</blockquote>
<p><img src="/2021/03/17/MITAdmitted/%E5%8F%8D%E5%A4%8D%E5%88%86%E6%9E%90.jpg" class=""></p>
<p>论标化，自己的标化成绩在国内传统认知内对于MIT的申请只能称得上是堪堪够用。</p>
<p>论文书，因为自己原本对MIT的申请不抱特别大的希望，文书写的是中规中矩，没有特别多的灵光一现和奇妙构思。</p>
<p>论活动，自己没有上过许多国内奉为圭臬的夏校。没有辩论，没有模联，没有特别多社会活动。</p>
<p>论竞赛，自己国铜的最高水准大概只到了最低线？</p>
<p>论申请策略，自己直接说喜欢EECS的直球做法在许多人看来也是头铁。</p>
<p>那是为什么呢？</p>
<p>转了一圈，思绪回到1月6号申请最后一天在电脑前的奋笔疾书。</p>
<p>是了，原来如此，答案或许见诸于MIT申请系统的首页：</p>
<blockquote>
<p>The key is to be yourself.</p>
</blockquote>
<p>我在最后一天才意识到MIT的申请居然允许递交一份maker portfolio，那时的兴奋是无以言表的。</p>
<p>自己就把自己平时乱搞的小项目连简介带Github链接填了上去，填了九个，简介写了一千多个词，自己从未如此畅快。</p>
<p>想必让招生官高看我一眼的，大概就是这么多乱搞项目当中体现出来的对<del>摸鱼</del>计算机的一种热情？（暴论）</p>
<p>记得自己曾经做第一个小项目的时候，一方面是觉得自己开心，另一方面为未尝没有“如果项目牛逼了会不会被人赏识”的小功利心和小幻想。做了那么多小项目，快乐是总有的，但牛逼的项目是没有的，所以在高中的几年觉得大学申请愈发迫近也曾焦虑迷茫过，尝试过竞赛，但也难以完全投入精力，最终屈服于自己强大的摸鱼欲之下重操旧业。也不止一次地心中有“自己摸鱼做项目的时间是不是浪费了呢？”的疑问。</p>
<p>但是现实证明，所有的努力都不会被辜负。</p>
<p>自己的气质或许也和MIT很般配呢（大雾）。</p>
<p><img src="/2021/03/17/MITAdmitted/tradeschoolmeme.png" class=""></p>
<p>当然，这也可以理解为是某人摸鱼主义哲学的大胜利（大雾）。</p>
<p><img src="/2021/03/17/MITAdmitted/image-20210326162803734.png" class=""></p>
<p><del>上图：当你摸鱼的contribution都状似摸鱼，你就达成了二阶摸鱼的至高境界，物极必反，这是MIT的隐藏通道</del></p>
<p>人啊，还是要有理想的，有理想地摸鱼，这就达成了一组矛盾的对立统一，矛盾摸鱼，乃摸鱼之大境界。</p>
<p>最后还是要说一句，<del>Cornell你拒的好啊！</del></p>
<p>录了技校，人很开心，加上之前录了剑桥，所以现在就是一个去Cambridge还是去Cambridge的问题了，我选择去Cambridge。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ma-chengyuan.github.io/2021/03/16/Wallis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/16/Wallis/" class="post-title-link" itemprop="url">数学课划水整活之Wallis乘积公式的一种证明</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-16 01:07:28" itemprop="dateCreated datePublished" datetime="2021-03-16T01:07:28-04:00">2021-03-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>今天数学课讲了一点组合数的性质，因为太简单了所以稍微划了一会水。</p>
<p>结果发现自己整出来了一个算<span class="math inline">\(\pi\)</span>的式子？</p>
<p>化简以后发现是传说中的Wallis公式？</p>
<p>虽然原理一样的证明Wiki上有提到但是还是当场惊了。</p>
<p>简单记一笔吧。</p>
<p>一切的开端是今年寒假做夏校申请的时候证明过的一个极限 <span class="math display">\[
\lim_{n\to\infty} 2^{-2n}\binom{2n}{n} = 0
\]</span> 当时是用斯特林近似暴力代换进行证明（现在看来并不严谨） <span class="math display">\[
\begin{aligned}
    \lim_{n\to\infty} \binom{2n}{n} \frac{\left[\sqrt{2\pi n} \left(n \over e\right)^n \right]^2} {\sqrt{4\pi n} \left(2n \over e\right)^{2n}} &amp;= \lim_{n\to\infty} \left[\frac{\sqrt{2\pi n} \left(n \over e\right)^n}{n!}\right]^2 \frac{(2n)!}{\sqrt{4\pi n} \left(2n \over e\right)^{2n}} \\
    &amp;= 1 \\     
    \Rightarrow 
    \lim_{n\to\infty} 2^{-2n}\binom{2n}{n} &amp;= \lim_{n\to\infty} 2^{-2n}\frac {\sqrt{4\pi n} \left(2n \over e\right)^{2n}}{\left[\sqrt{2\pi n} \left(n \over e\right)^n\right]^2} \cdot \lim_{n\to\infty} \binom{2n}{n} \frac{\left[\sqrt{2\pi n} \left(n \over e\right)^n\right]^2} {\sqrt{4\pi n} \left(2n \over e\right)^{2n}} \\
    &amp;=  \lim_{n\to\infty} 2^{-2n}\frac {\sqrt{4\pi} 2^{2n}n^{2n+\frac{1}{2}}e^{-2n}}{2\pi n^{2n+1}e^{-2n}} \\
    &amp;= \lim_{n\to\infty} \frac{1}{\sqrt{\pi n}}\\
    &amp;= 0
\end{aligned}
\]</span> 今天划水的时候发现由以上过程，这个极限可以加强为 <span class="math display">\[
\lim_{n\to\infty} \frac{\sqrt{\pi n}\binom{2n}{n}}{2^{2n}} = 1
\]</span> 稍作整理即得 <span class="math display">\[
\lim_{n\to\infty} \frac{2^{4n}}{n\binom{2n}{n}^2} = \pi
\]</span> 拿卡西欧摁了一下，发现式子没有假，虽然收敛得有亿点点慢但确实是收敛到了<span class="math inline">\(\pi\)</span>。</p>
<p>关键是这个式子我似乎没见过啊？<del>内心直接膨胀，可把我牛逼坏了。</del></p>
<p>因为形式看起来较复杂，接着我就想可不可以通过邻项作比的方式变换一下形态 <span class="math display">\[
\begin{aligned}
\frac{2^{4n}}{n\binom{2n}{n}^2} \Bigg / \frac{2^{4(n-1)}}{(n-1)\binom{2n-2}{n-1}^2} &amp;= \frac{16(n-1)}{n} \left[\binom{2n-2}{n-1} \bigg/ \binom{2n}{n}\right]^2 \\
&amp;= \frac{16(n-1)}{n} \left[\frac{n^2}{2n(2n-1)}\right]^2 \\
&amp;= \frac{16n(n-1)}{(4n-2)^2} \\
&amp;= \frac{2n}{2n-1}\cdot \frac{2n-2}{2n-1}
\end{aligned}
\]</span> 这个形式似曾相识，结合上式把式子化为连乘积的形式，要素察觉！ <span class="math display">\[
\begin{aligned}
\frac{2^{4n}}{n\binom{2n}{n}^2} &amp;= \frac{2^{4}}{1\binom{2}{1}^2} \cdot \frac{2}{3} \cdot \frac{4}{3} \cdot \frac{4}{5} \cdot \frac{6}{5} \cdots \frac{2n-2}{2n-1}\cdot \frac{2n}{2n-1} \\
&amp;= 4\cdot \frac{2}{3} \cdot \frac{4}{3} \cdot \frac{4}{5} \cdot \frac{6}{5} \cdots \frac{2n-2}{2n-1}\cdot \frac{2n}{2n-1}
\end{aligned}
\]</span> 这不就是Wallis乘积公式嘛？翻出Wikipedia一看： <span class="math display">\[
\begin{aligned}
\frac{\pi}{2} &amp;=\prod_{n=1}^{\infty} \frac{4 n^{2}}{4 n^{2}-1}=\prod_{n=1}^{\infty}\left(\frac{2 n}{2 n-1} \cdot \frac{2 n}{2 n+1}\right) \\
&amp;=\left(\frac{2}{1} \cdot \frac{2}{3}\right) \cdot\left(\frac{4}{3} \cdot \frac{4}{5}\right) \cdot\left(\frac{6}{5} \cdot \frac{6}{7}\right) \cdot\left(\frac{8}{7} \cdot \frac{8}{9}\right) \cdots
\end{aligned}
\]</span> 完全一致，直接得证。</p>
<p>哇，也就是说我划着水就把Wallis公式不严谨地整了一遍？</p>
<p><em>果然还是要膨胀.jpg</em></p>
<p>以前觉得这个式子很高端的，现在有种莫名的幻灭感。</p>
<p>但是写到这的时候多看了一眼，发现斯特林逼近的一个推导里用到了Wallis公式？</p>
<p>突然有点不确定这算不算是循环论证了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chengyuan Ma</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js" integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha512-br8H6OngKoLht57WKRU5jz3Vr0vF+Tw4G6yhNN2F3dSDheq4JiaasROPJB1wy7PxPk7kV/+5AIbmoZLxxx7Zow==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-bash.min.js" integrity="sha512-JvRd44DHaJAv/o3wxi/dxhz2TO/jwwX8V5/LTr3gj6QMQ6qNNGXk/psoingLDuc5yZmccOq7XhpVaelIZE4tsQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-c.min.js" integrity="sha512-T6Lco61aWqCKSznWkd38lf159pD0+EwZ9UCEv6ARAvaWFiy/UHtYgOmlasT8lq5Ck17ZNHzbe5eHUablTGRXxw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cmake.min.js" integrity="sha512-M99z3be36IUB5pA3DWoJvjSYaZA9BiUqf1jXzVcjntASBZFNI53oDRzdJqGzH5voybcAx5Sg8F5QyryE6afD3g==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cpp.min.js" integrity="sha512-hxZJ6OUEpUl9/o4C1gMGvrAbeqDaldBiZbs08c/V8NcU7YImBFlqJAc7Uzjf3bh2W8Wx26/dVDyPk9cUMQY0Mw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-go.min.js" integrity="sha512-SgF1uayJ2/8TV+MhLasqygnm++vYRXswmrR2ZAmUCL4pXtf+6KzUgXPpn10Y6xca658sxOQEOsoP3MChfhke5A==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-java.min.js" integrity="sha512-PWHY6Vao4E9K4LsGBYCY0ttDeiWZwuUozTbJvSy9UFHRz2J4Bl7rcWML3wEnJTVuCJhSwGne/8My5gTo/gnbpg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-json.min.js" integrity="sha512-IC7rV8RslChgByOdUFC6ePqOGn+OwJhnKC3S5AezM8DAiOdGhJMwgsIvBChsa2yuxxoPbH2+W/kjNUM1cc+jUQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-kotlin.min.js" integrity="sha512-aTozTdtORp/xxS/dhRRDfmv/p1eyEMTje96MplkSOqdbKGGvOYIlogoGdtsh/BD91vaqKoAw9M7O/DodqqudIQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-julia.min.js" integrity="sha512-eTGeKQdDzC2rPAUVfM2Fa36s9B9wp138NEhzZqJpRSdJQ66BwLUot25r2YQveCRU5uYNVfX3gckDkl4byfBIWw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-latex.min.js" integrity="sha512-6D3l3Fy8g/hr6AeK2g1rcVZHyFjCqiqgUrwy0mBZTGFd8UwVcUDhzQeIIv3eYeXDecGPTtBOS9ctyRzJyUgypQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-rust.min.js" integrity="sha512-kgT7r2HlCEO4b+Rp3nJvm+/EMBwGMvv1WMdWkb3eNgnS91llMli8Y3T1CgnD8Hifqx50Q3XLUQXDd7PzKQQtUA==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-python.min.js" integrity="sha512-wK9tQmDrstGtZqTKcyVf3h457QGMlNriKs+fHmEkiCizrq0LVovfT3v1smeT1DlQetHhdRkkX1JSuZg5LoNHJg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-nginx.min.js" integrity="sha512-/MNzg8GlnVrAau/TZClh1jxgHNX0HDgidbGnHS5x1OtbKiNoK3e0XNd1oV16xmmeDHjisa3GKLArUau+43GZ4A==" crossorigin="anonymous"></script>
<script type = "text/javascript">
    document.addEventListener('pjax:complete', function() {
        if (typeof Prism !== 'undefined') {
            Prism.highlightAll();
        }
    });
</script>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  






  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    <div class="pjax">

  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



    </div>
</body>
</html>
