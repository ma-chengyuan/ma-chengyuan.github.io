<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"alan20210202.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="不务正业高中生一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="Chengyuan Ma&#39;s Blog">
<meta property="og:url" content="https://alan20210202.github.io/page/7/index.html">
<meta property="og:site_name" content="Chengyuan Ma&#39;s Blog">
<meta property="og:description" content="不务正业高中生一枚">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chengyuan Ma">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://alan20210202.github.io/page/7/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.css" integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbggqjHJeyzx88I3rfwjS38WJag/ihH7lzuGlGHpDBymLirZQ==" crossorigin="anonymous" />
<title>Chengyuan Ma's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-65HSG5NCY6"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-65HSG5NCY6');
      }
    </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Chengyuan Ma's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-pagedewarp"><a href="/dewarp/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>PageDewarp</a></li>
        <li class="menu-item menu-item-english"><a href="/english/" rel="section"><i class="fa fa-globe-americas fa-fw"></i>English</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chengyuan Ma"
      src="/avatar.png">
  <p class="site-author-name" itemprop="name">Chengyuan Ma</p>
  <div class="site-description" itemprop="description">不务正业高中生一枚</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">94</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://kalasearch.cn/" title="https:&#x2F;&#x2F;kalasearch.cn&#x2F;" rel="noopener" target="_blank">卡拉搜索</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/LaTeX%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/LaTeX%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">LaTeX小技巧整理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-26 23:43:26" itemprop="dateModified" datetime="2021-04-26T23:43:26-04:00">2021-04-26</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这篇文章是在经历<span class="math inline">\(\LaTeX\)</span>改格式改得死去活来后对于以后可能经常会用到的格式调整小技巧的一个汇总。许多片段的来源是TeX StackExchange, 源链接就不一一表明了。这些技巧在XeTeX上编译通过，对于其他的引擎尚未测试。</p>
<p>该列表预计会随着我被<span class="math inline">\(\LaTeX\)</span>虐的次数增加而不断更新。</p>
<h1 id="页边距设置">页边距设置</h1>
<p>使用<code>geometry</code>宏包：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;geometry&#125;
\geometry&#123;a4paper, top = 34.4mm, bottom = 45mm, left = 23mm, right = 23mm&#125;</code></pre>
<p>更高级的用途可以参阅其官方文档。</p>
<h1 id="字体设置">字体设置</h1>
<h2 id="times-new-roman">Times New Roman</h2>
<p>为了全局设置Times New Roman字体，我们需要<code>fontspec</code>宏包：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;fontspec&#125;
\setmainfont&#123;Times New Roman&#125;</code></pre>
<p>如果希望数学公式的字体也使用Times New Roman，可以使用<code>newtx</code>宏包：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;newtxmath&#125;</code></pre>
<p>注：<code>newtx</code>宏包下还有<code>newtxtext</code>可以代替<code>fontspec</code>和<code>setmainfont</code>的功能，但是不知为何在Windows的XeTeX上编译错误。归根结底，XeTeX以及LuaTeX的一个设计理念就是使用户可以直接调用系统字体而不用拘泥于宏包，因此我个人还是偏向于<code>setmainfont</code>的解决方案。</p>
<h2 id="宋体粗体">宋体粗体</h2>
<p>CTeX在Windows系统下宋体采用的是中易的字库，而不幸的是中易的宋体并不包括粗体。Word之所以可以给中易宋体加粗，是因为它有在标准字重基础之上自动加粗的算法。而高贵的<span class="math inline">\(\LaTeX\)</span>显然是不屑于用这种歪门邪道加粗字体的，所以你惊喜地发现在Windows下你似乎无论怎么<code>\textbf</code>/<code>\bfseries</code>都得不到加粗的宋体（于是CTeX就机智地把黑体作为粗体时的字体）。如果因为种种原因迫不得已一定要使用粗体，CTeX给出了两个解决方案：</p>
<ol type="1">
<li>伪粗体：通过对于一个汉字堆叠若干个微距平移标准字号的宋体实现视觉上的粗体效果。这种伪粗体效果肯定不如专门的宋体效果好，而且在PDF内选词的时候偶尔会遇到问题，因此我是没有使用过。</li>
<li>使用带有粗体的宋体：可以使用<code>\setCJKmainfont</code>命令转而使用例如思源黑体等设计时考虑粗体的字体。这在Windows下其实也不简单。最傻瓜的做法是在<code>\documentclass&#123;ctexart&#125;</code>前加上<code>[fontset = fandol]</code>选项，使得CTeX采用Fandol的字库。这家的字库可以在GPL协议下自由使用，但是缺点是缺的字不少。</li>
<li>不是解决办法的办法：装一台Ubuntu的虚拟机，Ubuntu下的默认宋体是带有粗字号的，问题直接解决。</li>
</ol>
<h1 id="标题格式的修改">标题格式的修改</h1>
<p>一般来说，LaTeX内修改标题格式最合适的宏包是<a target="_blank" rel="noopener" href="https://www.ctan.org/pkg/titlesec"><code>titlesec</code></a>。<code>titlesec</code>的文档相当详细，SE上也有非常多的教程，所以在这类就不多赘述了。我想记一笔的是CTeX内部自带的格式设置功能：这个功能在CTeX的<a target="_blank" rel="noopener" href="https://www.ctan.org/pkg/titlesec">官方手册</a>上确有记载，但是在网上却不是很好找。个人认为用法比<code>titlesec</code>简洁明了，对于一般的中文文档已是相当够用了。这里举一个例子：</p>
<pre class="line-numbers"><code class="language-latex">\ctexset&#123;
    section/format = \songti\sffamily\zihao&#123;-4&#125;\bfseries, % 中文宋体，英文无衬线体，字号小四，加粗
    section/afterskip = 0pt, % 标题下方不留空，直接接段落，更紧凑
    subsection/format = \songti\sffamily\zihao&#123;5&#125;\bfseries, % 中文宋体，英文无衬线体，字号五号，加粗
    subsection/beforeskip = 0pt, % 标题上方不留空，直接在上一段下方，更紧凑
    subsection/afterskip = 0pt, % 标题上方不留空
    subsubsection/format = \songti\sffamily\zihao&#123;5&#125;\bfseries, % 中文宋体，英文无衬线体，字号五号，加粗
    subsubsection/beforeskip = 0pt,
    subsubsection/afterskip = 0pt   
&#125;</code></pre>
<h1 id="参考文献标题格式的修改">“参考文献”标题格式的修改</h1>
<p>和上节相同，只需要在<code>\thebibliography</code>之前修改<code>section</code>的格式就行了（如果还有附录的话不要忘记改回来）。</p>
<p>如果要修改“参考文献”这四个字本身，CTeX提供了<code>refname</code>选项。</p>
<h1 id="自动引号配对">自动引号配对</h1>
<p>使用<code>csquotes</code>宏包：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage[autostyle=false, style=english]&#123;csquotes&#125;
\MakeOuterQuote&#123;&quot;&#125;</code></pre>
<h1 id="中文的定理环境">中文的定理环境</h1>
<p>CTeX会自动将<code>amsthm</code>包当中的证明环境从“Proof”改成“证明”，但在<code>ctexart</code>类型下不会对定理，引理，定义等环境进行汉化，因此需要手动加入如下代码：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;amsthm&#125;
\newtheorem&#123;theorem&#125;&#123;定理&#125;[section]
\newtheorem&#123;definition&#125;&#123;定义&#125;[section]
\newtheorem&#123;corollary&#125;&#123;推论&#125;[section]
\newtheorem*&#123;remark&#125;&#123;注&#125;
\newtheorem&#123;lemma&#125;&#123;引理&#125;[section]</code></pre>
<h1 id="列表环境下的间距">列表环境下的间距</h1>
<h2 id="一般列表去除间距">一般列表去除间距</h2>
<p>使用<code>enumitem</code>宏包的<code>nosep</code>选项让<code>enumerate</code>和<code>itemize</code>中相邻项之间的垂直间距为0：</p>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;enumitem&#125;

\begin&#123;enumerate&#125;[nosep]

\end&#123;enumerate&#125;</code></pre>
<h2 id="文献列表去除间距">文献列表去除间距</h2>
<p>通过以下代码去除文献列表中相邻项的垂直间距：</p>
<pre class="line-numbers"><code class="language-latex">% 去除参考文献一节文献项之间过大的间隙
\let\OLDthebibliography\thebibliography
\renewcommand\thebibliography[1]&#123;
    \OLDthebibliography&#123; #1 &#125;
    \setlength&#123;\parskip&#125;&#123;0pt&#125;
    \setlength&#123;\itemsep&#125;&#123;0pt plus 0.3ex&#125;
&#125;</code></pre>
<h1 id="图注格式修改">图注格式修改</h1>
<p>最为通用，最为灵活的方法：</p>
<pre class="line-numbers"><code class="language-latex">% 宋体五号粗体，#1#2#3分别是“图xxx”，“：”，以及图注文字本身
\DeclareCaptionFormat&#123;mycaptionformat&#125;&#123;\songti\zihao&#123;-5&#125;\bfseries#1#2#3\par&#125;
\captionsetup&#123;format = mycaptionformat&#125;</code></pre>
<h1 id="页眉页脚相关">页眉页脚相关</h1>
<h2 id="首页特殊">首页特殊</h2>
<pre class="line-numbers"><code class="language-latex">\usepackage&#123;fancyhdr&#125;
\fancypagestyle&#123;firststyle&#125;&#123;
    \fancyhf&#123;&#125;
    \renewcommand&#123;\headrule&#125;&#123;\hrule height 0.5pt \vspace&#123;0.8pt&#125;\hrule height 0.5pt&#125;
    \renewcommand&#123;\footrule&#125;&#123;\hrule height 0.5pt width 0.3\textwidth&#125;
    ...
&#125;

% 在\begin&#123;document&#125;之后
\thispagestyle&#123;firststyle&#125;</code></pre>
<h2 id="装饰线">装饰线</h2>
<pre class="line-numbers"><code class="language-latex">% 页眉双线
\renewcommand&#123;\headrule&#125;&#123;\hrule height 0.5pt \vspace&#123;0.8pt&#125;\hrule height 0.5pt&#125;
% 页脚部分装饰线
\renewcommand&#123;\footrule&#125;&#123;\hrule height 0.5pt width 0.3\textwidth&#125;</code></pre>
<p>参数可以视情况自行调整；可以写在<code>\fancypagestyle</code>内部。</p>
<h1 id="在一行内同时包括左中右对齐的文本">在一行内同时包括左中右对齐的文本</h1>
<pre class="line-numbers"><code class="language-latex">\newcommand&#123;\headerline&#125;[3]&#123;
    \par\medskip\noindent
    \makebox[\textwidth][s]&#123;\rlap&#123;#1&#125;\hfill#2\hfill\llap&#123;#3&#125;&#125;%
    \par\medskip
&#125;
% 用例：
\headerline&#123;•栏目•&#125;&#123;doi: 10.3866/PKU.DXHX20xxxxxxx&#125;&#123;www.dxhx.pku.edu.cn&#125;</code></pre>
<h1 id="在表格环境内改变表线宽度">在表格环境内改变表线宽度</h1>
<p>鉴于许多办法可能不适用于除<code>tabular</code>之外的环境，这里提供一个简单粗暴的办法：</p>
<pre class="line-numbers"><code class="language-latex">\setlength&#123;\doublerulesep&#125;&#123;0pt&#125;
...

\hline\hline % 两倍标准线宽</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/JuliaPlots/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/JuliaPlots/" class="post-title-link" itemprop="url">让Plots.jl支持中文标题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-01-22 07:25:20" itemprop="dateModified" datetime="2020-01-22T07:25:20-05:00">2020-01-22</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Julia Plots啥都好，就是原生对于Unicode的支持还不完善（可见用Julia的国人似乎不多）。这篇文章简要汇总一下几个不同的backend对于中文的workaround。</p>
<h1 id="gr-backend">GR Backend</h1>
<p>GR在支持Unicode字符上进展感觉其实不积极。具体可以看<a target="_blank" rel="noopener" href="https://github.com/jheinen/GR.jl/issues/143">这个issue</a>，修了一年还是没有比较好的成果（作者说是一个extensive patch...估计一开始在架构里写死了），只修到了支持Latin-1的地步，目前提供的临时解决方案是：</p>
<pre class="line-numbers"><code class="language-julia">ENV[&quot;GKS_ENCODING&quot;]=&quot;utf-8&quot;
using Plots</code></pre>
<p>在Windows上实测对于png格式的图片还是不行，但是对于SVG是可以的（但是因为计算布局的时候字符串长度算的是有问题的，所以legend的框会偏小）。</p>
<h1 id="pyplot-backend">PyPlot Backend</h1>
<p>PyPlot背后调用的是matplotlib，因此PyPlot默认对于中文的支持不利主要也来自于matplotlib对中文的支持问题。对于后者网上改<code>rcParams</code>的解决方案已经比较普及了。在Julia里面，我们只需要把<code>rcParams</code>暴露出来改就行了：</p>
<pre class="line-numbers"><code class="language-julia">using Plots
pyplot()
rcParams = Plots.PyCall.PyDict(Plots.PyPlot.matplotlib.&quot;rcParams&quot;)
rcParams[&quot;font.sans-serif&quot;] = [&quot;Sarasa UI SC&quot;]
rcParams[&quot;axes.unicode_minus&quot;] = false</code></pre>
<p>其中的<code>"Sarasa UI SC"</code>可以替换成电脑上安装的中文字体。这样中文标题就一点问题也没有了，但是似乎在Juno里面PyPlot画出来的图不会自动缩放，令强迫症稍微感到一丝不适。</p>
<h1 id="plotlyjs-backend">PlotlyJS Backend</h1>
<p>原生支持。</p>
<h1 id="inspectdr-backend">InspectDR Backend</h1>
<p>原生支持。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/KCP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/KCP/" class="post-title-link" itemprop="url">Rust实现带BBR的高效魔改KCP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-02-02 08:21:02" itemprop="dateModified" datetime="2021-02-02T08:21:02-05:00">2021-02-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>完整的代码<a target="_blank" rel="noopener" href="https://github.com/alan20210202/ekho/blob/e2c24b4504/src/kcp.rs">在此</a>。</p>
<h1 id="背景">背景</h1>
<p>最近我在用Rust写一个ICMP隧道，因为ICMP包本身是不可靠的，于是需要在ICMP之上写一个可靠协议。一个完整的TCP协议栈显然过于臃肿了（何况也并没有现成的无IO的轮子），所以我就看上了skywind3000大佬的<a target="_blank" rel="noopener" href="https://github.com/skywind3000/kcp">KCP协议</a>——轻量、简洁、代码连我这种网路萌新都看得懂，实在是再好不过了。</p>
<p>一开始是我直接使用原版的C实现+FFI封装，在不开流控的情况下效果不错，但可惜原版的拥塞控制用的是最朴素的TCP Tahoe（作者也表明出于简洁性考虑不准备在标准实现当中使用复杂的流控算法），其在国际网络环境下的表现实在差强人意。想改进，但自己对于自己C的编程水平实在是不抱信心。既然Rust也是性能一流的系统编程语言，我最终还是决定用Rust再写了一个实现。本实现具有以下特点：</p>
<ul>
<li>相较于C实现进行了架构上的些许调整。</li>
<li>在C实现的基础之上，使用链表+滚动数组优化大窗口下的发送性能。</li>
<li>在C实现的基础之上，使用小根堆优化RTO计时器的效率，提升重传性能。</li>
<li>将著名的BBR拥塞控制算法进行一定修改后试验性地运用到KCP中。</li>
</ul>
<h1 id="依赖的包">依赖的包</h1>
<p>为了使编写更加简便，我们的实现依赖以下Rust crates：</p>
<ul>
<li><code>bytes</code>——简便的字节处理（代替原来C实现当中的<code>encode_xxx</code>/<code>decode_xxx</code>）。</li>
<li><code>num_enum</code>——简化Rust枚举与字节的互相转换。</li>
<li><code>derivative</code>——简化一些trait的实现。</li>
<li><code>thiserror</code>——简化错误类型的定义。</li>
<li><code>rand</code>——用于BBR随机相位初始化。</li>
</ul>
<h1 id="架构上的调整">架构上的调整</h1>
<h2 id="常量与配置">常量与配置</h2>
<p>相对于C实现，本实现大幅减少了常量的数量。最后仅剩的常量有五：</p>
<pre class="line-numbers"><code class="language-rust">/// KCP包头大小
const OVERHEAD: u32 = 24;
/// 最大分段
const MAX_FRAGMENTS: u16 = 128;
/// KCP段类型
#[derive(Debug, Clone, Copy, TryFromPrimitive, IntoPrimitive)]
#[repr(u8)]
enum Command &#123;
    Push = 81,
    Ack = 82,
    AskWnd = 83,
    TellWnd = 84,
&#125;
/// BBR各阶段的增益
const BBR_GAIN_CYCLE: [usize; 8] = [5, 3, 4, 4, 4, 4, 4, 4];
/// BDP增益的分母，见后文
const BDP_GAIN_DEN: usize = 1024;</code></pre>
<p>常量少了，变量自然就多了，原来C实现的常量在本实现中成为可配置项：</p>
<pre class="line-numbers"><code class="language-rust">/// 大部分配置的意思如字面
#[derive(Clone, Debug, Deserialize, Derivative)]
#[derivative(Default)]
pub struct Config &#123;
    #[derivative(Default(value = &quot;536&quot;))]
    pub mtu: u32,
    #[derivative(Default(value = &quot;200&quot;))]
    pub rto_default: u32,
    #[derivative(Default(value = &quot;100&quot;))]
    pub rto_min: u32,
    #[derivative(Default(value = &quot;6000&quot;))]
    pub rto_max: u32,
    #[derivative(Default(value = &quot;7000&quot;))]
    pub probe_min: u32,
    #[derivative(Default(value = &quot;120000&quot;))]
    pub probe_max: u32,
    #[derivative(Default(value = &quot;1024&quot;))]
    pub send_wnd: u16,
    #[derivative(Default(value = &quot;1024&quot;))]
    pub recv_wnd: u16,
    #[derivative(Default(value = &quot;40&quot;))]
    pub interval: u32,
    /// 若一个包重传dead_link_thres次后依然失败，则视作底层链路失效。
    #[derivative(Default(value = &quot;20&quot;))]
    pub dead_link_thres: u32,
    /// nodelay模式下, rto_min = 0且rto在重传失败后不指数增长。
    #[derivative(Default(value = &quot;false&quot;))]
    pub nodelay: bool,
    /// stream模式下, 多个数据包可以被合并在同一段内从而减少开销。
    #[derivative(Default(value = &quot;false&quot;))]
    pub stream: bool,
    /// 如果指定，则一个包在fast_resend_thres个在其之后的包ACK之后会直接重传
    #[derivative(Default(value = &quot;None&quot;))]
    pub fast_resend_thres: Option&lt;u32&gt;,
    /// 快速重传的次数上限
    #[derivative(Default(value = &quot;None&quot;))]
    pub fast_resend_limit: Option&lt;u32&gt;,
    /// 是否启用BBR控制算法
    #[derivative(Default(value = &quot;false&quot;))]
    pub bbr: bool,
    /// BBR中RTprop（往返时间）滑动窗口的时间长度（单位：毫秒）
    #[derivative(Default(value = &quot;10000&quot;))]
    pub rt_prop_wnd: u32,
    /// BBR中BtlBw（瓶颈带宽）滑动串口的长度（单位：RTT）
    #[derivative(Default(value = &quot;10&quot;))]
    pub btl_bw_wnd: u32,
    /// BBR中一次RTT/RTprop探测的时间（单位：RTT），减少该值可以减轻RTT探测对于流量的影响。
    #[derivative(Default(value = &quot;200&quot;))]
    pub probe_rtt_time: u32,
    /// BDP增益，见后文
    #[derivative(Default(value = &quot;1024&quot;))]
    pub bdp_gain: usize,
&#125;

impl Config &#123;
    pub fn mss(&amp;self) -&gt; usize &#123;
        (self.mtu - OVERHEAD) as usize
    &#125;
&#125;

impl ControlBlock &#123;
    pub fn new(conv: u32, config: Config) -&gt; ControlBlock &#123;
        ...
    &#125;
&#125;</code></pre>
<h2 id="异常类型">异常类型</h2>
<p>KCP原本的C实现仅使用负数表达异常值，虽简介但其含义并不明晰，在本实现中我们对于异常进行了清晰定义：</p>
<pre class="line-numbers"><code class="language-rust">#[derive(Debug, Error)]
pub enum Error &#123;
    #[error(&quot;packet to be sent too large to be fragmented&quot;)]
    OversizePacket,
    #[error(&quot;incomplete KCP packet&quot;)]
    IncompletePacket,
    #[error(&quot;invalid KCP command: &#123;0&#125;&quot;)]
    InvalidCommand(u8),
    #[error(&quot;empty queue (try again later)&quot;)]
    NotAvailable,
    #[error(&quot;wrong conv. (expected &#123;expected&#125;, found &#123;found&#125;)&quot;)]
    WrongConv &#123; expected: u32, found: u32 &#125;,
&#125;

pub type Result&lt;T&gt; = std::result::Result&lt;T, Error&gt;;</code></pre>
<p>以上异常类型还有更精确的空间，但是目前应该已经堪堪够用了。</p>
<h2 id="发包方式">发包方式</h2>
<p>在原来的C实现在发包时直接调用callback，其优点是简洁，但其缺点在于callback的运行时间不定以及异常处理不明对运行产生的影响。<del>何况在Rust当中安全存储callback需要和borrow checker拼命。</del>在本实现中，我们将flush出去的包暂存在一个队列中，然后通过外部不断poll的方式拉出去。一方面，主动poll的方式和底层收到包时的push呼应；另一方面，这有助于分离底层发包和KCP逻辑本身，是“<a target="_blank" rel="noopener" href="https://sans-io.readthedocs.io/">无IO/Sans IO</a>”理念的一种体现。缺点是缓存队列可能会膨胀得厉害。当中tradeoff见仁见智。</p>
<pre class="line-numbers"><code class="language-rust">impl ControlBlock &#123;
    ...
    /// 底层收包push
    pub fn input(&amp;mut self, mut data: &amp;[u8]) -&gt; Result&lt;usize&gt; &#123; ... &#125;
    /// 底层发包poll
    pub fn output(&amp;mut self) -&gt; Option&lt;Vec&lt;u8&gt;&gt; &#123; ... &#125;
&#125;</code></pre>
<h2 id="去除check和update">去除<code>check</code>和<code>update</code></h2>
<p>这是一个比较大胆的改动，未必适合所有情形。去除的原因是在数据结构的优化下计算重传、更新发送窗口的开销大幅度减小，已经可以在每一次调用<code>input</code>和<code>send</code>的时候进行一次，没有必要去不断<code>check</code>再<code>update</code>。上层只需要按照固定的时间间隔调用<code>flush</code>就行了。我进行这样的设计是为了简化上层的代码，而且我的应用情形恰好是高流量的反正都要一直<code>flush</code>，也无所谓。</p>
<p><code>flush</code>的代码也其实很简单：</p>
<pre class="line-numbers"><code class="language-rust">pub fn flush(&amp;mut self) &#123;
    self.sync_now(); // 更新now
    self.flush_probe(); // 更新窗口探测
    self.flush_push(); // 计算重传以及更新发送窗口
    self.flush_ack(); // 发ACK
    if !self.buffer.is_empty() &#123;
        let mut new_buf = Vec::with_capacity(self.config.mtu as usize);
        std::mem::swap(&amp;mut self.buffer, &amp;mut new_buf);
        self.output.push_back(new_buf);
    &#125;
&#125;</code></pre>
<p>既然<code>sync_now</code>、<code>flush_push</code>在<code>input</code>和<code>send</code>当中都可以廉价地调用，那为什么还需要不断<code>check</code>再<code>update</code>呢？直接调用<code>flush</code>了事。</p>
<p>如果要参考有<code>check</code>和<code>update</code>的实现，可以参照<a target="_blank" rel="noopener" href="https://github.com/alan20210202/ekho/blob/caaeb5f55d/src/kcp.rs">早些时候的commit</a>。</p>
<h1 id="窗口数据结构的改进">窗口数据结构的改进</h1>
<p>KCP原版的实现中发送/接收的队列/窗口全部使用队列作为数据结构，这固然使得代码变简单了，但也一定程度上降低了性能：在队列中查找KCP段最差需要线性时间，这在某些情形下未必是最优的。在本实现中，我们优化数据结构，以最优的复杂度实现发送/接受窗口需要的若干操作：</p>
<ul>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>以分段的序号为键查找分段。</li>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>插入分段。</li>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>以分段的序号为键查找分段。</li>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>以分段的序号为键删除分段。</li>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>查询/弹出最早插入的分段（在发送窗口中，最早插入的分段自然是序号最小的分段）。</li>
<li><span class="math inline">\(\mathcal{O}(k)\)</span>遍历以插入顺序为序，某分段的所有<span class="math inline">\(k\)</span>个前驱（在发送窗口中，分段插入顺序即序号顺序，因此该操作可直接用于快速重传的计算）。</li>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>查询大小。</li>
</ul>
<p>考虑到任何时刻窗口内分段序号之差不会大于窗口大小这一常数，符合上述要求的数据结构就可以用链表+滚动数组高效实现。代码不长，百行左右：</p>
<pre class="line-numbers"><code class="language-rust">struct Element&lt;T&gt; &#123;
    /// 前驱下标
    prev: usize,
    /// 后继下标
    next: usize,
    data: T,
&#125;

pub struct Window&lt;T&gt; &#123;
    size: usize,
    entry: Vec&lt;Option&lt;Element&lt;T&gt;&gt;&gt;,
    end: Option&lt;usize&gt;,
    len: usize,
&#125;

impl&lt;T&gt; Window&lt;T&gt; &#123;
    pub fn with_size(size: usize) -&gt; Self &#123;
        Self &#123;
            size,
            entry: (0..size).map(|_| None).collect(),
            end: None,
            len: 0,
        &#125;
    &#125;

    pub fn is_empty(&amp;self) -&gt; bool &#123;
        self.end.is_none()
    &#125;

    pub fn get_mut(&amp;mut self, index: usize) -&gt; Option&lt;&amp;mut T&gt; &#123;
        match self.entry[index % self.size].as_mut() &#123;
            Some(elem) =&gt; Some(&amp;mut elem.data),
            None =&gt; None,
        &#125;
    &#125;

    pub fn push(&amp;mut self, index: usize, data: T) &#123;
        let index = index % self.size;
        if self.entry[index].is_some() &#123;
            return;
        &#125;
        self.entry[index] = Some(match self.end &#123;
            Some(prev) =&gt; &#123;
                let prev_elem = self.entry[prev].as_mut().unwrap();
                let next = prev_elem.next;
                prev_elem.next = index;
                self.entry[next].as_mut().unwrap().prev = index;
                Element &#123; prev, next, data &#125;
            &#125;
            None =&gt; Element &#123; prev: index, next: index, data &#125;,
        &#125;);
        self.end = Some(index);
        self.len += 1;
    &#125;

    pub fn remove(&amp;mut self, index: usize) -&gt; Option&lt;T&gt; &#123;
        let index = index % self.size;
        let elem = self.entry[index].take()?;
        let (prev, next) = (elem.prev, elem.next);
        self.entry[index] = None;
        self.len -= 1;
        if index == self.end.unwrap() &#123;
            if prev == index &#123;
                self.end = None;
                return Some(elem.data);
            &#125; else &#123;
                self.end = Some(prev);
            &#125;
        &#125;
        self.entry[prev].as_mut().unwrap().next = next;
        self.entry[next].as_mut().unwrap().prev = prev;
        Some(elem.data)
    &#125;

    pub fn front(&amp;self) -&gt; Option&lt;&amp;T&gt; &#123;
        self.end.map(|end| &#123;
            let head = self.entry[end].as_ref().unwrap().next;
            &amp;self.entry[head].as_ref().unwrap().data
        &#125;)
    &#125;

    pub fn pop_unchecked(&amp;mut self) -&gt; T &#123;
        let end = self.end.unwrap();
        let head = self.entry[end].as_ref().unwrap().next;
        self.remove(head).unwrap()
    &#125;

    pub fn len(&amp;self) -&gt; usize &#123;
        self.len
    &#125;

    pub fn for_preceding(&amp;mut self, index: usize, mut action: impl FnMut(&amp;mut T)) &#123;
        let mut index = index % self.size;
        index = match self.entry[index].as_ref() &#123;
            Some(elem) =&gt; elem.prev,
            None =&gt; return,
        &#125;;
        while index != self.end.unwrap() &#123;
            let elem = self.entry[index].as_mut().unwrap();
            action(&amp;mut elem.data);
            index = elem.prev;
        &#125;
    &#125;
&#125;</code></pre>
<p>因为滚动数组是连续空间，在内存布局上相较于链表对于缓存更加友好，所以速度应该还可以再快一点。唯一的不足是<code>unwrap</code>有点多看着心惊肉跳，并且用指针可能会比用下标快一丁点，但是用Rust写数据结构大约就是这个尿性。</p>
<p>有这个打底，窗口大小开到8192实测是一点问题都没有的，更大的没试过。</p>
<p>但KCP的设计本质上是不适合大流量的，因为快速重传无论如何优化数据结构最坏的线性复杂度就在那里无法消除，除非可以限制快速重传向后看的范围，但后者又削弱了快速重传的意义与效用。</p>
<h1 id="重传计时器的改进">重传计时器的改进</h1>
<p>原版的KCP实现在<code>check</code>的时候需要遍历发送窗口来确定最近的重传时间，在<code>flush</code>的时候又要遍历才能重传，这在窗口较大的时候显然是比较吃性能的。原作者记得在issues里的讨论中提过可以用时间轮进行优化。诚然，时间轮是最好的方案，但是实现起来较为复杂。因此，本实现使用借助Rust的标准库实现起来相对简单的小根堆进行优化：</p>
<pre class="line-numbers"><code class="language-rust">use std::cmp::Reverse;
use std::collections::BinaryHeap;

pub struct Timer(BinaryHeap&lt;Reverse&lt;u64&gt;&gt;);

impl Timer &#123;
    pub fn with_capacity(capacity: usize) -&gt; Self &#123;
        Self(BinaryHeap::with_capacity(capacity))
    &#125;

    pub fn schedule(&amp;mut self, ts: u32, sn: u32) &#123;
        self.0.push(Reverse(((ts as u64) &lt;&lt; 32) | sn as u64));
    &#125;

    /// 获取截止到now发生的 一个 事件，应该重复调用
    pub fn event(&amp;mut self, now: u32) -&gt; Option&lt;(u32, u32)&gt; &#123;
        let key = (now as u64 + 1) &lt;&lt; 32;
        match self.0.peek() &#123;
            Some(&amp;Reverse(val)) if val &lt; key =&gt; &#123;
                let sn = val &amp; (u32::max_value() as u64);
                let ts = val &gt;&gt; 32;
                self.0.pop();
                Some((ts as u32, sn as u32))
            &#125;
            _ =&gt; None,
        &#125;
    &#125;
&#125;</code></pre>
<p>计时器只需要存时间和分段序号即可。调用的代码如下：</p>
<pre class="line-numbers"><code class="language-rust">fn flush_push(&amp;mut self) &#123;
    // ... 省去流控以及把队列里的分段加入发送窗口的部分
    let mut send_buf = std::mem::take(&amp;mut self.send_buf);
    while let Some((ts, sn)) = self.timer.event(self.now) &#123;
        if sn &lt; self.send_una || sn &gt;= self.send_nxt &#123;
            continue; // 分段被ACK于是不在发送窗口里了，自然跳过
        &#125;
        if let Some(seg) = send_buf.get_mut(sn as usize) &#123;
            if ts == seg.ts &#123;
                seg.ts = self.prepare_send(seg); // 更新RTO并计算下一次重传的时间
                seg.ts_last_send = ts;
                self.dead_link |= seg.sends &gt;= self.config.dead_link_thres;
                self.flush_segment(Command::Push, seg.frg, seg.sn, ts, seg.payload.len());
                self.buffer.extend_from_slice(&amp;seg.payload);
                self.timer.schedule(seg.ts, seg.sn); // 安排下一次重传
            &#125;
        &#125;
    &#125;
    self.send_buf = send_buf;
&#125;</code></pre>
<p>由于查看小根堆堆顶是<span class="math inline">\(\mathcal{O}(1)\)</span>的，因此在没有重传的时候<code>flush_push</code>的开销确实很小。足以在<code>input</code>和<code>send</code>时都调用一次。真的要重传时，更新小根堆的时间复杂度也是对数级别的，这就给去除<code>check</code>和<code>update</code>提供了基础。</p>
<h1 id="bbr">BBR</h1>
<p>最后的改进是用BBR取代了KCP原版实现中朴素的基于丢包的流控算法。</p>
<p>我试图参照<a target="_blank" rel="noopener" href="https://research.google/pubs/pub45646/">原论文</a>实现BBR，但因为计时精度的问题packet pacing是做不到了。实现的部分有</p>
<ul>
<li>基于单调队列的滑动窗口BtlBw max-filter。</li>
<li>基于单调队列的滑动窗口RTprop min-filter。</li>
<li>BBR状态机。</li>
<li>基于以上三者计算inflight limit进行流控。</li>
</ul>
<p>和BBR有分歧的一点在于在ProbeRTT状态采用BDP的一半作为拥塞窗口而不是原文的4个包。</p>
<p>此外，本实现只对只传输一次的分段计算BBR的各项参数，如RTT，带宽，更新各个filter等。原因是实际上大部分的分段都在看到包头的UNA之后就被ACK掉了而不是被单独的ACK包ACK的。ACK包带有分段的序号与时间戳，所以可以清楚知道ACK的是哪一次传输，但被UNA ACK掉的就不清楚，唯一的例外是分段只被传输了一次。如果对于多次传输的包仍然直接计算BBR，那么万一ACK恰好在重传之后到达，那么误算出的RTT就非常小，导致RTprop非常小，进而BDP非常小，整个BBR就堵住了。诚然，可以把每一次传输的时间戳都存起来，然后在被UNA时选择最接近<code>now - srtt</code>的传输，但这就增加了代码的复杂度。考虑到丢包的毕竟是少数，如此未必会有特别大的优势（实现这个的代码在这个<a target="_blank" rel="noopener" href="https://github.com/alan20210202/ekho/blob/01b1d72b7e/src/kcp.rs">commit</a>，也可作为参考）。</p>
<p>实测效果还行。一个比较重要的问题是在间歇性<code>flush</code>的情况下对于带宽的计算并不准确甚至有低估的倾向，往往导致BDP过于保守，即使ProbeBW状态有一个1.25x的激进phase也解决不了问题。我想到的一个解决方案是将拥塞窗口不是简单的设置为BDP，而是乘上一个增益，也就是配置里面的<code>bdp_gain</code>。为了避免浮点数运算，<code>bdp_gain</code>使用1024为基数。一般来说设置成1280就差不多了——其实就是主动创造轻微的拥塞来确保占有带宽。这对于其他的TCP连接固然有些不公平的，是否采用见仁见智。</p>
<h1 id="真背景">真·背景</h1>
<p>其实一开始，只是为了编译的时候能够不带着<code>unsafe</code>和C编译器而选择把原版实现移植到Rust，当时代码大部分几乎一模一样。</p>
<p>后来引入BBR魔改了一回。</p>
<p>为了代码更Rust魔改了一回。</p>
<p>再后来做配置分离魔改了一回。</p>
<p>再后来数据结构优化又魔改了一回。</p>
<p>来来回回地改，到最后除了架子还和原版实现相似，内部的代码已经大变样了。</p>
<p>但是在ICMP隧道上试验下来仍然不是最令人满意，CPU占用仍然不少，带宽仍然不能跑满，goodput仍然不高。</p>
<p>我不知道是我应用层以及底层的代码写的有问题，还是KCP本身就不是很适合高流量大窗口的应用场景。</p>
<p>或许二者兼有之？</p>
<p>前两天突然想起了QUIC，找了一下，Cloudflare有一个优秀的QUIC实现，是Rust的，而且是Sans IO的。大概QUIC才是最适合我的应用情形的吧。我准备这几天试验一下。</p>
<p>或许之后就转QUIC了呢？（笑）</p>
<p>那我魔改的KCP就放在这吃灰？</p>
<p>于是乎，就有了这篇文章。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/IceBoat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/IceBoat/" class="post-title-link" itemprop="url">从技术角度看Minecraft的高级冰船技术</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-04-17 10:43:44" itemprop="dateModified" datetime="2020-04-17T10:43:44-04:00">2020-04-17</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景">背景</h1>
<p>最近比较无聊，偶尔会和同学们一起在Minecraft的私服上玩一会，现在地狱交通已经初见雏形了，nether hub已经搭好了，然而地狱交通网络应该基于哪一种运输方式还没有确定。常见的快速运输方式有两种：piston bolt和冰船。</p>
<p>很显然按照每天半个小时的游戏时间是不可能有精力做双向的piston bolt的，况且论最高速度冰船比piston bolt还是快上许多的，因此几乎毫无疑议地大家都选择了冰船。</p>
<p>这篇文章是在代码角度对于高级冰船技术的分析。</p>
<p>全文的代码均为使用官方mapping以及CFR编译器进行反编译所得（但愿这并不违反EULA）。</p>
<h1 id="带方向校准的高端冰船">带方向校准的高端冰船</h1>
<p>冰船系统一直为人所诟病，也是其不如piston bolt的一点是：它在运动中是需要玩家控制的。不仅要一直按着W，还要使用AD确保船头一直向前。这在直道冰船上还好，但在斜线冰船道上就非常非常麻烦。</p>
<p>幸好，Rays Works在几个月前分享了<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=hiQTnwqrfEU">解决方案</a>。其方案的思想是：</p>
<p>如果一开始船就放正，那么就只需要W而不需要左右调整了！</p>
<p>那怎么把船放正呢？</p>
<p>观察一下代码（<code>net/minecraft/world/item/BoatItem</code>）：</p>
<pre class="line-numbers"><code class="language-java">@Override
public InteractionResultHolder&lt;ItemStack&gt;use(Level level, Player player, InteractionHand interactionHand) &#123;
    Object object;
    ItemStack itemStack = player.getItemInHand(interactionHand);
    HitResult hitResult = BoatItem.getPlayerPOVHitResult(level, player, ClipContext.Fluid.ANY);
    ...
    if (hitResult.getType() == HitResult.Type.BLOCK) &#123;
        object = new Boat(level, hitResult.getLocation().x, hitResult.getLocation().y, hitResult.getLocation().z);
        ((Boat) object).setType(this.type);
        ((Boat) object).yRot = player.yRot; // !
        ...
        return InteractionResultHolder.success(itemStack);
    &#125;
    return InteractionResultHolder.pass(itemStack);
&#125;</code></pre>
<p><code>yRot</code>自然是Y-axis Rotation的意思，也就是说放下船的方向直接等于当时玩家的视角方向。</p>
<p>因此如果一开始视角方向， 那么问题就解决了！</p>
<p>如何确保每一次放船的时候视角方向都是一个固定值呢？</p>
<p>Rays Works的解决方案是：用另外一艘船！</p>
<p>在<code>net/minecraft/client/player/LocalPlayer</code>当中：</p>
<pre class="line-numbers"><code class="language-java">@Override
public boolean startRiding(Entity entity, boolean bl) &#123;
    if (!super.startRiding(entity, bl)) &#123;
        return false;
    &#125;
    ...
    if (entity instanceof Boat) &#123; // !!!
        this.yRotO = entity.yRot;
        this.yRot = entity.yRot;
        this.setYHeadRot(entity.yRot);
    &#125;
    return true;
&#125;</code></pre>
<p>可以看到，当玩家乘上船的一瞬间，玩家的视角方向会强制调整到船的方向。</p>
<p>因此我们只需要准备一艘校准船，确保这艘船的角度正确，之后要使用的时候直接先做上这艘船再立刻放船再坐上新放的船就可以了（简单来说就是三连右键）。</p>
<p>这就是Rays Works视频的主旨，我这里只是找到了对应的源代码而已。</p>
<h1 id="放置角度与minecraft的角度系统">放置角度与Minecraft的角度系统</h1>
<p>Rays Works在视频当中宣称通过它的方法可以把冰道修到任何角度与朝向。</p>
<p>似乎没有什么不对？只要把校准船放到任意角度就行了。</p>
<p>然而在Ray的视频当中可以看到，有的时候明明船放下去是45°，不一会就转到了46.4°，Ray坦言这是这套冰船系统唯一比较麻烦的地方。Ray提出的解决方案是：</p>
<blockquote>
<p>If that happens, just remove this boat and place in a new one. ……and do it a couple times it actually fixes itself.</p>
</blockquote>
<p>并认为这是一个随机行为，具有一定意义上的周期性，等一会就好了。</p>
<p>事实并非如此。有一些角度是无论如何都放不到的，刚放下去一会就会微微一转，然后角度就变了。属实糟心，我在自己服务器里面放了20次都没有放成功。那个时候我终于意识到Ray的claim可能是在扯淡，于是去看了下代码。</p>
<p>代码里面似乎没有任何一处体现了“微微一转”这种行为。最上面<code>BoatItem</code>的代码就是直接把<code>yRot</code>设成了玩家的<code>yRot</code>。我用全文搜索对于<code>yRot</code>产生修改的片段，没有一处是这样的。<code>yRot</code>是用<code>float</code>存储的，应该不会产生舍入误差这种事情。</p>
<p>整个事情让我对于Minecraft的屎山代码不由生出一份敬畏，我开始觉得这是玄学问题，直到看见<code>net/minecraft/network/protocol/game/ClientboundAddEntityPacket</code>的构造函数……</p>
<pre class="line-numbers"><code class="language-java">public class ClientboundAddEntityPacket implements Packet&lt;ClientGamePacketListener&gt; &#123;
    ...
    private int xRot;
    private int yRot;

    public ClientboundAddEntityPacket(int n, UUID uUID, double d, double d2, double d3, float f, float f2, EntityType&lt;?&gt; entityType, int n2, Vec3 vec3) &#123;
        ...
        this.xRot = Mth.floor(f * 256.0f / 360.0f);
        this.yRot = Mth.floor(f2 * 256.0f / 360.0f);
        ...
    &#125;
&#125;</code></pre>
<p>以及<code>net/minecraft/client/multiplayer/PacketListener</code>如何处理这个packet的:</p>
<pre class="line-numbers"><code class="language-java"> @Override
 public void handleAddEntity(ClientboundAddEntityPacket clientboundAddEntityPacket) &#123;
     Entity entity;
     ...
     if (entity != null) &#123;
         entity.xRot = (float)(clientboundAddEntityPacket.getxRot() * 360) / 256.0 f;
         entity.yRot = (float)(clientboundAddEntityPacket.getyRot() * 360) / 256.0 f;
         ...
     &#125;
 &#125;</code></pre>
<p>哦……原来还真有舍入误差这回事……Mojang大概想省空间，虽然rotation在客户端和服务端内部都是<code>float</code>存储的，但是在网络传输的时候硬是塞到了<code>byte</code>里面。于是在这一层转换的帮助下，Minecraft理论上就只有256种可能的角度了。</p>
<p>我猜测的整个放船的流程大致如下：</p>
<ol type="1">
<li>客户端玩家手持船右键</li>
<li>客户端发出一个<code>ServerboundUseItemPacket</code></li>
<li>服务端接收到<code>ServerboundUseItemPacket</code>，然后执行<code>BoatItem</code>有关的代码</li>
<li>服务端新增船的实体，想客户端发送<code>ClientboundAddEntityPacket</code>，这个时候角度被舍入了</li>
<li>客户端收到<code>ClientboundAddEntityPacket</code>，将本地的船同步为舍入的角度，在10gt的插值作用下体现为“微微一转”</li>
<li>玩家坐上去，这个时候一系列网络同步把服务端的船的角度也舍入了</li>
</ol>
<pre class="line-numbers mermaid"><code class="language-none">sequenceDiagram
    participant Client
    participant Server
    Note left of Client: Player right clicks
    Client-&gt;&gt;Server: ServerboundUseItemPacket
    Note right of Server: Execute code in &lt;br/&gt; BoatItem.use
    Server-&gt;&gt;Client: ClientboundAddEntityPacket</code></pre>
<p>因此，微微一转的问题其实根本就不是Ray说的随机事件，而是在网络传输当中舍入误差加上客户端线性插值带来的现象。看似的随机只是因为F3的精度不够，44.99和45.01都显示为45.0，虽然从代码当中我们可以清晰地看到两个数的舍入结果是不一样的。</p>
<p>这么做的好处是对于90°，45°等特殊角这一层舍入可以保证绝对的精确，避免了放成45.01°然后在船上开1000格偏离航道的惨剧。缺点是很多角度就不能精确达到了。两个相邻的可达角度差1.40625°，大概勉强可以接受。</p>
<p>话又说回来了，<code>ServerboundMovePlayerPacket</code>这种同步玩家信息倒是还是用<code>float</code>作为载体的。所以玩家的角度还是很精确的？难道是因为玩家相对于实体少很多所以有更多流量可以挥霍？</p>
<p>我再次对于Minecraft的代码肃然起敬。</p>
<h1 id="辅助高级冰船的scarpet脚本">辅助高级冰船的Scarpet脚本</h1>
<p>在知道这些之后我们就可以有针对性地设计冰道了，因为人比较懒所以我写了一个scarpet的脚本：</p>
<pre class="line-numbers"><code class="language-none">__command() -&gt; null;

_ice_mark(x, y, z) -&gt; create_marker(&#39;ICE&#39;, l(x + 0.5, y + 0.5, z + 0.5));

_mark_x(y, x1, z1, x2, z2, w) -&gt; (
    if(x1 &gt; x2, l(x1, x2, z1, z2) = l(x2, x1, z2, z1));
    k = (z2 - z1) / (x2 - x1);
    for(range(x1, x2 + 1),
        x = _; z = round((x - x1) * k + z1);
        for(range(-w + 1, w), _ice_mark(x, y, z + _))
    )
);

_mark_z(y, x1, z1, x2, z2, w) -&gt; (
    if(z1 &gt; z2, l(x1, x2, z1, z2) = l(x2, x1, z2, z1));
    k = (x2 - x1) / (z2 - z1);
    for(range(z1, z2 + 1),
        z = _; x = round((z - z1) * k + x1);
        for(range(-w + 1, w), _ice_mark(x + _, y, z))
    )
);

mark(y, x1, z1, x2, z2, w) -&gt; (
    dx = abs(x1 - x2); dz = abs(z1 - z2);
    if(dx == 0 || dx &lt; dz, _mark_z(y, x1, z1, x2, z2, w),
        _mark_x(y, x1, z1, x2, z2, w))
);

clear() -&gt; remove_all_markers();

_wrap_deg(x) -&gt; (
    tmp = x % 360.0;
    if(tmp &lt; -180, tmp + 360, tmp &gt; 180, tmp - 360, tmp)
);

_wrap_internal(x) -&gt; (
    tmp = x % 360.0;
    if (tmp &lt; 0, tmp + 360, tmp)
);

_angle(x1, z1, x2, z2) -&gt; -atan2(x2 - x1, z2 - z1);

_floor_angle(x) -&gt; _wrap_deg(floor(x * 256 / 360.0) * 360 / 256);

angle(x1, z1, x2, z2) -&gt; (
    theta = _angle(x1, z1, x2, z2);
    print(str(&#39;exact yaw: %f&#39;, theta));
    lb = floor_angle(_wrap_internal(theta));
    ub = floor_angle(_wrap_internal(theta + 360.0 / 256));
    print(str(&#39;floored yaw (lb): %f&#39;, lb));
    print(str(&#39;floored yaw (ub): %f&#39;, ub));
    ret = if(abs(lb - theta) &lt; abs(ub - theta), lb, ub);
    print(str(&#39;suggested yaw: %f&#39;, ret));
);

_best_angle(x1, z1, x2, z2) -&gt; (
    theta = _angle(x1, z1, x2, z2);
    lb = floor_angle(_wrap_internal(theta));
    ub = floor_angle(_wrap_internal(theta + 360.0 / 256));
    if(abs(lb - theta) &lt; abs(ub - theta), lb, ub)
);

adjust(x1, z1, x2, z2, dir) -&gt; (
    x = _best_angle(x1, z1, x2, z2);
    ov = 360; opt = 0;
    print(str(&#39;yaw: %f&#39;, x));
    if(
        dir == &#39;x&#39;,
        for(range(x2 - 1000, x2 + 1000), 
            tmp = abs(_angle(x1, z1, _, z2) - x);
            if (tmp &lt; ov, ov = tmp; opt = _)
        );
        print(str(&#39;%f %f %f %f&#39;, x1, z1, opt, z2)),
        dir == &#39;z&#39;,
        for(range(z2 - 1000, z2 + 1000), 
            tmp = abs(_angle(x1, z1, x2, _) - x);
            if (tmp &lt; ov, ov = tmp; opt = _)
        );
        print(str(&#39;%f %f %f %f&#39;, x1, z1, x2, opt)),
        print(&#39;direction must either be x or z&#39;)
    )
)</code></pre>
<p>用法如下：</p>
<ol type="1">
<li><p><code>/iceboat y x1 z1 x2 z2 w</code>标记一条从<span class="math inline">\((x_1,y,z_1)\)</span>到<span class="math inline">\((x_2,y,z_2)\)</span>的，宽度为<span class="math inline">\(2w-1\)</span>的冰道。</p></li>
<li><p><code>/iceboat clear</code>清除标记。</p></li>
<li><p><code>/iceboat angle x1 z1 x2 z2</code>计算站在<span class="math inline">\((x_1,z_1)\)</span>望向<span class="math inline">\((x_2,z_2)\)</span>的视角方向，最近的两个可达角度，以及推荐的可达角度。</p></li>
<li><p><code>/iceboat adjust x1 z1 x2 z2 x/z</code>固定<span class="math inline">\((x_1,z_1)\)</span>，沿<span class="math inline">\(x/z\)</span>轴在<span class="math inline">\((x_2,z_2)\)</span>附近寻找最贴近可达角度的方块坐标。考虑到在几千格之后哪怕0.7°的角度差都会有导致最终百格的偏差，这个命令非常重要。在算法实现角度，用三分写是最快的，但是考虑到从-180°到180°有一个不连续间断点，导致写三分会涉及到一些繁琐的细节。我比较懒，所以就用了比较慢的写法（这个写法其实也有明显bug，但是我不准备修）。</p></li>
</ol>
<p>常见的使用流程：</p>
<ol type="1">
<li>确定冰道的两点。</li>
<li>固定一点（通常是nether hub或者已经固定留好空间的端点），使用<code>/iceboat adjust</code>微调另一端点的位置。同时计算得出角度。</li>
<li>使用<code>/iceboat mark</code>标记放冰的位置。</li>
<li>放冰。</li>
<li>使用<code>/iceboat clear</code>清除标记。</li>
</ol>
<p>目前比较不人性化的一点是carpet的<code>create_marker</code>用的是隐形盔甲架实现的，hitbox的制约导致有的时候放不了方块，用area effect cloud可能可以解决这个问题。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/HDU2204/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/HDU2204/" class="post-title-link" itemprop="url">HDU 2204 / 容斥原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-09-01 10:02:38" itemprop="dateModified" datetime="2018-09-01T10:02:38-04:00">2018-09-01</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=2204">题面</a></p>
<p>大意：求在<span class="math inline">\([1, n]\)</span>中可以表示为<span class="math inline">\(m^k\)</span>形式的数的个数（<span class="math inline">\(m, k \in \mathbb{Z}^+, k &gt; 1,n \le 10^{18}\)</span>）</p>
<p>这道题不像是有<span class="math inline">\(O(1)\)</span>的解法，但是哪怕是<span class="math inline">\(O(\sqrt{n})\)</span>的算法也会超时，因此直觉上我们应该寻找的是<span class="math inline">\(O(\log n)\)</span>的算法。</p>
<p>首先，因为<span class="math inline">\(m = 1\)</span>的情形是trivial的，所以考虑<span class="math inline">\(m \ge 2\)</span>此时<span class="math inline">\(k \le \log_m n \le \log_2 n \le 60\)</span>，这也是<span class="math inline">\(k\)</span>的一个上界。</p>
<p>接下来我们发现：如果一个数可以表示为<span class="math inline">\(m^4\)</span>的形式，也一定可以表示为<span class="math inline">\((m^2)^2\)</span>的形式，类似地，如果<span class="math inline">\(k = pq\)</span>是合数的话，那么<span class="math inline">\(m^k\)</span>一定可以表示为<span class="math inline">\((m^p)^q\)</span>和<span class="math inline">\((m^q)^p\)</span> 。</p>
<p>令<span class="math inline">\(P(i)\)</span>表示可以表示为<span class="math inline">\(m^i\)</span>形式的数的个数，那么题目显然要我们求的是： <span class="math display">\[
\left| \bigcup_{素数p\le\log_2n}P(p) \right|
\]</span> 接下来就用容斥原理很快就能解决这道题了，代码非常的简洁，注意精度：</p>
<pre class="line-numbers"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cmath&gt;

using namespace std;
typedef long long ll;
const double EPS = 1e-8;
const int p[] = &#123; 0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59 &#125;;
ll n;

ll calc(ll d, ll a) &#123;
    if (a &gt; 60) return 0;
    if (d == 0) 
        return a == 1 ? 0 : (ll)(pow(n, 1.0 / a) + EPS) - 1;
    return calc(d - 1, a) - calc(d - 1, a * p[d]);
&#125;

int main() &#123;
    while (scanf(&quot;%lld&quot;, &amp;n) != EOF)
        printf(&quot;%lld\n&quot;, -calc(17, 1) + 1);
    return 0;
&#125;</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/HDU5015/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/HDU5015/" class="post-title-link" itemprop="url">HDU 5015 / 矩阵加速递推</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-09-03 07:58:42" itemprop="dateModified" datetime="2018-09-03T07:58:42-04:00">2018-09-03</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="题意">题意</h1>
<p><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=5015">题面</a>：假设有一个<span class="math inline">\(n+1\)</span>行<span class="math inline">\(m+1\)</span>列的矩阵<span class="math inline">\(A\)</span>，下标从<span class="math inline">\(0\)</span>开始，给定<span class="math inline">\(A_{1,0}, A_{2, 0}, \cdots A_{n, 0}\)</span>（即最左边一列的初始值），以及已知矩阵的第<span class="math inline">\(1\)</span>行第<span class="math inline">\(i\)</span>列为<span class="math inline">\(2\underbrace{333\cdots3}_{i + 1 个 3}\)</span>，如下所示： <span class="math display">\[
\left(\begin{matrix}
0 &amp;233 &amp;2333 &amp;23333 &amp;\cdots \\
A_{1, 0} &amp;A_{1, 1} &amp;A_{1, 2} &amp;A_{1, 3} &amp;\cdots \\
A_{2, 0} &amp;A_{2, 1} &amp;A_{2, 2} &amp;A_{2, 3} &amp;\cdots \\
\vdots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\ddots
\end{matrix}\right)
\]</span> 并且已知对于<span class="math inline">\(i, j \ge 1\)</span>，有<span class="math inline">\(A_{i, j} = A_{i - 1, j} + A_{i, j - 1}\)</span>。求<span class="math inline">\(A_{n, m}\)</span>。</p>
<p><span class="math inline">\(n \le 10, m \le 10^9\)</span>。</p>
<h1 id="解法">解法</h1>
<p>从数据范围可以得知我们必须使用矩阵快速幂加速递推，我们定义第<span class="math inline">\(i\)</span>列的状态向量为一个<span class="math inline">\(n + 2\)</span>行的列向量，并<strong>手动展开递推式消除同一列的项</strong>（非常重要，因为不然的话没办法推）得到转移矩阵： <span class="math display">\[
\left(\begin{matrix}
1 \\
A_{i, 0} \\
A_{i, 1} \\
A_{i, 2} \\
A_{i, 3} \\
\vdots
\end{matrix}\right)
=
\left(\begin{matrix}
1 &amp;0 &amp;0 &amp;0 &amp;0 &amp;\cdots\\
3 &amp;10 &amp;0 &amp;0 &amp;0 &amp;\cdots\\
3 &amp;10 &amp;1 &amp;0 &amp;0 &amp;\cdots\\
3 &amp;10 &amp;1 &amp;1 &amp;0 &amp;\cdots\\
3 &amp;10 &amp;1 &amp;1 &amp;1 &amp;\cdots\\
\vdots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\vdots &amp;\ddots
\end{matrix}\right)
\left(\begin{matrix}
1 \\
A_{i - 1, 0} \\
A_{i - 1, 1} \\
A_{i - 1, 2} \\
A_{i - 1, 3} \\
\vdots
\end{matrix}\right)
\]</span> 注意到我们怎么处理<span class="math inline">\(2\underbrace{333\cdots3}_{i + 1 个 3}\)</span>的，我们发现<span class="math inline">\(2\underbrace{3\cdots3}_{i + 1 个 3} = 2\underbrace{3\cdots3}_{i 个 3} \times 10 + 3\)</span>，为了凑出<span class="math inline">\(3\)</span>我们在矩阵当中引入<span class="math inline">\(1\)</span>这多余的一行（<strong>这是在矩阵加速递推时引入常数项的常用技巧</strong>）（其实在这里直接引入<span class="math inline">\(3\)</span>也可以啦，但是<span class="math inline">\(1\)</span>的话更通用），这就是系数<span class="math inline">\(3, 10\)</span>的由来。然后使用快速幂加速矩阵乘法即可，时间复杂度为<span class="math inline">\(O(n^3\log m)\)</span>：</p>
<pre class="line-numbers"><code class="language-cpp">#include &lt;cstdio&gt;

using namespace std;
typedef long long ll;
typedef int mat[13][13];
typedef int vec[13];
const int MOD = 10000007;
int n, m;
vec a;
mat b;

void mul(mat &amp;x, vec &amp;y) &#123;
    vec z;
    for (int i = 1; i &lt;= n + 2; i++) &#123;
        z[i] = 0;
        for (int j = 1; j &lt;= n + 2; j++)
            z[i] = (z[i] + 1LL * x[i][j] * y[j]) % MOD;
    &#125;
    for (int i = 1; i &lt;= n + 2; i++)
        y[i] = z[i];
&#125;

void sqr(mat &amp;x) &#123;
    mat y;
    for (int i = 1; i &lt;= n + 2; i++) &#123;
        for (int j = 1; j &lt;= n + 2; j++) &#123;
            y[i][j] = 0;
            for (int k = 1; k &lt;= n + 2; k++)
                y[i][j] = (y[i][j] + 1LL * x[i][k] * x[k][j]) % MOD;
        &#125;
    &#125;
    for (int i = 1; i &lt;= n + 2; i++)
        for (int j = 1; j &lt;= n + 2; j++)
            x[i][j] = y[i][j];
&#125;

int main() &#123;
    while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF) &#123;
        a[1] = 1, a[2] = 23;
        for (int i = 3; i &lt;= n + 2; i++)
            scanf(&quot;%d&quot;, &amp;a[i]);
        b[1][1] = 1;
        for (int i = 2; i &lt;= n + 2; i++) &#123;
            b[i][1] = 3, b[i][2] = 10;
            for (int j = 3; j &lt;= i; j++)
                b[i][j] = 1;  
        &#125;
        for (; m; m &gt;&gt;= 1) &#123;
            if (m &amp; 1) mul(b, a);
            sqr(b);
        &#125;
        printf(&quot;%d\n&quot;, a[n + 2]);
    &#125;
    return 0;
&#125;</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/Gradle%E5%88%9D%E6%8E%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/Gradle%E5%88%9D%E6%8E%A2/" class="post-title-link" itemprop="url">Gradle初探</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-04-03 10:26:36" itemprop="dateModified" datetime="2020-04-03T10:26:36-04:00">2020-04-03</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>自己最近又在用JVM系的语言开新坑。这次终于说服自己从Jetbrains的温床里脱离出来改用了大家都在用的Gradle！感觉良好，在这里简单写一下大概咋用，给之后的自己留一个参考吧。</p>
<p>为什么自己要用Gradle呢？</p>
<ol type="1">
<li>Gradle作为一个开源的构建系统不与任何IDE绑定（比如说IDEA），这相当于增加了代码的兼容性。</li>
<li>Gradle里面可以直接从Maven Central上下库下来，省了我手动下库导入的过程，库更新了也好维护。这对我来说非常地有诱惑力。实测也非常舒服。</li>
<li>Gradle从设计上来说非常灵活，Gradle默认的构建脚本是用Groovy写的（当然也可以用Kotlin但是这似乎不是主流的样子），而不是只有标记功能的XML，这使Gradle一下子非常强大。</li>
<li>大家都在用的样子。</li>
<li>IDEA对于Gradle的支持非常棒！（所以到头来自己还是没有逃脱JB的舒适圈……）</li>
</ol>
<p>虽然说Gradle的功能很强大我目前的用法还是最初级的。我目前用的Gradle代码大致如下：</p>
<pre class="line-numbers"><code class="language-groovy">plugins &#123;
    id &#39;java&#39;
    id &#39;org.jetbrains.kotlin.jvm&#39; version &#39;1.3.61&#39;
&#125;

group &#39;chengyuan&#39;
version &#39;1.0-SNAPSHOT&#39;

sourceCompatibility = 1.8
project.ext.lwjglVersion = &quot;3.2.3&quot;
project.ext.lwjglNatives = &quot;natives-windows&quot;

repositories &#123;
    maven &#123; url &#39;http://maven.aliyun.com/nexus/content/groups/public/&#39; &#125;
    maven &#123; url &quot;https://oss.sonatype.org/content/repositories/snapshots/&quot; &#125;
    mavenCentral()
&#125;

dependencies &#123;
    implementation platform(&quot;org.lwjgl:lwjgl-bom:$lwjglVersion&quot;)
    
    implementation &quot;org.lwjgl:lwjgl&quot;
    implementation &quot;org.lwjgl:lwjgl-assimp&quot;
    implementation &quot;org.lwjgl:lwjgl-bgfx&quot;
    implementation &quot;org.lwjgl:lwjgl-glfw&quot;
    implementation &quot;org.lwjgl:lwjgl-nanovg&quot;
    implementation &quot;org.lwjgl:lwjgl-nuklear&quot;
    implementation &quot;org.lwjgl:lwjgl-openal&quot;
    implementation &quot;org.lwjgl:lwjgl-opengl&quot;
    implementation &quot;org.lwjgl:lwjgl-par&quot;
    implementation &quot;org.lwjgl:lwjgl-stb&quot;
    implementation &quot;org.lwjgl:lwjgl-vulkan&quot;
    runtimeOnly &quot;org.lwjgl:lwjgl::$lwjglNatives&quot;
    runtimeOnly &quot;org.lwjgl:lwjgl-assimp::$lwjglNatives&quot;
    runtimeOnly &quot;org.lwjgl:lwjgl-bgfx::$lwjglNatives&quot;
    runtimeOnly &quot;org.lwjgl:lwjgl-glfw::$lwjglNatives&quot;
    runtimeOnly &quot;org.lwjgl:lwjgl-nanovg::$lwjglNatives&quot;
    runtimeOnly &quot;org.lwjgl:lwjgl-nuklear::$lwjglNatives&quot;
    runtimeOnly &quot;org.lwjgl:lwjgl-openal::$lwjglNatives&quot;
    runtimeOnly &quot;org.lwjgl:lwjgl-opengl::$lwjglNatives&quot;
    runtimeOnly &quot;org.lwjgl:lwjgl-par::$lwjglNatives&quot;
    runtimeOnly &quot;org.lwjgl:lwjgl-stb::$lwjglNatives&quot;
    
    testCompile group: &quot;junit&quot;, name: &quot;junit&quot;, version: &quot;4.12&quot;
&#125;

compileKotlin &#123;
    kotlinOptions.jvmTarget = &quot;1.8&quot;
&#125;

compileTestKotlin &#123;
    kotlinOptions.jvmTarget = &quot;1.8&quot;
&#125;</code></pre>
<p>首先是<code>plugins</code>这段，这一段虽然重要但一般用不着特别操心，按照我的理解大概是语言支持的插件。</p>
<p>接下来是版本、JVM版本之类的，看着也很明白。</p>
<p>然后可以申明一些接下来会用到的常量。</p>
<p><code>repository</code>告诉Gradle从哪里找库。常见的源有内置的函数，例如<code>mavenCentral()</code>，<code>jcenter()</code>。如果是其他的Maven源也可以指定URL。比如说我这里用了阿里云的Maven镜像，在国内速度就会快上很多。</p>
<p>接下来是<code>dependencies</code>，这个是重头戏。</p>
<p>最常见的是<code>implementation</code>，这个后面一般跟库的Maven id。如果想直接引用本地文件可以用<code>files(...)</code>，如果是一个平台一个版本的可以用<code>platform(...)</code>。基本上这就覆盖了99%的用途。</p>
<p>此外还有<code>runtimeOnly</code>，这个和<code>implementation</code>的区别就是<code>runtimeOnly</code>的库是不参与编译的，只在运行期有效。这一般都是用JNI的一众native库和一些二级库。</p>
<p>还有<code>testCompile</code>，用这个修饰的库是只在跑单元测试的时候依赖的，因此基本上都是一些测试有关的库。我人懒，平时懒得写单元测试，因此这个我基本上不用。</p>
<p>这些就是我目前摸索出来的Gradle的基本用法，目前的感觉就是把IDEA里面的很多GUI的操作文字化，非常舒适，省了很多麻烦。更复杂的用法例如自定义build task等都可以在官网上找到（文档很丰富也是Gradle比较吸引人的点）。</p>
<p>最后有一点点想吐槽，就是Groovy似乎单引号和双引号都可以表示字符串。双引号的字符串支持插值，这似乎是唯一的予以区别。IDE默认生成的是单引号，LWJGL的打包器生成的是双引号，似乎最通用的是双引号，自己到底是用双引号还是单引号呢？这种东西真的是万恶之源。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/FuckZhihu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/FuckZhihu/" class="post-title-link" itemprop="url">退乎，与自省</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-29 22:45:24" itemprop="dateModified" datetime="2020-03-29T22:45:24-04:00">2020-03-29</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>上一次发文章已经是三个星期以前了。</p>
<p>感到一丝焦虑，但三个星期中确实没有做成值得写一写的事情是一个令人沮丧的事实。</p>
<p>开学了人忙了是一个原因。人一忙，一个矛盾愈发凸显。</p>
<p><strong>理性上对于系统化学习的追求与感性上沉溺于碎片化知识平台的矛盾。</strong></p>
<p>自己要应付AP考试还有一整本的Gregory Mankiw的经济学要看。</p>
<p>自己现在还在看柏拉图的《理想国》，书很好看，觉得很有启发。</p>
<p>地理的等级考也是要准备起来的。</p>
<p>文书也是要做起准备的。</p>
<p>个人的项目也是要做的。</p>
<p>退一步讲，自己还有一个追番TODO List还要十几部番要追，轻小说TODO List还有几部要抽空看。</p>
<p>当时间就剩下这么一点，知乎这么一个搅屎棍的存在就显得令人恼火了。</p>
<p>自己之前一直看不起快手和抖音，觉得这种垃圾玩意纯粹就是让人上瘾的。</p>
<p>可悲的是，自己也成了知乎的奴隶。</p>
<p>确实我在鄙视链上比抖音快手高一级，但是当鄙视链的每一根链环都足够拴着你吃屎的时候，其实区别不大。</p>
<p>知乎不知不觉成为了我常逛的唯一平台。居然占据了30%的耗电，难道这不恐怖吗？</p>
<p>只是为了看时事，结果刷了一个小时，难道这不恐怖吗？</p>
<p>我觉得是时候好好反思反思了。</p>
<p>要是这一个小时有营养就算了。</p>
<p>现在的知乎，90%的回答就是在玩烂梗。时政问题下就是两个极端的口诛笔伐，喊入关的喊入关，吹国外的吹国外，骂公知的骂公知。党同伐异，贴上标签就开骂，评论区里友善度堪比电竞祖安。</p>
<p>国家自信的大旗已经举起，反公知的政治正确俨然形成。这着实是好事，但是被这股情绪裹挟着消磨时间又是另一回事了。</p>
<p>人们说政治是一个门槛看起来低实际上高得很的学科。谁都能对政治发表一番高论，但是要使理论逻辑自洽，预测准确一致就需要非常高的水平。</p>
<p>知乎上大体是前者。山高死而入关兴，大家都在喊入关，要么就国家拟人化走一波，大家还就好这一口。</p>
<p>敢情我是来看波兰球动画的呢？</p>
<p>不然要么就恶政隐或者膜蛤走一波，下面的评论狂喊冲塔冲塔枪毙枪毙药丸药丸下个账号再见，不亦乐乎，谁说天朝子民不可妄议朝政？</p>
<p>但是我现在真的觉得让我们普罗大众表达诉求可以，玩键盘政治或许不值得提倡。</p>
<p>我记得16年刚玩知乎的时候，还是有很多很有意义的回答的。比如说人民群众喜闻乐见的知乎如意勺系列，虽然问题虚构荒诞，但是科普的目的确实达到了。每一篇文章洋洋洒洒干货十足，比起现在一千万和蜗牛的虚构问题不知道高到哪里去了。</p>
<p>现在还有这么多干货文章吗？有的，引经据典的回答终究是有的，之前在知乎上看到的毕导的科普视频也是很好的。但是这些都被大大稀释了，到现在，为了这么一篇好文章刷过50篇朱一旦，营销号，观察者网或者环球时报似乎不值得。</p>
<p>我不知道是资本的入驻使知乎变了味，还是推荐算法使然。</p>
<p>我倾向于后者。</p>
<p>推荐算法实在是太恐怖了。</p>
<p>它恐怖就恐怖在它是一个正反馈系统，平衡点是不稳定的。只要思想稍有偏差，就会迅速滚到一个极端去。</p>
<p>它迎合你，让你每一时刻都享受英雄所见略同的快感。很多时候看前两句句你就知道这篇文章要讲啥，但是禁不住讲的东西你喜欢，于是又看了下去。很多时候回答就只有两句，篇幅完全不重要。我逛知乎的心态已经从以往的获取知识，到寻求附和与认同为主，能看到啥就学啥为辅的情况了，非常可悲。自己当真就没有独立思考的能力和对此的自信？</p>
<p>小群体内的自我认同除了加深偏执以外不会引入新的思想，甚至还会降低你对异见的容忍度，看到不一样的观点就烦躁，哪怕它的长篇大论是真的有论点有论据有深度可以学到东西的。知乎里现在键政领域两极分化，推荐算法功不可没。</p>
<p>当一个问答网站将迎合用户，附和用户作为首要任务，而不是去挑战用户的认知，扩充用户的头脑的话，这个网站可就真的忘了初心，出了大问题了。</p>
<p>或许也没有忘初心，万一人家初心就是赚钱呢。</p>
<p>现在想想我每天干嘛？去知乎看人嘲讽美国防疫，还是看人调侃美股八熔八耻？</p>
<p>但是我又不是靠知乎获得这些信息的。我每天一大早都是自己去JHU的网站上查人数，自己查道指的。小米内置的资讯在遇到大新闻的时候也没落下。也就是我不断心理暗示知乎是一个获得时政新闻的平台，其实根本不是。那我天天去干嘛？我贱不贱啊？贱不贱啊？</p>
<p>自己完全是被动地被知乎牵着鼻子走，可太悲哀了。</p>
<p>另一方面，知乎的产品设计实在是太高明了。</p>
<p>我觉得我还是要回归搜索引擎。</p>
<p>搜索引擎有两个好，一个是它没有针对个人的推荐算法，另一个是你永远有主动权。你搜索什么它给什么。你不搜它不给，爽到。搜出来的结果分散于网络，不容易对于一个平台形成粘性。因此，只要搜索引擎的算法不是特别差（比如说Google），用搜索引擎就不会有大问题。</p>
<p>被搜索引擎带到知乎和直接在知乎搜索栏里搜索是完全两个不一样的概念。</p>
<p>搜索引擎的覆盖面比知乎高，那我为啥不用搜索引擎呢？</p>
<p>我要学习技术，我为啥不去SO、V2EX、SF之类的呢？</p>
<p>同样是刷手机，我为啥不去B站上看看罗翔追追番呢？前者能普法，后者比看垃圾梗更娱乐一点。</p>
<p>为什么呢？</p>
<p>自己之前真的是懒。妄想着知乎一个平台就够了，结果被灌屎，被偶尔尝到的糖吊着胃口，持续地被喂屎。</p>
<p>太糟糕了，实在是太糟糕了。</p>
<p>丹麦哲学家 Søren Kierkegaard 讲过一句话，现在想起来觉得实在是太对了。</p>
<blockquote>
<p>People demand freedom of speech as a compensation for the freedom of thought which they seldom use.</p>
</blockquote>
<p>把知乎卸了。搜索引擎搜到还是会看一下，但是不会主动逛了。</p>
<p>但愿不会真香。</p>
<hr />
<p>其实吧，我觉得，自己退出知乎的这个决定在我看来也是很可悲的。</p>
<p>因为这是我对于无法解决实际问题的一个逃避。</p>
<p>控制不住逛知乎，知乎用户粘性很高是外因，自己不自制是内因。外因通过内因而起作用。</p>
<p>有的时候我觉得虽然学校的政治课大多弱智，但是一些矛盾论以及唯物辩证的思路终究还是受用的。</p>
<p>自己究竟什么时候才会认认真真审视自己自制力不够的问题呢？</p>
<p>我如何才能避免自己看知乎变成看B站呢？</p>
<p>我自以为知乎比B站容易上瘾，先这么自以为着吧。与自己的颓废欲望做出妥协。</p>
<hr />
<p>搜索引擎让我掌握了主动权，但是主动权往往是不够的。我要主动搜啥呢？</p>
<p>正如YPM里面Humphrey说的，I have to know everything so that I can decide whether I need them!</p>
<p>我也有同学说知乎平台里面有很多宝藏回答，我自己也觉得很多时候知乎的热榜里有热点新闻，这是知乎的价值。</p>
<p>可以料想到的是，我现在退出知乎以后，终究要有一个信息平台顶替它的位置，keeping myself well-informed.</p>
<p>这个平台会是什么呢？</p>
<p>我不期望是一个正反馈的系统，今日头条之类的肯定不行。</p>
<p>直接看新闻？新闻是一个无反馈的系统，但为了避免被带入一家的政治立场当中去就要各种立场的新闻都看，不知道有没有时间。</p>
<p>并没有人设计过负反馈的信息平台，估计也不会有人设计这种吃力不讨好的玩意，虽然这是最好的。</p>
<p>朋友圈或许可以，让亲戚朋友代我受这些正反馈平台的戕害自然是最好不过的了（感觉自己的思想还是有点阴暗），反正他们在朋友圈几句话也不足以左右我本身的判断，他们转发的文章我也未必要看，我要的就是这件事情本身，这样我就可以自己去搜了。</p>
<p>唉。有的时候我觉得学数理之类的不用区分立场，逻辑与实验自有定论，省了我的脑细胞，是我作为理科生的幸运，但让我缺乏批判性思考的锻炼，又是我作为理科生的不幸。以至于面对正反馈带来的立场极端化不得不采取“闭关锁国”的战略，我也不知道是不是好事。我一直认为，如果有人能够依靠自己的批判性思维带来的负反馈效用力压推荐算法的正反馈，以至于在主流平台当中依然可以保持相对地客观，那是真的厉害。</p>
<p>另一种自暴自弃的思路莫过于，创造一种统一的政治立场，有一个绝对的权威来树立绝对的政治正确，这样大家都处在同一个立场，提前到达了正反馈的极限，正反馈也就没用了。这正如西方对于我国的态度。一个小圈子里互相认同而偏执是悲哀，但是如果几十亿人不断地相互认同而产生的根深蒂固的思潮，我也不知道是好是坏。它确实湮灭了所有的异见也降低了头脑在这个问题的负担，但也导致新思维的短缺。站在民智发展的角度来看，这样很危险，但是站在统战的角度上，这样似乎又不是不行。</p>
<p>我从未学过认知论也从未学过教育学，但是我推断人类的认知过程本身不可避免地是一个先天的正反馈过程，别人的认可是激励，别人的反驳是惩罚。在基础教育的过程中，“别人”单指老师与同学，因此这个思路被不断提倡，而当到了网络的辩论场，人们自动就会把“别人”的定义延拓了。要逆转这个态势，审慎地对待别人的认可，积极地面对别人的反驳，小心翼翼地避免矫枉过正，在这个时代还要对抗推荐算法，实在是不容易。而如果只有一个人能够做到这一步，那么这个人被孤立于群体之中，也未必如之前一样快乐。</p>
<p>因此我越看《理想国》，越觉得像里面的苏格拉底一样在辩论中不恼羞成怒诉诸于人身攻击，反而通过设问，在多个立场之间来回切换，将辩论用作真正探寻真理的途径而非自我膨胀的乱骂一通，实在是一种非常高明的智慧。我觉得自己离这个境界差远了，而对于是否所有人都能拥有这个智慧，是否应该拥有这份智慧，拥有这份智慧之后是否会感到快乐，我现在很悲观。</p>
<p>唉，自己社科不行，也只能乱发牢骚一通。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/FWHT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/FWHT/" class="post-title-link" itemprop="url">Fast Walsh-Hadamard Transform in Competitive Programming</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-08-07 04:56:28" itemprop="dateModified" datetime="2020-08-07T04:56:28-04:00">2020-08-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>This should be the very first English post I write on my blog and I expect there to be some minor errors. This is a popular technique in the Chinese competitive programming community but there doesn't seem to be a lot of documentation about its application in the English CP community. The posts I found on Codeforces doesn't seem to be very clear to me...</p>
<h1 id="prerequisites">Prerequisites</h1>
<ul>
<li>A decent proficiency in competitive programming.</li>
<li>A basic understanding of the Cooley-Tukey FFT and its application in competitive programming.</li>
<li>A decent understanding of bitwise operations.</li>
</ul>
<h1 id="why-do-we-need-fwht">Why do we need FWHT?</h1>
<p>Recall what we would do if we are to quickly calculate the following convolution of two sequences <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, each of length <span class="math inline">\(n\)</span>: <span class="math display">\[
\{a\circledast b\}_i=\sum_{j+k=i}a_{j}b_k \Bigg/ \{a\circledast b\}_i=\sum_{j=0}^ia_{j}b_{i-j}
\]</span> We use FFT, which applies the following transformation to the input sequence: <span class="math display">\[
\mathcal{F}\{a\}_i = \sum_{j=0}^n a_j\omega_{n}^{ij}
\]</span> Since the calculation of this transformation (and its inverse) can be done in a divide-and-conquer manner in <span class="math inline">\(\mathcal O(n\log n)\)</span> and the element wise product of the transformation is equivalent to the convolution on the original series, we are able to calculate the convolution in <span class="math inline">\(\mathcal O(n\log n)\)</span>.</p>
<p>Now we try to generalize our findings to a more general case: <span class="math display">\[
\{a\circledast b\}_i=\sum_{j \star k=i}a_jb_k
\]</span> where <span class="math inline">\(\star\)</span> is some binary operation. The convolution we see at the beginning is a special case where <span class="math inline">\(\star = +\)</span>.</p>
<p>FWHT is an algorithm that borrows similar notions from FFT and is able to compute the convolution in <span class="math inline">\(\mathcal O(n \log n)\)</span> time for <span class="math inline">\(\star =\vee,\wedge,\oplus\)</span> (bitwise OR, bitwise AND, and bitwise XOR). Why do the convolutions of these bitwise operations matter? Observe that binary representation is a way of encoding sets and these three operations correspond to set union, set intersection and set symmetric difference respectively, therefore, FWHT can be used to accelerate set-based DPs.</p>
<h1 id="bitwise-or-convolution">Bitwise OR convolution</h1>
<p>Let's start with the convolution with respect to bitwise OR: <span class="math display">\[
\{a\circledast b\}_i = \sum_{j\vee k=i}a_jb_k
\]</span> We start by exploiting an interesting property of bitwise OR: <span class="math display">\[
x \vee z = z,y\vee z = z \Leftrightarrow (x\vee y)\vee z=z
\]</span> or its clearer equivalent in set-based notations: <span class="math display">\[
X\subseteq Z,Y\subseteq Z \Leftrightarrow (X\cup Y)\subseteq Z
\]</span> <strong>Claim:</strong> The following transformation can turn OR convolutions to element-wise multiplications: <span class="math display">\[
\mathcal{FWHT}\{a\}_i=\sum_{j\vee i=i} a_j
\]</span> <strong>Proof:</strong> <span class="math display">\[
\begin{aligned}
\mathcal{FWHT}\{a\}_i\cdot\mathcal{FWHT}\{b\}_i &amp;= \left(\sum_{j\vee i=i}a_j\right) \left(\sum_{k\vee i=i}b_k\right) \\
&amp;= \sum_{j\vee i=i}\sum_{k\vee i=i}a_jb_k \\
&amp;= \sum_{(j\vee k)\vee i=i} a_jb_k \\
&amp;= \sum_{l\vee i = i}\sum_{j \vee k = l} a_jb_k\\
&amp;= \mathcal{FWHT}\{a\circledast b\}_i
\end{aligned}
\]</span> Then how are we able to compute <span class="math inline">\(\mathcal{FWHT}\{a\}\)</span> quickly? A trivial implementation still takes <span class="math inline">\(\mathcal O(n^2)\)</span> time.</p>
<p>Recall what we did in FFT: we divide <span class="math inline">\(a\)</span> into two subsequences based on parity of indices, a.k.a, the last bit of indices. We did this because the root of unity has such amazing property as <span class="math inline">\(\omega_n^k=\omega_{n/2}^{k/2}\)</span>. We could do that here as well, but a limitation of dividing based on the last bit is that the order of elements changes in the process, so an efficient in-place implementation has to do a pre-shuffle to cope with that. Since OR is a bitwise operation, which bit based on which we divide doesn't really matter much. Why not simply <strong>divide based on the first, or the most significant bit</strong>, such that the order of elements is preserved in the process? Dividing based on the highest bit of indices, simply put, is to split <span class="math inline">\(a\)</span> into the first half, <span class="math inline">\(a^0\)</span>, and the second half, <span class="math inline">\(a^1\)</span>, in their natural order.</p>
<p>Here I introduce a notation, <span class="math inline">\(1|a\)</span> or <span class="math inline">\(0|a\)</span>. In the context where the length of the sequence is <span class="math inline">\(n\)</span> (and <span class="math inline">\(n\)</span> is a power of <span class="math inline">\(2\)</span>), <span class="math inline">\(1|a=\frac{n}{2}+a\)</span> where <span class="math inline">\(0\le a&lt;n/2\)</span>, and <span class="math inline">\(0|a\)</span> is just <span class="math inline">\(a\)</span>. In other words, <span class="math inline">\(1|a\)</span> has <span class="math inline">\(1\)</span> as the highest bit and <span class="math inline">\(0|a\)</span> has <span class="math inline">\(0\)</span> as the highest bit.</p>
<p>(Note using this notation, <span class="math inline">\(a^0_i = a_{0|i}\)</span> and <span class="math inline">\(a^1_i = a_{1|i}\)</span>)</p>
<p>To make our writing clearer, denote <span class="math display">\[
\begin{aligned}
\mathcal{FWHT}\{a\} &amp;= A \\
\mathcal{FWHT}\left\{a^0\right\} &amp;= A^0 \\
\mathcal{FWHT}\left\{a^1\right\} &amp;= A^1 \\
\end{aligned}
\]</span> We want to express each element of <span class="math inline">\(A\)</span> as a combination of some element in <span class="math inline">\(A^0\)</span> and <span class="math inline">\(A^1\)</span>.</p>
<p>We first look at the first half of <span class="math inline">\(A\)</span>. Using the notation I defined above, these elements can be expressed as <span class="math inline">\(A_{0|i}\)</span>. <span class="math display">\[
\begin{aligned}
A_{0|i}&amp;=\sum_{j\vee (0|i)=0|i}a_j \\
&amp;= \sum_{(0|j)\vee (0|i)=0|i}a^0_j + \sum_{(1|j)\vee (0|i)=0|i}a^1_j \\
\end{aligned}
\]</span> We know that the highest bit of <span class="math inline">\((1|j)\vee (0|i)\)</span> should always be <span class="math inline">\(1\)</span>, so the condition in the second summation is never satisfied, and we can simply throw the second term away. And <span class="math inline">\((0|j)\vee (0|i)=0|i\)</span> simplifies to <span class="math inline">\(j\vee i =i\)</span>, so we get, by definition of <span class="math inline">\(A^0\)</span>: <span class="math display">\[
A_{0|i} = A^0_i
\]</span> What about the second half, <span class="math inline">\(A_{1|i}\)</span>? <span class="math display">\[
\begin{aligned}
A_{1|i}&amp;=\sum_{j\vee (1|i)=1|i}a_j \\
&amp;= \sum_{(0|j)\vee (1|i)=1|i}a^0_j + \sum_{(1|j)\vee (1|i)=1|i}a^1_j \\
&amp;= A_i^0+A_i^1
\end{aligned}
\]</span> Together we get: <span class="math display">\[
A=\left(A^0, A^0+A^1\right)
\]</span> with the trivial recursion boundary <span class="math inline">\(A_0=a_0\)</span> when <span class="math inline">\(n=0\)</span>.</p>
<p>(here I use the tuple notation to denote concatenation, and <span class="math inline">\(+\)</span> to denote element-wise addition).</p>
<p>This is something we can write an in-place implementation for with ease:</p>
<pre class="line-numbers"><code class="language-cpp">void fwht_or(int n, int *a, int *A) &#123;
    copy(a, a + n, A);
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1)
        for (int l = 0; l &lt; n; l += s)
            for (int i = 0; i &lt; h; i++)
                A[l + h + i] += A[l + i]
&#125;</code></pre>
<p>Its time complexity is obviously <span class="math inline">\(\mathcal O(n\log n)\)</span> with a really small constant factor.</p>
<p>Its reverse transform turns out to be simple as well, suppose we know <span class="math inline">\(A\)</span> and let <span class="math display">\[
A=(A&#39;,A&#39;&#39;)
\]</span> (Assuming <span class="math inline">\(n\)</span> is a power of <span class="math inline">\(2\)</span> and <span class="math inline">\(A&#39;\)</span> and <span class="math inline">\(A&#39;&#39;\)</span> each have length <span class="math inline">\(n/2\)</span>)</p>
<p>Then we can recover <span class="math inline">\(A^0\)</span> and <span class="math inline">\(A^1\)</span>: <span class="math display">\[
\begin{cases}
    A^0=A&#39;\\
    A^1=A&#39;&#39;-A&#39;
\end{cases}
\]</span> Implementation:</p>
<pre class="line-numbers"><code class="language-cpp">void ifwht_or(int n, int *a, int *A) &#123; 
    std::copy(A, A + n, a);
    // If n is guaranteed to be a power of 2 then we don&#39;t need n_ and the min(...) in the inner loop.
    int n_ = 1; while (n_ &lt; n) n_ &lt;&lt;= 1; 
    // n_ = 1 &lt;&lt; (32 - __builtin_clz(n - 1));
    for (int s = n_, h = n_ / 2; h; s &gt;&gt;= 1, h &gt;&gt;= 1)
        for (int l = 0; l &lt; n; l += s)
            for (int i = 0; i &lt; std::min(i, n - l - h); i++)
                a[l + h + i] -= a[l + i]
&#125;</code></pre>
<p>And an amazing thing about this, which I haven't quite figured out why, is that the order of the outermost loop above can be reversed and both functions can be merged into one:</p>
<pre class="line-numbers"><code class="language-cpp">void fwht_or(int n, int *a, int *A, int dir = 1) &#123;
    std::copy(a, a + n, A);
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1)
        for (int l = 0; l &lt; n; l += s)
            for (int i = 0; i &lt; h; i++)
                A[l + h + i] += dir * A[l + i]
&#125;</code></pre>
<p>(Fast bitwise OR / set union convolution is sometimes aliased "Fast Mobius Transform" in Chinese CP community. Both are essentially the same.)</p>
<h1 id="bitwise-and-convolution">Bitwise AND convolution</h1>
<p>The bitwise AND convolution <span class="math display">\[
\{a\circledast b\}_i = \sum_{j\wedge k=i}a_jb_k
\]</span> can be accelerated in a similar way.</p>
<p>(Actually, by de Morgan's Law we can always reduce an AND convolution to an OR convolution)</p>
<p>Note that AND also has this interesting property: <span class="math display">\[
x \wedge z = z,y\wedge z = z \Leftrightarrow (x\wedge y)\wedge z=z
\]</span> or in set notations: <span class="math display">\[
Z\subseteq X,Z\subseteq Y \Leftrightarrow Z\subseteq(X\cap Y)
\]</span> Thus, we can prove in a way similar to what we did in OR convolution that the transform <span class="math display">\[
\mathcal{FWHT}\{a\}_i=\sum_{j\wedge i=i} a_j
\]</span> can turn convolutions to element-wise multiplications.</p>
<p>We still adopt the same divide-and-conquer approach and continue to use the notations <span class="math inline">\(a, a^0,a^1,A,A^0,A^1\)</span>.</p>
<p>Consider the first half of <span class="math inline">\(A\)</span>, which can be expressed as <span class="math inline">\(A_{0|i}\)</span>: <span class="math display">\[
\begin{aligned}
A_{0|i}&amp;=\sum_{j\wedge (0|i)=0|i}a_j \\
&amp;= \sum_{(0|j)\wedge (0|i)=0|i}a^0_j + \sum_{(1|j)\wedge (0|i)=0|i}a^1_j \\
\end{aligned}
\]</span> And by the properties of AND, both <span class="math inline">\((0|j)\wedge (0|i)=0|i\)</span> and <span class="math inline">\((1|j)\wedge (0|i)=0|i\)</span> simplify to <span class="math inline">\(j\wedge i=i\)</span>. So by definition we get <span class="math display">\[
A_{0|i}=A^0_i+A_i^1
\]</span> Then consider the other half of <span class="math inline">\(A\)</span>: <span class="math display">\[
\begin{aligned}
A_{1|i}&amp;=\sum_{j\wedge (1|i)=1|i}a_j \\
&amp;= \sum_{(0|j)\wedge (1|i)=1|i}a^0_j + \sum_{(1|j)\wedge (1|i)=1|i}a^1_j \\
&amp;= A_i^1
\end{aligned}
\]</span> Together we have: <span class="math display">\[
A=\left(A^0+A^1,A^1\right)
\]</span> with the trivial recursion boundary <span class="math inline">\(A_0=a_0\)</span> when <span class="math inline">\(n=0\)</span>.</p>
<p>This gives an efficient implementation very similar to <code>fwht_or</code> above:</p>
<pre class="line-numbers"><code class="language-cpp">void fwht_and(int n, int *a, int *A) &#123;
    std::copy(a, a + n, A);
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1)
        for (int l = 0; l &lt; n; l += s)
            for (int i = 0; i &lt; h; i++)
                A[l + i] += A[l + h + i]
&#125;</code></pre>
<p>The inverse transform is simple as well. Let <span class="math inline">\(A=(A&#39;, A&#39;&#39;)\)</span>, then <span class="math display">\[
\begin{cases}
A^0=A&#39;-A&#39;&#39; \\
A^1=A&#39;&#39;
\end{cases}
\]</span> The code:</p>
<pre class="line-numbers"><code class="language-cpp">void ifwht_and(int n, int *a, int *A) &#123; 
    std::copy(A, A + n, a);
    // If n is guaranteed to be a power of 2 then we don&#39;t need n_ and the min(...) in the inner loop.
    int n_ = 1; while (n_ &lt; n) n_ &lt;&lt;= 1; 
    for (int s = n_, h = n_ / 2; h; s &gt;&gt;= 1, h &gt;&gt;= 1)
        for (int l = 0; l &lt; n; l += s)
            for (int i = 0; i &lt; std::min(i, n - l - h); i++)
                a[l + i] -= a[l + h + i]
&#125;</code></pre>
<p>The order of the outermost loop can be reversed and we can also merge the functions above together.</p>
<h1 id="bitwise-xor-convolution">Bitwise XOR convolution</h1>
<p>The XOR operation does <strong>not</strong> have such nice property as <span class="math display">\[
x\oplus z=z, y\oplus z=z\Leftrightarrow (x\oplus y)\oplus z=z
\]</span> So accelerating the convolution <span class="math display">\[
\{a\circledast b\}_i = \sum_{j\oplus k=i}a_jb_k
\]</span> is not as straightforward as we did above.</p>
<p>We first introduce an auxiliary operation, define <span class="math inline">\(x \otimes y= \operatorname{popcount}(x\wedge y) \bmod 2\)</span>, where <span class="math inline">\(\operatorname{popcount}(x)\)</span> denotes the number of <span class="math inline">\(1\)</span>s in the binary representation of <span class="math inline">\(x\)</span>.</p>
<p><strong>Claim:</strong> The transformation below turns convolutions to element-wise multiplications: <span class="math display">\[
\mathcal{FWHT}\{a\}_i=\sum_{j\otimes i=0} a_j - \sum_{j\otimes i=1} a_j
\]</span> <strong>Proof: </strong> <span class="math display">\[
\begin{aligned}
\mathcal{FWHT}\{a\}_i\cdot\mathcal{FWHT}\{b\}_i &amp;= \left(\sum_{j\otimes i=0} a_j - \sum_{j\otimes i=1} a_j\right) \left(\sum_{k\otimes i=0} b_k - \sum_{k\otimes i=1} b_k\right) \\
&amp;= \sum_{j\otimes i=0}\sum_{k\otimes i=0}a_jb_k +\sum_{j\otimes i=1}\sum_{k\otimes i=1}a_jb_k \\
&amp;- \sum_{j\otimes i=1}\sum_{k\otimes i=0}a_jb_k - \sum_{j\otimes i=0}\sum_{k\otimes i=1}a_jb_k
\end{aligned}
\]</span> How to simplify those terms?</p>
<p>Observe that by the definition of XOR we have <span class="math display">\[
\operatorname{popcount}(x\oplus y) = \operatorname{popcount}(x)+\operatorname{popcount}(y)-2\operatorname{popcount}(x\wedge y)
\]</span> So if we apply modulo <span class="math inline">\(2\)</span> on both sides, <span class="math display">\[
\operatorname{popcount}(x\oplus y) \equiv \operatorname{popcount}(x)+\operatorname{popcount}(y) \pmod 2
\]</span> Plug in <span class="math inline">\(x=j\wedge i,y=k\wedge i\)</span> and we get <span class="math display">\[
\operatorname{popcount}((j\wedge i)\oplus (k\wedge i)) \equiv \operatorname{popcount}(j\wedge i)+\operatorname{popcount}(k\wedge i) \pmod 2
\]</span> We are almost there. Apply the identity below, whose proof I simply omit here, <span class="math display">\[
(j\wedge i)\oplus (k\wedge i)=(j\oplus k)\wedge i
\]</span> (This is something good about bitwise operations: if you cannot prove an identity the smart way you can always fall back on the dumb method -- making a truth table)</p>
<p>We finally get <span class="math display">\[
(j \oplus k)\otimes i \equiv j\otimes i+k\otimes i \pmod 2
\]</span> (We are actually quite familiar with this if we remove the circles outside <span class="math inline">\(+\)</span>s and <span class="math inline">\(\times\)</span>s)</p>
<p>With this conclusion we can simplify the four terms above: <span class="math display">\[
\begin{aligned}
\mathcal{FWHT}\{a\}_i\cdot\mathcal{FWHT}\{b\}_i &amp;= \cdots \\
&amp;= \sum_{(j\oplus k)\otimes i=0}a_jb_k - \sum_{(j\oplus k)\otimes i=1}a_jb_k \\
&amp;=  \mathcal{FWHT}\{a\circledast b\}_i
\end{aligned}
\]</span> which completes the proof.</p>
<p>We then explore how to compute <span class="math inline">\(\mathcal{FWHT}\{a\}\)</span> efficiently. Divide and conquer is still our friend, and dividing <span class="math inline">\(a\)</span> based on the highest bit works here so we continue to use those notations.</p>
<p>Consider the first half of <span class="math inline">\(A\)</span>... <span class="math display">\[
\begin{aligned}
A_{0|i} &amp;= \sum_{j\otimes (0|i)=0} a_j - \sum_{j\otimes (0|i)=1} a_j \\
&amp;= \sum_{(0|j)\otimes (0|i)=0} a_j^0+  \sum_{(1|j)\otimes (0|i)=0}a_j^1 -  \sum_{(0|j)\otimes (0|i)=1} a_j^0-  \sum_{(1|j)\otimes (0|i)=1}a_j^1 \\
&amp;= \sum_{j\otimes i=0} a_j^0+  \sum_{j\otimes i=0}a_j^1 -  \sum_{j\otimes i=1} a_j^0-  \sum_{j\otimes i=1}a_j^1 \\
&amp;= A_i^0
+A_i^1\end{aligned}
\]</span> and the other half: <span class="math display">\[
\begin{aligned}
A_{1|i} &amp;= \sum_{j\otimes (1|i)=0} a_j - \sum_{j\otimes (1|i)=1} a_j \\
&amp;= \sum_{(0|j)\otimes (1|i)=0} a_j^0+  \sum_{(1|j)\otimes (1|i)=0}a_j^1 -  \sum_{(0|j)\otimes (1|i)=1} a_j^0-  \sum_{(1|j)\otimes (1|i)=1}a_j^1 \\
&amp;= \sum_{j\otimes i=0} a_j^0+  \sum_{j\otimes i=1}a_j^1 -  \sum_{j\otimes i=1} a_j^0-  \sum_{j\otimes i=0}a_j^1 \\
&amp;= A_i^0 - A_i^1
\end{aligned}
\]</span> So together we get <span class="math display">\[
A=\left(A^0+A^1,A^0-A^1\right)
\]</span> and the inverse transform <span class="math display">\[
A=(A&#39;,A&#39;&#39;) \Rightarrow \begin{cases}
\displaystyle A^0=\frac{A&#39;+A&#39;&#39;}{2} \\
\displaystyle A^1=\frac{A&#39;-A&#39;&#39;}{2}
\end{cases}
\]</span> The code for both transforms are a bit longer than those for OR and AND, but not by too much:</p>
<pre class="line-numbers"><code class="language-cpp">void fwht_xor(int n, int *a, int *A) &#123;
    std::copy(a, a + n, A);
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1) &#123;
        for (int l = 0; l &lt; n; l += s) &#123;
            for (int i = 0; i &lt; h; i++) &#123;
                int t = A[l + h + i];
                A[l + h + i] = A[l + i] - t;
                A[l + i] += t;
            &#125;
        &#125;
    &#125;
&#125;
void ifwht_xor(int n, int *a, int *A) &#123;
    std::copy(A, A + n, a);
    // If n is guaranteed to be a power of 2 then we don&#39;t need n_ and the min(...) in the inner loop.
    int n_ = 1; while (n_ &lt; n) n_ &lt;&lt;= 1; 
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1) &#123;
        for (int l = 0; l &lt; n; l += s) &#123;
            for (int i = 0; i &lt; std::min(i, n - l - h); i++) &#123;
                int t = a[l + h + i];
                a[l + h + i] = (a[l + i] - t) / 2;
                a[l + i] = (a[l + i] + t) / 2;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>They can be merged as well:</p>
<pre class="line-numbers"><code class="language-cpp">void fwht_xor(int n, int *a, int *A, bool inv = false) &#123;
    std::copy(a, a + n, A);
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1) &#123;
        for (int l = 0; l &lt; n; l += s) &#123;
            for (int i = 0; i &lt; h; i++) &#123;
                int t = A[l + h + i];
                A[l + h + i] = A[l + i] - t;
                A[l + i] += t;
                if (inv) A[l + h + i] /= 2, A[l + i] /= 2;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p><strong>This code above is what Wikipedia refers to as the authentic Fast Walsh-Hadamard Transform</strong>.</p>
<h1 id="some-sidenotes">Some sidenotes</h1>
<p>Note that though FFT and FWHT shares the same idea of divide and conquer, FWHT does not require <span class="math inline">\(n\)</span> to be a power of <span class="math inline">\(2\)</span> whereas FFT does. (Well actually neither of them "require" <span class="math inline">\(n\)</span> to be a power of <span class="math inline">\(2\)</span>, but to apply FFT when <span class="math inline">\(n\)</span> is not a power of <span class="math inline">\(2\)</span> you either need to pad with <span class="math inline">\(0\)</span>s or you have to make your implementation really complicated).</p>
<p>Also, I just came to know that if we express WHT in the language of matrices and vectors, the matrix is called a Hadamard Matrix.</p>
<p>Another fact that I didn't quite understand is why the order of the inverse FWHT can be reversed.</p>
<p>For instance, when <span class="math inline">\(n=8\)</span>, after fully dividing the sequence into individual elements, we first merge <span class="math inline">\((0,1),(2,3),(4,5),(6,7)\)</span>, then we merge <span class="math inline">\((0,1,2,3),(4,5,6,7)\)</span> and finally <span class="math inline">\((0,1,2,3,4,5,6,7)\)</span>. Naturally when we do the inverse transform we have to start with <span class="math inline">\((0,1,2,3,4,5,6,7)\)</span>, recover <span class="math inline">\((0,1,2,3),(4,5,6,7)\)</span>, then recover <span class="math inline">\((0,1),(2,3),(4,5),(6,7)\)</span> and then recover the individual elements. But the popular implementation seems to suggest that the inverse transformation algorithm works in another direction as well. I am now puzzled why this is true and currently I'm just taking this for granted. Perhaps I derived the inversion in a different way than others did? If you have a simple explanation please leave a comment :)</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/Four%20Spaces/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/Four%20Spaces/" class="post-title-link" itemprop="url">线性代数四大空间笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-29 21:05:06" itemprop="dateModified" datetime="2021-04-29T21:05:06-04:00">2021-04-29</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>以下是读Gilbert Strang的<em>Introduction to Linear Algebra</em>的后回忆整理的笔记。内容大概包括第三节和第四节开头的一部分。</p>
<h1 id="四大空间">四大空间</h1>
<p>对于矩阵<span class="math inline">\(A\in \mathbb{R}^{m\times n}\)</span>，定义</p>
<ol type="1">
<li><span class="math inline">\(A\)</span>的列空间为其所有列向量的张成空间，<span class="math inline">\(A\)</span>的列向量的线性组合记作<span class="math inline">\(A\boldsymbol{x}=\boldsymbol b\)</span>——因此所有这个形式的<span class="math inline">\(\boldsymbol b\)</span>都属于<span class="math inline">\(A\)</span>的列空间。记作<span class="math inline">\(C(A)\)</span>。<span class="math inline">\(C(A)\subset\mathbb{R}^m\)</span>。</li>
<li><span class="math inline">\(A\)</span>的零空间为令其列向量线性组合为零的组合构成的空间，即所有满足<span class="math inline">\(A\boldsymbol{x}=\boldsymbol 0\)</span>的向量<span class="math inline">\(\boldsymbol x\)</span>。记作<span class="math inline">\(N(A)\)</span>。<span class="math inline">\(N(A)\subset \mathbb{R}^n\)</span>。</li>
<li><span class="math inline">\(A\)</span>的行空间为其所有行向量的张成空间。因为<span class="math inline">\(A\)</span>的行向量都是<span class="math inline">\(A^{\mathrm{T}}\)</span>的列空间，所以行空间可以记作<span class="math inline">\(C\left(A^{\mathrm T}\right)\)</span>。<span class="math inline">\(C\left(A^{\mathrm T}\right) \subset \mathbb{R}^{n}\)</span>。</li>
<li><span class="math inline">\(A\)</span>的左零空间为令其行向量线性组合为零的组合构成的空间，即所有满足<span class="math inline">\(\boldsymbol{x}^{\mathrm T}A = \boldsymbol 0^{\mathrm T}\)</span>的向量<span class="math inline">\(\boldsymbol{x}\)</span>，现在<span class="math inline">\(\boldsymbol x\)</span>在左边，所以和零空间相比就叫左零空间了。左零空间自然可以记作<span class="math inline">\(C\left(A^{\mathrm T}\right)\)</span>。<span class="math inline">\(C\left(A^{\mathrm T}\right) \subset \mathbb{R}^{m}\)</span>。</li>
</ol>
<p>以上就是线性代数当中比较重要的四个空间。虽然有四个，但本质只有“列空间”和“零空间”两种。基于矩阵的定义是颇有些枯燥的。矩阵只是线性变换比较常用且典型的形式，列空间和零空间的定义并不局限于此。归根结底，<strong>列空间是线性变换的“值域”，零空间是线性变换的“零点”</strong>。</p>
<p><sub>注：列空间在一些地方也叫做像空间（image），零空间在一些地方也叫做核（kernel）。个人认为，对于一般的线性变换，像空间的称谓比列空间更为恰当，但kernel这个词就有些莫名奇妙——我没有了解过相关的背景，但我觉得零空间的叫法更为直观。</sub></p>
<h1 id="向量空间的维度">向量空间的维度</h1>
<p>向量空间的维度定义为这个空间任何一组基包含的向量个数。这个定义蕴含的一个事实是：对于同一个向量空间，无论其基如何选取，其大小都是相同的。这里摘录一个书上的证明：</p>
<p><strong>证明：</strong> 假设向量空间<span class="math inline">\(\mathbf V\)</span>的两组基为<span class="math inline">\(\boldsymbol{v_1},\boldsymbol{v_2},\cdots,\boldsymbol{v_n}\)</span>和<span class="math inline">\(\boldsymbol{w_1}, \boldsymbol{w_2}, \cdots ,\boldsymbol{w_m}\)</span>。运用反证法，不失一般性，设<span class="math inline">\(n &lt; m\)</span>。因为<span class="math inline">\(\boldsymbol{v_1},\boldsymbol{v_2},\cdots,\boldsymbol{v_n}\)</span>是基，所以任意<span class="math inline">\(\boldsymbol{w_k}\)</span>都可以用他们的线性组合表示。即 <span class="math display">\[
\boldsymbol{w_k} = \begin{bmatrix}
    \boldsymbol{v_1} &amp;\boldsymbol{v_2} &amp;\cdots &amp;\boldsymbol{v_n}  
\end{bmatrix}\cdot \boldsymbol{a}
\]</span> （回忆一下，矩阵左乘向量等于按照向量的系数对矩阵的列向量进行线性组合）</p>
<p>进一步地， <span class="math display">\[
\begin{bmatrix}
    \boldsymbol{w_1} &amp;\boldsymbol{w_2} &amp;\cdots &amp;\boldsymbol{w_m}  
\end{bmatrix}= 
\begin{bmatrix}
    \boldsymbol{v_1} &amp;\boldsymbol{v_2} &amp;\cdots &amp;\boldsymbol{v_n}  
\end{bmatrix}\cdot A
\]</span> 不难发现，<span class="math inline">\(A\)</span>是<span class="math inline">\(n\)</span>行<span class="math inline">\(m\)</span>列的矩阵，而<span class="math inline">\(n &lt; m\)</span>，所以<span class="math inline">\(A\)</span>是扁的。在代数上，齐次线性方程组的变量多于方程数，也就是说<span class="math inline">\(A\boldsymbol{x} = \boldsymbol{0}\)</span>有非平凡解。 <span class="math display">\[
\begin{aligned}
    A\boldsymbol{x} &amp;= \boldsymbol{0} \\
    \Rightarrow \begin{bmatrix}
    \boldsymbol{v_1} &amp;\boldsymbol{v_2} &amp;\cdots &amp;\boldsymbol{v_n}  
\end{bmatrix} A\boldsymbol{x} &amp;= \boldsymbol{0} \\
    \Rightarrow \begin{bmatrix}
    \boldsymbol{w_1} &amp;\boldsymbol{w_2} &amp;\cdots &amp;\boldsymbol{w_m}  
\end{bmatrix} \boldsymbol{x} &amp;= \boldsymbol{0}
\end{aligned}
\]</span> 也就是说，<span class="math inline">\(\boldsymbol{w_1}, \boldsymbol{w_2}, \cdots ,\boldsymbol{w_m}\)</span>线性相关，推出矛盾，证毕。</p>
<h1 id="四大空间的维度">四大空间的维度</h1>
<p>一个矩阵四大空间的维度可以通过将其化简为行简化阶梯型（reduced row echelon form）来计算。行简化阶梯型的定义</p>
<ol type="1">
<li>阶梯型/上三角型矩阵</li>
<li>主元位置都是<span class="math inline">\(1\)</span></li>
<li>主元正上方都是<span class="math inline">\(0\)</span></li>
</ol>
<p>例如 <span class="math display">\[
\operatorname{rref}\left(
\begin{bmatrix}
    1 &amp;1 &amp;2 &amp;4\\
    1 &amp;2 &amp;2 &amp;5\\
    1 &amp;3 &amp;2 &amp;6
\end{bmatrix}
\right)
=
\begin{bmatrix}
    1 &amp;0 &amp;2 &amp;3\\
    0 &amp;1 &amp;0 &amp;1\\
    0 &amp;0 &amp;0 &amp;0
\end{bmatrix}
\]</span> 行简化阶梯型矩阵可以通过原矩阵的初等行变换得到（高斯消元）。</p>
<p>行简化阶梯型矩阵当中主元的个数称为矩阵的<strong>秩</strong>（rank）。我们首先注意到，对于一个行简化阶梯型矩阵<span class="math inline">\(A\)</span>，</p>
<ol type="1">
<li><strong>它列空间的维度是它的秩</strong>：主元列显然是线性无关的，而非主元列显然可以用主元列的线性组合表示（系数就写在列里面呢，比如说在上面的例子中，第四列是第一列的<span class="math inline">\(3\)</span>倍和第二列的<span class="math inline">\(1\)</span>倍之和）。</li>
<li><strong>它行空间的维度也是它的秩</strong>：行简化阶梯型的形态让我们不难发现每一个非零行都是线性无关的。原因在于每个非零行都包含一个主元，而只有那一行在主元的那一列是<span class="math inline">\(1\)</span>。</li>
<li><strong>它零空间的维度是列数与秩之差</strong>，即非主元列的个数：从方程<span class="math inline">\(A\boldsymbol x = \boldsymbol 0\)</span>的角度看，非主元列代表自由变量。通过令一个自由变量为<span class="math inline">\(1\)</span>，令其余自由变量为<span class="math inline">\(0\)</span>，并依此计算主元，我们可以得到和自由变量同样数目的若干“解向量”。这些解向量线性无关，都处在零空间中，且张成整个零空间，因此是零空间的一个基。</li>
<li><strong>它左零空间的维度是行数与秩之差</strong>，即零行的个数：非零行线性无关，因此要使行的线性组合为零所有非零行的系数必须为零，零行的系数任意，因此左零空间的维度就是零行的个数。</li>
</ol>
<p>接下来，我们观察到<strong>从一般矩阵化简为行简化阶梯型的过程不会改变矩阵的四个空间的维度</strong>：</p>
<ol type="1">
<li>初等行变换不会改变列向量之间的线性关系——对于所有列来说，行变换是“一荣俱荣，一损俱损”的。如果原来矩阵的第三列是第一列的两倍，那么行变换之后第三列还是第一列的两倍。如果原来矩阵的第二列是第一列和第三列的和，那么行变换之后这个和的关系不变。</li>
<li>因为列向量之间的线性关系没有变，所以零空间不会变，列空间的维数也不会变（但列空间本身会变）。</li>
<li>行变换是对行的线性组合，所以行简化阶梯型的行空间是原矩阵行空间的子集；而高斯消元的行变换是可逆的，所以原矩阵的行空间也是行简化阶梯型行空间的子集。因此，化简到行简化阶梯型的过程当中，行空间不变。</li>
<li>行简化阶梯型只是揭示而并非改变行向量之间的线性相关关系（行简化阶梯型中的零行表示原来的行向量和上面几行的行向量线性相关）。原来线性无关的行不会因为行变换就线性相关，反之亦然。因此左零空间的维数是不会变的。</li>
</ol>
<p>所以，一般矩阵的秩也就可以定义为其对应行简化阶梯形矩阵的秩，一般矩阵的四大空间的维度也可以用其秩计算了。</p>
<h1 id="四大空间维度的奇妙关联">四大空间维度的奇妙关联</h1>
<p>简要地总结一下，对于一个<span class="math inline">\(m\)</span>行<span class="math inline">\(n\)</span>列秩<span class="math inline">\(r\)</span>的矩阵<span class="math inline">\(A\)</span>，有</p>
<ol type="1">
<li><span class="math inline">\(\dim\left(C(A)\right) = r\)</span></li>
<li><span class="math inline">\(\dim\left(N(A)\right) = n - r\)</span></li>
<li><span class="math inline">\(\dim\left(C\left(A^{\mathrm T}\right)\right) = r\)</span></li>
<li><span class="math inline">\(\dim\left(N\left(A^{\mathrm T}\right)\right) = m - r\)</span></li>
</ol>
<p>然后我们整理一下就发现 <span class="math display">\[
\begin{aligned}
    \dim\left(C(A)\right) + \dim\left(N(A)\right) &amp;= n = \dim\left(\mathbb{R}^n\right) \\
    \dim\left(C\left(A^{\mathrm T}\right)\right) + \dim\left(N\left(A^{\mathrm T}\right)\right) &amp;= m = \dim\left(\mathbb{R}^m\right)
\end{aligned}
\]</span> 有什么意义？注意到<span class="math inline">\(A\)</span>可以看作一个线性变换，其定义域所在的空间是<span class="math inline">\(\mathbb{R}^n\)</span>。<span class="math inline">\(A^{\mathrm T}\)</span>也是如此。结合零空间和列空间的意义，我们发现了这样一个关系：</p>
<p><strong>线性变换定义域（输入）的维度，等于零空间与值域（输出）维度之和。</strong></p>
<p>好理解不？一个输入的部分维度在线性变换中“卷入零空间”消失了，只有剩下的维度反映在输出中。</p>
<p>高屋建瓴，妙不可言。这个关系具有震撼人心的力量。自己前几天在学校阅览室读到这一行，差点拍案叫绝。</p>
<p>线性代数是简洁的。</p>
<p>线性代数是优美的。</p>
<p>莫不如是。</p>
<p>这有啥用处？</p>
<p>书后有一个习题</p>
<blockquote>
<p>定义两个子向量空间<span class="math inline">\(\mathbf{V}\)</span>和<span class="math inline">\(\mathbf W\)</span>的和<span class="math inline">\(\mathbf{V} + \mathbf{W}\)</span>为二者中任意向量组合形成的空间（即二者基的并的张成空间）。</p>
<p>求证： <span class="math display">\[
\dim(\mathbf V) + \dim(\mathbf W) = \dim(\mathbf V + \mathbf W) + \dim(\mathbf V \cap \mathbf W)
\]</span></p>
</blockquote>
<p>朴素的做法设出两向量空间交的基，然后在此基础上分别拓展形成<span class="math inline">\(\mathbf V\)</span>，<span class="math inline">\(\mathbf W\)</span>，然后再证明这些分别拓展的基和两空间交的基一起是线性无关的。步骤倒也不是特别复杂。</p>
<p>但是格局低了。</p>
<p>Mike Artin提出的证明是这样的：考虑二元运算<span class="math inline">\(+\)</span>把二元组 <span class="math inline">\((\boldsymbol v\in \mathbf V, \boldsymbol w\in \mathbf W)\)</span>变换到<span class="math inline">\(\boldsymbol v + \boldsymbol w\)</span>。易证这个变换是线性的。其输入维度是<span class="math inline">\(\dim(\mathbf V) + \dim(\mathbf W)\)</span>。其值域的维度是<span class="math inline">\(\dim(\mathbf V + \mathbf W)\)</span>。其零空间是<span class="math inline">\((\boldsymbol v, \boldsymbol -v)\)</span>其中<span class="math inline">\(v\in \mathbf V \cap \mathbf W\)</span>，维度自然是<span class="math inline">\(\dim(\mathbf V \cap \mathbf W)\)</span>。因为线性变换输入的维度等于输出的维度与零空间维度之和，得证。</p>
<p><img src="/2021/07/25/Four%20Spaces/v2-d3a9348b3a938c79f5998c5bc40a1d82_hd.webp" class=""></p>
<p>太高了，我恐高症都犯了。</p>
<h1 id="四大空间的正交性">四大空间的正交性</h1>
<p>还有一点很妙的是：<strong>四大空间是两两正交的</strong>！</p>
<p>什么是正交？两个子向量空间正交当且仅当两个空间中的任意两个向量都互相垂直。（说“子向量空间”是因为两个向量谈论垂直不垂直的前提条件自然是两个向量维数一样，即同属于一个更大的向量空间）</p>
<ol type="1">
<li><p>在<span class="math inline">\(\mathbb R^n\)</span>内，零空间<span class="math inline">\(N(A)\)</span>和行空间<span class="math inline">\(C\left(A^{\mathrm T}\right)\)</span>互相正交 <span class="math display">\[
\forall A^{\mathrm T}\boldsymbol x \in C\left(A^{\mathrm T}\right),\boldsymbol y \in N(A),\quad \left(A^{\mathrm T}\boldsymbol x\right)^{\mathrm T}\boldsymbol y = \boldsymbol{x}^{\mathrm T}A\boldsymbol y = \boldsymbol{x}^{\mathrm T}\cdot \boldsymbol 0 = 0
\]</span> 又因为二者维度之和为<span class="math inline">\(n\)</span>，所以二者互补，即<span class="math inline">\(N(A) + C\left(A^{\mathrm T}\right) = \mathbb{R}^n\)</span>。</p></li>
<li><p>在<span class="math inline">\(\mathbb R^m\)</span>内，列空间<span class="math inline">\(C(A)\)</span>和左零空间<span class="math inline">\(N\left(A^{\mathrm T}\right)\)</span>互相正交 <span class="math display">\[
\forall A\boldsymbol x \in C(A),\boldsymbol y \in N\left(A^{\mathrm T}\right),\quad \left(A\boldsymbol x\right)^{\mathrm T}\boldsymbol y = \boldsymbol{x}^{\mathrm T}A^{\mathrm T}\boldsymbol y = \boldsymbol{x}^{\mathrm T}\cdot \boldsymbol 0 = 0
\]</span> 又因为二者维度之和为<span class="math inline">\(m\)</span>，所以二者互补，即<span class="math inline">\(C(A)+ N\left(A^{\mathrm T}\right) = \mathbb{R}^m\)</span>。</p></li>
</ol>
<p>于是就可以祭出Introduction to Linear Algebra 封面上的神图<del>手绘重制以表敬意</del></p>
<p><img src="/2021/07/25/Four%20Spaces/image-20210417155102490.png" class=""></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chengyuan Ma</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js" integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha512-br8H6OngKoLht57WKRU5jz3Vr0vF+Tw4G6yhNN2F3dSDheq4JiaasROPJB1wy7PxPk7kV/+5AIbmoZLxxx7Zow==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-bash.min.js" integrity="sha512-JvRd44DHaJAv/o3wxi/dxhz2TO/jwwX8V5/LTr3gj6QMQ6qNNGXk/psoingLDuc5yZmccOq7XhpVaelIZE4tsQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-c.min.js" integrity="sha512-T6Lco61aWqCKSznWkd38lf159pD0+EwZ9UCEv6ARAvaWFiy/UHtYgOmlasT8lq5Ck17ZNHzbe5eHUablTGRXxw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cmake.min.js" integrity="sha512-M99z3be36IUB5pA3DWoJvjSYaZA9BiUqf1jXzVcjntASBZFNI53oDRzdJqGzH5voybcAx5Sg8F5QyryE6afD3g==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cpp.min.js" integrity="sha512-hxZJ6OUEpUl9/o4C1gMGvrAbeqDaldBiZbs08c/V8NcU7YImBFlqJAc7Uzjf3bh2W8Wx26/dVDyPk9cUMQY0Mw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-go.min.js" integrity="sha512-SgF1uayJ2/8TV+MhLasqygnm++vYRXswmrR2ZAmUCL4pXtf+6KzUgXPpn10Y6xca658sxOQEOsoP3MChfhke5A==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-java.min.js" integrity="sha512-PWHY6Vao4E9K4LsGBYCY0ttDeiWZwuUozTbJvSy9UFHRz2J4Bl7rcWML3wEnJTVuCJhSwGne/8My5gTo/gnbpg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-json.min.js" integrity="sha512-IC7rV8RslChgByOdUFC6ePqOGn+OwJhnKC3S5AezM8DAiOdGhJMwgsIvBChsa2yuxxoPbH2+W/kjNUM1cc+jUQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-kotlin.min.js" integrity="sha512-aTozTdtORp/xxS/dhRRDfmv/p1eyEMTje96MplkSOqdbKGGvOYIlogoGdtsh/BD91vaqKoAw9M7O/DodqqudIQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-julia.min.js" integrity="sha512-eTGeKQdDzC2rPAUVfM2Fa36s9B9wp138NEhzZqJpRSdJQ66BwLUot25r2YQveCRU5uYNVfX3gckDkl4byfBIWw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-latex.min.js" integrity="sha512-6D3l3Fy8g/hr6AeK2g1rcVZHyFjCqiqgUrwy0mBZTGFd8UwVcUDhzQeIIv3eYeXDecGPTtBOS9ctyRzJyUgypQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-rust.min.js" integrity="sha512-kgT7r2HlCEO4b+Rp3nJvm+/EMBwGMvv1WMdWkb3eNgnS91llMli8Y3T1CgnD8Hifqx50Q3XLUQXDd7PzKQQtUA==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-python.min.js" integrity="sha512-wK9tQmDrstGtZqTKcyVf3h457QGMlNriKs+fHmEkiCizrq0LVovfT3v1smeT1DlQetHhdRkkX1JSuZg5LoNHJg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-nginx.min.js" integrity="sha512-/MNzg8GlnVrAau/TZClh1jxgHNX0HDgidbGnHS5x1OtbKiNoK3e0XNd1oV16xmmeDHjisa3GKLArUau+43GZ4A==" crossorigin="anonymous"></script>
<script type = "text/javascript">
    document.addEventListener('pjax:complete', function() {
        if (typeof Prism !== 'undefined') {
            Prism.highlightAll();
        }
    });
</script>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  






  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    <div class="pjax">

  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



    </div>
</body>
</html>
