<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"alan20210202.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="不务正业高中生一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="Chengyuan Ma&#39;s Blog">
<meta property="og:url" content="https://alan20210202.github.io/page/4/index.html">
<meta property="og:site_name" content="Chengyuan Ma&#39;s Blog">
<meta property="og:description" content="不务正业高中生一枚">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chengyuan Ma">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://alan20210202.github.io/page/4/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.css" integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbggqjHJeyzx88I3rfwjS38WJag/ihH7lzuGlGHpDBymLirZQ==" crossorigin="anonymous" />
<title>Chengyuan Ma's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-65HSG5NCY6"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-65HSG5NCY6');
      }
    </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Chengyuan Ma's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-pagedewarp"><a href="/dewarp/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>PageDewarp</a></li>
        <li class="menu-item menu-item-english"><a href="/english/" rel="section"><i class="fa fa-globe-americas fa-fw"></i>English</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chengyuan Ma"
      src="/avatar.png">
  <p class="site-author-name" itemprop="name">Chengyuan Ma</p>
  <div class="site-description" itemprop="description">不务正业高中生一枚</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">94</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://kalasearch.cn/" title="https:&#x2F;&#x2F;kalasearch.cn&#x2F;" rel="noopener" target="_blank">卡拉搜索</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/%E5%88%9D%E6%8E%A2%E6%8B%9F%E9%98%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/%E5%88%9D%E6%8E%A2%E6%8B%9F%E9%98%B5/" class="post-title-link" itemprop="url">拟阵笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-10-07 04:12:10" itemprop="dateModified" datetime="2018-10-07T04:12:10-04:00">2018-10-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>拟阵是很多贪心算法的基础，也可以帮助我们验证自己的贪心算法的正确性，接下来是我从<del>抄</del>《算法导论》中整理出来的一些关于拟阵的性质：</p>
<h1 id="定义">定义</h1>
<p><strong>吐槽：</strong>虽然说拟阵叫拟阵，但是这个“阵”和矩阵的阵几乎一点关系都没有（名字的由来纯粹是历史遗留问题），拟阵和矩阵的关系就像JavaScript和Java，雷锋和雷峰塔一样……</p>
<p><strong>拟阵：</strong>拟阵是一个二元组<span class="math inline">\(M = (S, I)\)</span>，其中<span class="math inline">\(S\)</span>为一个有限集，<span class="math inline">\(I\)</span>为<span class="math inline">\(S\)</span>的一个族（即子集的集合）并满足如下性质：</p>
<ol type="1">
<li><strong>遗传性：</strong>若<span class="math inline">\(B \in I\)</span>且<span class="math inline">\(A \subseteq B\)</span>，则<span class="math inline">\(A \in I\)</span>。</li>
<li><strong>交换性：</strong>若<span class="math inline">\(A \in I, B \in I\)</span>且<span class="math inline">\(|A| &lt; |B|\)</span>，那么存在元素<span class="math inline">\(x \in B \setminus A\)</span>，使得<span class="math inline">\(A \cup \{x\} \in I\)</span>。（又是一个误导性的名字……）</li>
</ol>
<p><span class="math inline">\(I\)</span>中的集合成为<span class="math inline">\(S\)</span>的<strong>独立子集</strong>。</p>
<p><strong>图拟阵：</strong>对于一个图<span class="math inline">\(G = (V, E)\)</span>，我们定义它的图拟阵为<span class="math inline">\(M_G = (S_G, I_G)\)</span>，当中<span class="math inline">\(S_G\)</span>为边集，而<span class="math inline">\(E\)</span>的子集<span class="math inline">\(A \in I_G\)</span>的当且仅当<span class="math inline">\(A\)</span>中无环（森林）。图拟阵与最小生成树有关（这也解释了为什么最小生成树的算法都是贪心）。由于森林的子图还是森林，因此该拟阵的遗传性显然。而该拟阵的交换性也在算法导论中有详细的证明，简单讲起来就是对于森林<span class="math inline">\(A, B\)</span>，<span class="math inline">\(|A| &lt; |B|\)</span>，我们知道<span class="math inline">\(A\)</span>中有<span class="math inline">\(|V| - |A|\)</span>棵树，<span class="math inline">\(B\)</span>中有<span class="math inline">\(|V| - |B|\)</span>棵树比<span class="math inline">\(A\)</span>少，因此一定存在一条边<span class="math inline">\((u, v)\)</span>使得<span class="math inline">\(u, v\)</span>在<span class="math inline">\(A\)</span>中分别属于两棵树，而在<span class="math inline">\(B\)</span>中却在一棵树上，显然<span class="math inline">\(A \cup \{(u, v)\} \in I_G\)</span>，证毕。</p>
<p><strong>拓展：</strong>对于集合<span class="math inline">\(A\)</span>，若存在元素<span class="math inline">\(x\)</span>使得<span class="math inline">\(A \cup \{x\} \in I\)</span>，则称<span class="math inline">\(x\)</span>是<span class="math inline">\(A\)</span>的一个拓展。</p>
<p><strong>最大独立子集：</strong>不存在拓展的独立子集。</p>
<p><strong>定理：</strong>所有的最大独立子集等大小。</p>
<p><strong>证明：</strong>反证， 假设存在最大独立子集<span class="math inline">\(A, B\)</span>使得<span class="math inline">\(|A| &lt; |B|\)</span>，由交换性，必然存在<span class="math inline">\(x \in B \setminus A\)</span>是<span class="math inline">\(A\)</span>的一个拓展，证毕。</p>
<p><strong>加权拟阵：</strong>若存在一个权函数<span class="math inline">\(w\)</span>为所有<span class="math inline">\(S\)</span>的元素定义了严格正的权值，则称<span class="math inline">\(M\)</span>为加权拟阵，定义独立子集<span class="math inline">\(A\)</span>的权值为： <span class="math display">\[
w(a) = \sum_{x \in A} w(x)
\]</span></p>
<h1 id="和贪心的关系">和贪心的关系</h1>
<p>很多贪心问题可以转化为<strong>在拟阵上求最大权独立子集</strong>，或者称为拟阵的<strong>最优子集</strong>。</p>
<p><strong>例：</strong>最小生成树算法当中我们可以对于边<span class="math inline">\(e\)</span>定义权重<span class="math inline">\(w(e) = l_{max} - l(e)\)</span>，其中<span class="math inline">\(l(e)\)</span>为边的长度，<span class="math inline">\(l_{max}\)</span>为一个极大的数。<em>在图拟阵上最大化独立子集权重必然等价于在图上最小化生成树边权</em>（因为生成树的边数总是固定的）。</p>
<p><strong>求解最优子集的算法：</strong>将<span class="math inline">\(S\)</span>的所有元素<span class="math inline">\(x\)</span>按照<span class="math inline">\(w(x)\)</span>从大到小排序，初始化<span class="math inline">\(A = \emptyset\)</span>，然后依次从大到小考虑每个元素<span class="math inline">\(x\)</span>，并<strong>尽可能地</strong>用<span class="math inline">\(x\)</span>去拓展<span class="math inline">\(A\)</span>，最后得到的集合必定是最优子集。</p>
<p>这个算法的贪心本质暴露无遗，接下来我们证明这个算法的正确性：</p>
<p><strong>引理1（贪心选择）：</strong>若将<span class="math inline">\(S\)</span>的元素从大到小排序，令<span class="math inline">\(x\)</span>为排序后第一个使得<span class="math inline">\(\{x\} \in I\)</span>的元素，那么必然存在一个包含<span class="math inline">\(x\)</span>的最优子集。</p>
<p><strong>证明：</strong>如果不存在<span class="math inline">\(x\)</span>，则最优子集为空，显然。</p>
<p>否则，假设我们有一个不含<span class="math inline">\(x\)</span>的最优子集<span class="math inline">\(B\)</span>，显然由遗传性，对于<span class="math inline">\(y \in B\)</span>都有<span class="math inline">\(\{y\} \in I\)</span>，又因为我们选择<span class="math inline">\(x\)</span>的方式显然由<span class="math inline">\(w(x) \ge w(y)\)</span>。我们初始化<span class="math inline">\(A = \{x\}\)</span>，利用和<span class="math inline">\(B\)</span>交换性不断拓展<span class="math inline">\(A\)</span>直至<span class="math inline">\(|A| = |B|\)</span>，此时必定存在另一元素<span class="math inline">\(y\)</span>，使得<span class="math inline">\(A \setminus \{x\} = B \setminus \{y\}\)</span>，又因为<span class="math inline">\(w(x) \ge w(y)\)</span>，那么<span class="math inline">\(A\)</span>一定不会比<span class="math inline">\(B\)</span>差，得证。</p>
<p><strong>引理2：</strong>若元素<span class="math inline">\(x\)</span>是<span class="math inline">\(A\)</span>的一个拓展，那么<span class="math inline">\(\{x\} \in I\)</span>，换而言之，<span class="math inline">\(x\)</span>是<span class="math inline">\(\emptyset\)</span>的拓展。</p>
<p><strong>证明：</strong>由定义，<span class="math inline">\(A \cup \{x\} \in I\)</span>，由遗传性显然。</p>
<p><strong>推论（逆否命题）：</strong>若<span class="math inline">\(x\)</span>不是<span class="math inline">\(\emptyset\)</span>的拓展，那它也一定不是其他非空独立子集的拓展。</p>
<p><strong>引理3（最优子结构）：</strong>在如上算法中选择完<span class="math inline">\(x\)</span>之后，在<span class="math inline">\(M = (S, I)\)</span>中寻找最优子集等价于在<span class="math inline">\(M&#39;= (S&#39;, I&#39;)\)</span>中寻找最优子集，其中： <span class="math display">\[
\begin{aligned}
S&#39; &amp;= \{y \mid \{x, y\} \in S\} \\
I&#39; &amp;= \{B \mid B \subseteq S \setminus \{x\}, B \cup \{x\} \in I\}
\end{aligned}
\]</span> 即<strong>我们可以忽略<span class="math inline">\(x\)</span>继续我们的算法。</strong></p>
<p><strong>证明：</strong>如果我们在<span class="math inline">\(M&#39;\)</span>当中选出了最优子集<span class="math inline">\(A&#39;\)</span>，则显然<span class="math inline">\(A&#39; \cup \{x\}\)</span>是<span class="math inline">\(M\)</span>的独立子集，并且由<span class="math inline">\(x\)</span>的选择方式可知也是最优子集，证毕。</p>
<p><strong>贪心正确性的证明：</strong>由引理2的推论，我们知道贪心算法没能一开始用来拓展的<span class="math inline">\(x\)</span>一定在后面也没有用。由引理3，选择完<span class="math inline">\(x\)</span>之后我们把问题缩小，还可以进一步贪心，此时贪心实质上是在<span class="math inline">\(M&#39;\)</span>上寻找最优子集。证毕。</p>
<p>从以上讨论我们可以看出，对于一类问题，如果我们可以以某种方式把它规约为在拟阵上求取最优子集，那你一定可以使用贪心解决，这给很多贪心算法（例如Kruskal）提供了理论支持。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/WebAssembly/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/WebAssembly/" class="post-title-link" itemprop="url">WebAssembly初体验</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-01-14 08:40:14" itemprop="dateModified" datetime="2020-01-14T08:40:14-05:00">2020-01-14</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我在之前用JavaScript实现了PageDewarp的核心算法。但是众所周知，JavaScript作为一门解释性语言并不适合运算密集型的任务，导致算法运行一次要30秒钟……这个效率虽然不能算特别差，我还是不满意的。所以又花了两天学习了WebAssembly把瓶颈算法用C重写了，现在在手机端一次也只需要1秒左右，效果自然是极好的。但是WebAssembly毕竟还是新科技，和现有的一些框架融合的确实不算好，在应用的过程中踩了非常多的坑，尤其是对于我这种1个月前还是Web萌新的人更是新坑老坑一起踩到怀疑人生（悲）。</p>
<h1 id="webassembly-emscripten">WebAssembly &amp; Emscripten</h1>
<p>什么是WebAssembly？</p>
<p>WebAssembly是一种通过将静态的系统编程语言（比如说C，C++，Rust）AOT编译成一种基于栈虚拟机架构的字节码，然后在浏览器端再次实时JIT执行，来逼近这些语言native performance的技术。</p>
<p>(<em>吐槽：</em>我最初看到WebAssembly的时候有一种莫名的，很强烈的Java Applet的既视感。)</p>
<p>和CLR类似，WebAssembly只是字节码的标准，至于将特定语言编译成字节码的实现则是那些语言自己的事情。在目前的生态下，C和C++有名为Emscripten的基于LLVM的编译器，Rust则有它们自己的一套toolchain，两者都处于勉强凑活的水平。</p>
<p>就我个人而言我其实觉得Rust在这方面做得最好，官方维护，官方文档。wasm_bindgen也给自定义数据结构类型提供了很好的支持，非常适合大项目开发。但是我只是实现一个小算法，Rust的那一套太重了，有一种boilerplate会比真正代码多的预感，所以我最终选择了C（至于为什么不是C++，那是因为name mangling已经破坏了我对它FFI能力产生了非常深的心理阴影）。</p>
<p>前面说了，C对接WebAssembly的工具链是Emscripten。现在Emscripten的生态已经相对比较成熟了，跟着官方的<a target="_blank" rel="noopener" href="https://emscripten.org/docs/getting_started/downloads.html">Getting Started</a>走基本上就没有问题。写C的时候就按照正常的写法（我感觉Emscripten对于libc里面的大多数常用函数都做了适配）写就可以了。算法的代码很短：</p>
<pre class="line-numbers"><code class="language-c">#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;emscripten.h&gt;

typedef struct v3 &#123;
    float x, y, z;
&#125; v3;
v3 add(v3 a, v3 b) &#123;
    return (v3) &#123; .x = a.x + b.x, .y = a.y + b.y, .z = a.z + b.z &#125;;
&#125;
v3 mul(v3 a, float k) &#123;
    return (v3) &#123; .x = a.x * k, .y = a.y * k, .z = a.z * k &#125;;
&#125;
v3 a2v(float *a) &#123;
    return (v3) &#123; .x = a[0], .y = a[1], .z = a[2] &#125;;
&#125;
EMSCRIPTEN_KEEPALIVE
unsigned char *dewarp(
        unsigned char *src, int srcWidth, int srcHeight,
        int dstWidth, int dstHeight,
        float *cpX, float *cpY,
        float *upperLeft, float *baseVec, float *normalVec, 
        float *vertical, float d
        ) &#123;
    v3 ul = a2v(upperLeft);
    v3 bv = a2v(baseVec);
    v3 nv = a2v(normalVec);
    v3 vt = a2v(vertical);
    unsigned char *dst = malloc(4 * dstWidth * dstHeight);
    for (int x = 0; x &lt; dstWidth; x++) &#123;
        v3 top = add(ul, add(mul(bv, cpX[x]), mul(nv, cpY[x])));
        for (int y = 0; y &lt; dstHeight; y++) &#123;
            v3 c = add(top, mul(vt, (float)y / dstHeight));
            float sx = c.x / (1 + c.z / d); 
            float sy = c.y / (1 + c.z / d); 
            sx = (sx + 0.5f) * srcWidth;
            sy = sy * srcWidth + 0.5f * srcHeight;
            int di = (y * dstWidth + x) * 4;
            int si = ((int)round(sy) * srcWidth + (int)round(sx)) * 4;
            dst[di] = src[si];
            dst[di + 1] = src[si + 1];
            dst[di + 2] = src[si + 2];
            dst[di + 3] = src[si + 3];
        &#125;
    &#125;
    return dst;
&#125;</code></pre>
<p>注意函数前面加的<code>EMSCRIPTEN_KEEPALIVE</code>宏，这个宏一方面导出了函数，另一方面防止LLVM过于智能把这段函数当成dead code消除掉或者内联掉。如果不用这个宏，就需要在编译选项里加上<code>-s EXPORTED_FUNCTIONS="['_dewarp']"</code>。注意<strong>Emscripten在导出函数名称的时候都在前面加上了<code>_</code></strong>，直接引用的时候不能漏掉。</p>
<p>另外一个要注意的点是程序内部是无法直接访问JavaScript里面的变量的，我用的是Vue，那就更不用说了。所有要用到的context都需要在参数里面传进来。而目前来说，Emscripten对于自定义结构体之类的支持很少，传参基本上只支持primitive types和指针。除此以外，在指针方面吧，Emscripten并没有自动帮我们做好数组的转换，这一部分需要自行编写，一维的还容易一点，高维的写起来就更难受了。可以参考这个<a target="_blank" rel="noopener" href="https://github.com/Planeshifter/emscripten-examples">repo</a>。</p>
<pre class="line-numbers"><code class="language-javascript">function copyToHeap(typedArray) &#123;
  let size = typedArray.length * typedArray.BYTES_PER_ELEMENT;
  let offset = Module._malloc(size);
  Module.HEAPU8.set(new Uint8Array(typedArray.buffer), offset);
  return offset;
&#125;

Module[&quot;dewarp&quot;] = function(src, srcWidth, srcHeight, dstWidth, dstHeight, cpX, cpY, upperLeft, baseVec, normalVec, vertical, d) &#123;
  let pSrc = copyToHeap(src);
  let pCpX = copyToHeap(cpX), pCpY = copyToHeap(cpY);
  let pUL = copyToHeap(upperLeft), pBV = copyToHeap(baseVec);
  let pNV = copyToHeap(normalVec), pVertical = copyToHeap(vertical);
  let pDst = Module._dewarp(pSrc, srcWidth, srcHeight, dstWidth, dstHeight, pCpX, pCpY, pUL, pBV, pNV, pVertical, d);
  let ret = new Uint8ClampedArray(4 * dstWidth * dstHeight);
  ret.set(new Uint8ClampedArray(Module.HEAPU8.buffer, pDst, 4 * dstWidth * dstHeight));
  Module._free(pSrc); Module._free(pDst);
  Module._free(pCpX); Module._free(pCpY);
  Module._free(pUL); Module._free(pBV);
  Module._free(pNV); Module._free(pVertical);
  return ret;
&#125;;</code></pre>
<p>WebAssembly内部是简单的线性内存空间，可以使用<code>Module.HEAPU8</code>来获取一个<code>U8</code>的View。调用的时候直接<code>Module._dewarp</code>，依然注意要在C函数名前面加<code>_</code>。官方还提供了了<code>ccall</code>的调用方式，会自动对字符串做转码，在这里并不需要。在调用时指针一律当做整数处理。在返回时直接把返回数组在内存中的数据复制一份就行了。之后记得全部<code>free</code>掉就行了。</p>
<p>编译的指令是：</p>
<pre class="line-numbers shell"><code class="language-none">emcc -O3 dewarp.c -o dewarp.js --post-js dewarp_post.js \
    -s ENVIRONMENT=&quot;web&quot; \
    -s MODULARIZE=1 \
    -s ALLOW_MEMORY_GROWTH=1</code></pre>
<p>选项的意义如下：</p>
<ul>
<li><code>-O3</code>：优化级别，和一般的C编译器类似。<code>-O3</code>是最激进的优化之一。除了在字节码上优化还会minify生成的接口js。</li>
<li><code>-o dewarp.js</code>：生成的接口文件名。</li>
<li><code>--post-js dewarp_post.js</code>：把<code>dewarp_post.js</code>（也就是上面<code>copyToHeap</code>所在的文件）附到生成的<code>dewarp.js</code>后。类似地还有<code>--pre-js</code>。</li>
<li><code>-s ENVIRONMENT="web"</code>：默认Emscripten在编译接口文件的时候会同时加入node和浏览器环境下不同的加载方案。我们这边只需要浏览器环境，加上这个选项有助于减少生成的接口js大小。何况在使用webpack的情况下不开这个webpack会傻乎乎地把<code>fs</code>加到dependencies里面然后报错，这个时候要不这里加选项要不webpack那里额外配置二选一。</li>
<li><code>-s MODULARIZE=1</code>：在写Emscripten的js端的文件的时候<code>Module</code>是一个关键的变量。在默认情况下Emscripten把它定义为全局变量。这会造成命名污染。如果加上这个选项，编译出来的代码就相当于是在一个大的<code>function</code>里面。这个函数接受一个预先加了点东西的<code>Module</code>对象，加上自己的私货（还有我们在<code>dewarp_post.js</code>里面定义的helper函数）之后返回完成的<code>Module</code>。确保不会产生命名污染的问题。同时Emscripten会自动把这个大函数设成<code>module.exports</code>。</li>
<li><code>-s ALLOW_MEMORY_GROWTH=1</code>：默认的内存空间是固定的，这个选项允许内存空间的扩张。图像处理算法占的内存比较大，不加这个选项会爆内存。</li>
</ul>
<p>另外还有两个常用的选项：</p>
<ul>
<li><code>-s EXPORTED_FUNCTIONS="['_foo', ...]"</code>：指定要导出的函数，这里的名称要加下划线。等号右边是js列表的写法。如果在C源码要导出的函数前加上<code>EMSCRIPTEN_KEEPALIVE</code>的话这里就不需要再指明了。</li>
<li><code>-s EXTRA_EXPORTED_RUNTIME_METHODS="['ccall', ...]"</code>：默认Emscripten不会把很多API导出，因为这有助于减小接口文件的大小，但是如果要用<code>ccall</code>和<code>cwrap</code>之类的API的话就要在这里指明。</li>
</ul>
<p>（自己一开始<code>-s</code>开头的选项一个都不知道要加，然后疯狂出问题，就暴毙了）</p>
<p>编译完之后会生成两个文件，一个是接口的js文件，一个是wasm文件，里面存放的就是字节码了。</p>
<h1 id="javascript端的磨合">Javascript端的磨合</h1>
<p>Emscripten上的教程在这里说得非常轻巧：只要<code>&lt;script/&gt;</code>引入，然后接口js会自动加载wasm文件，然后调用方法就行了。这样做是没错，但是忽略了一点：大家现在都在用webpack之类的打包器，这类打包器面对WebAssembly需要特殊的配置才能确保其顺利运行。</p>
<p>我之前一直避免自己动webpack配置这种东西，因为我觉得Vue CLI帮我安顿得挺好的自己一搞搞不好怎么挂的都不知道。刚开始配置我这个萌新就真马上跌进坑里了：网上教程里面写的都是<code>webpack.config.js</code>，然后我一直试都没有效果，纳闷了很久，才发觉因为我用的是Vue CLI，所以配置都在<code>vue.config.js</code>里面：</p>
<pre class="line-numbers"><code class="language-javascript">module.exports = &#123;
  ...
  configureWebpack: &#123;
    // 原来webpack.config.js的内容
  &#125;
&#125;;</code></pre>
<p><del>这种坑有经验的开发者都不会进去吧？还是我太菜了</del></p>
<p>同时注意如果开启ESLint的话，注意一定要在<code>.eslintignore</code>文件里面加上接口js，一方面自动生成的js不需要lint，另一方面由于上下文不足lint下来会有很多误报。</p>
<p>在webpack的配置上，对于两种文件分别采取如下策略：</p>
<ul>
<li>wasm文件就是普通文件，应该使用<code>file-loader</code>。</li>
<li>js文件由于采用<code>-s MODULARIZE=1</code>编译开关，会把一个函数挂载到<code>module.exports</code>上，这个时候就要用<code>exports-loader</code>加载。</li>
</ul>
<p>我这个萌新一开始对于loader的概念很困惑。因为我一开始觉得webpack一个打包的东西有哪里需要load呢？在那里用这些loader呢？后来意识到loader机制的意思是把</p>
<pre class="line-numbers"><code class="language-javascript">import foo from &quot;bar&quot;</code></pre>
<p>转变成</p>
<pre class="line-numbers"><code class="language-javascript">var foo = some_loader(&quot;bar&quot;);</code></pre>
<p>这件事情其实是挺有意思的。静态语言写多了就觉得模块导入语句应该有固定的语义才对，结果到JavaScript这里发现<code>import</code>其实纯粹是类似语法糖的元素，语义不固定=_=。</p>
<p>倒腾一圈下来我项目当中的webpack配置如下：</p>
<pre class="line-numbers"><code class="language-javascript">&#123;
  module: &#123;
    rules: [
      &#123;
        test: /dewarp\.js$/,
        loader: &quot;exports-loader&quot;
      &#125;,
      &#123;
        test: /dewarp\.wasm$/,
        type: &quot;javascript/auto&quot;,
        loader: &quot;file-loader&quot;,
      &#125;
    ]
  &#125;,
&#125;</code></pre>
<p>还没完，在javascript代码里面这样写：</p>
<pre class="line-numbers"><code class="language-javascript">// 指定用exports-loader，所以wasmInterface现在就是Emscripten导出的那个返回Module的大函数
import wasmInterface from &quot;./wasm/dewarp.js&quot;
// 指定用file-loader，所以wasmBytecode现在就是指向wasm文件的路径
import wasmBytecode from &quot;./wasm/dewarp.wasm&quot;

let wasmModule = wasmInterface(&#123;
  // Emscripten导出的函数可以接受一个已经塞了东西的对象作为Module的基础
  // 可以在里面定义Emscripten文档里面写的一些特殊函数，比如说这里的locateFile
  // 如果定义了，在加载字节码的时候就会调用这个函数获取path的真实有效值，因为webpack
  // 调整了文件位置关系，而Emscripten生成接口脚本时写入的是生成时的文件位置，因此我们
  // 就必须在这个函数里告诉它真实的文件位置，不然会404翻车
  locateFile(path) &#123;
    return path.endsWith(&quot;.wasm&quot;) ? wasmBytecode : path;
  &#125;
&#125;); // 创建对象之后自动加载
wasmModule.onRuntimeInitialized = () =&gt; &#123;
  // 文件加载完毕
&#125;;</code></pre>
<p>在这么一番操作之后，我才终于可以在原来的地方写上</p>
<pre class="line-numbers"><code class="language-javascript">wasmModule.dewarp(...) // 调用dewarp_post.js里面的helper函数，间接调用C函数</code></pre>
<p>整个过程挺折腾的，但事实也确实证明这么折腾一番是值得的，性能提升三十倍，非常愉悦。</p>
<h1 id="结论">结论</h1>
<p>总体下来我觉得WebAssembly现在技术上已经趋于成熟了，像我第一次积累了经验之后以后再用WebAssembly不踩那些坑的话体验是相当不错的。当然对于Emscripten来说在调用时的转化上目前还不是那么智能，还有很多要改进的地方（这也可能和JavaScript太放飞自我的设计有关？），使用Rust的开发我还没有试过，看官方文档上Game of Life的demo觉得非常有意思（我觉得Rust真的是绝对的后起之秀，各种方面的）。</p>
<p>更有意思的是，这还不是优化的终点。我听说WebAssembly还有一个SIMD的提案，这似乎又可以让性能提升若干个台阶（当然我不知道目前的JIT VM能不能根据字节码进行自动向量化）。还真的就是啥native上的技术都往web端搬，浏览器也是啥活现在都要揽=_=，估计过几年就真成一个小的操作系统了（ChromeOS: Hold my chrome :）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/Wallis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/Wallis/" class="post-title-link" itemprop="url">数学课划水整活之Wallis乘积公式的一种证明</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-16 01:07:28" itemprop="dateModified" datetime="2021-03-16T01:07:28-04:00">2021-03-16</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>今天数学课讲了一点组合数的性质，因为太简单了所以稍微划了一会水。</p>
<p>结果发现自己整出来了一个算<span class="math inline">\(\pi\)</span>的式子？</p>
<p>化简以后发现是传说中的Wallis公式？</p>
<p>虽然原理一样的证明Wiki上有提到但是还是当场惊了。</p>
<p>简单记一笔吧。</p>
<p>一切的开端是今年寒假做夏校申请的时候证明过的一个极限 <span class="math display">\[
\lim_{n\to\infty} 2^{-2n}\binom{2n}{n} = 0
\]</span> 当时是用斯特林近似暴力代换进行证明（现在看来并不严谨） <span class="math display">\[
\begin{aligned}
    \lim_{n\to\infty} \binom{2n}{n} \frac{\left[\sqrt{2\pi n} \left(n \over e\right)^n \right]^2} {\sqrt{4\pi n} \left(2n \over e\right)^{2n}} &amp;= \lim_{n\to\infty} \left[\frac{\sqrt{2\pi n} \left(n \over e\right)^n}{n!}\right]^2 \frac{(2n)!}{\sqrt{4\pi n} \left(2n \over e\right)^{2n}} \\
    &amp;= 1 \\     
    \Rightarrow 
    \lim_{n\to\infty} 2^{-2n}\binom{2n}{n} &amp;= \lim_{n\to\infty} 2^{-2n}\frac {\sqrt{4\pi n} \left(2n \over e\right)^{2n}}{\left[\sqrt{2\pi n} \left(n \over e\right)^n\right]^2} \cdot \lim_{n\to\infty} \binom{2n}{n} \frac{\left[\sqrt{2\pi n} \left(n \over e\right)^n\right]^2} {\sqrt{4\pi n} \left(2n \over e\right)^{2n}} \\
    &amp;=  \lim_{n\to\infty} 2^{-2n}\frac {\sqrt{4\pi} 2^{2n}n^{2n+\frac{1}{2}}e^{-2n}}{2\pi n^{2n+1}e^{-2n}} \\
    &amp;= \lim_{n\to\infty} \frac{1}{\sqrt{\pi n}}\\
    &amp;= 0
\end{aligned}
\]</span> 今天划水的时候发现由以上过程，这个极限可以加强为 <span class="math display">\[
\lim_{n\to\infty} \frac{\sqrt{\pi n}\binom{2n}{n}}{2^{2n}} = 1
\]</span> 稍作整理即得 <span class="math display">\[
\lim_{n\to\infty} \frac{2^{4n}}{n\binom{2n}{n}^2} = \pi
\]</span> 拿卡西欧摁了一下，发现式子没有假，虽然收敛得有亿点点慢但确实是收敛到了<span class="math inline">\(\pi\)</span>。</p>
<p>关键是这个式子我似乎没见过啊？<del>内心直接膨胀，可把我牛逼坏了。</del></p>
<p>因为形式看起来较复杂，接着我就想可不可以通过邻项作比的方式变换一下形态 <span class="math display">\[
\begin{aligned}
\frac{2^{4n}}{n\binom{2n}{n}^2} \Bigg / \frac{2^{4(n-1)}}{(n-1)\binom{2n-2}{n-1}^2} &amp;= \frac{16(n-1)}{n} \left[\binom{2n-2}{n-1} \bigg/ \binom{2n}{n}\right]^2 \\
&amp;= \frac{16(n-1)}{n} \left[\frac{n^2}{2n(2n-1)}\right]^2 \\
&amp;= \frac{16n(n-1)}{(4n-2)^2} \\
&amp;= \frac{2n}{2n-1}\cdot \frac{2n-2}{2n-1}
\end{aligned}
\]</span> 这个形式似曾相识，结合上式把式子化为连乘积的形式，要素察觉！ <span class="math display">\[
\begin{aligned}
\frac{2^{4n}}{n\binom{2n}{n}^2} &amp;= \frac{2^{4}}{1\binom{2}{1}^2} \cdot \frac{2}{3} \cdot \frac{4}{3} \cdot \frac{4}{5} \cdot \frac{6}{5} \cdots \frac{2n-2}{2n-1}\cdot \frac{2n}{2n-1} \\
&amp;= 4\cdot \frac{2}{3} \cdot \frac{4}{3} \cdot \frac{4}{5} \cdot \frac{6}{5} \cdots \frac{2n-2}{2n-1}\cdot \frac{2n}{2n-1}
\end{aligned}
\]</span> 这不就是Wallis乘积公式嘛？翻出Wikipedia一看： <span class="math display">\[
\begin{aligned}
\frac{\pi}{2} &amp;=\prod_{n=1}^{\infty} \frac{4 n^{2}}{4 n^{2}-1}=\prod_{n=1}^{\infty}\left(\frac{2 n}{2 n-1} \cdot \frac{2 n}{2 n+1}\right) \\
&amp;=\left(\frac{2}{1} \cdot \frac{2}{3}\right) \cdot\left(\frac{4}{3} \cdot \frac{4}{5}\right) \cdot\left(\frac{6}{5} \cdot \frac{6}{7}\right) \cdot\left(\frac{8}{7} \cdot \frac{8}{9}\right) \cdots
\end{aligned}
\]</span> 完全一致，直接得证。</p>
<p>哇，也就是说我划着水就把Wallis公式不严谨地整了一遍？</p>
<p><em>果然还是要膨胀.jpg</em></p>
<p>以前觉得这个式子很高端的，现在有种莫名的幻灭感。</p>
<p>但是写到这的时候多看了一眼，发现斯特林逼近的一个推导里用到了Wallis公式？</p>
<p>突然有点不确定这算不算是循环论证了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/TreapMultiset/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/TreapMultiset/" class="post-title-link" itemprop="url">Reinventing the Wheel: A Drop-in STL Multiset Alternative Using Treap</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-15 23:30:50" itemprop="dateModified" datetime="2021-03-15T23:30:50-04:00">2021-03-15</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>It turns out that writing a STL container from scratch is mostly a tedious physical labor.</p>
</blockquote>
<p>STL is created to save C++ programmers the time of reinventing wheels. Unfortunately, many STL data structures, most notably self-balancing BSTs (aka. <code>std::(multi)set</code>), are not extendable and are by itself too limited to be used in the context of competitive programming, forcing us to write our own BSTs again and again in competitions.</p>
<p>There comes the fact I find really interesting: A quick and dirty self-balancing BST implementation written during a competition is only about 50-60 lines long, while the STL implementation of <code>std::set</code> and <code>std::multiset</code> is usually more than a thousand-lines long in total.</p>
<p>It does make me wonder: what makes this huge difference? And, will the code of our BST bloat as well if we write it the STL way -- with generics, iterators, and all the necessary bits and pieces as specified in the reference?</p>
<p>To answer my question, I have here tried creating my implementation of multiset using treap as the underlying data structure. The result, <code>treap_multiset</code>, is almost a drop-in replacement to <code>std::multiset</code>. The few places where it does not conform to the C++ standard are:</p>
<ol type="1">
<li>It is currently not allocator-aware, so all allocator-related features are not implemented.</li>
<li><code>emplace</code> and <code>emplace_hint</code> are not implemented.</li>
<li>All operations that have logarithmic time complexity in <code>std::multiset</code> still have logarithmic time complexity here, but only in the average sense (because treap is a randomized data structure), and could have linear worst-case time complexity (though very, very, very unlikely).</li>
<li><code>void erase(iterator)</code> takes amortized logarithmic time instead of constant time.</li>
<li>A few uncommonly-used member types are missing.</li>
</ol>
<p><code>treap_multiset</code> also supports two new operations that are not supported in the original <code>std::multiset</code>:</p>
<ol type="1">
<li><pre class="line-numbers"><code class="language-cpp">   size_type rank(iterator it) const;
   size_type rank(const_iterator it) const;</code></pre>
<p>Both take average logarithmic time and return the rank / position of the iterator.</p></li>
<li><pre class="line-numbers"><code class="language-cpp">   iterator at(size_type index);
   const iterator at(size_type index) const;</code></pre>
<p>Both take average logarithmic time and return the iterator at the specified index/position.</p></li>
</ol>
<p>The code is shown below:</p>
<pre class="line-numbers"><code class="language-cpp">#include &lt;stdexcept&gt;
#include &lt;random&gt;
#include &lt;algorithm&gt;

static std::random_device random_device;
static std::mt19937_64 random_engine(random_device());

template &lt;typename T&gt;
struct treap_node &#123;
    using rand_weight_type = decltype(random_engine)::result_type;
    using size_type = std::size_t;

    treap_node *left, *right, *parent;
    rand_weight_type weight;
    size_type size;
    T value;

    treap_node(const T &amp;value): left(nullptr), right(nullptr), parent(nullptr),
        weight(random_engine()), size(1), value(value) &#123;&#125;

    treap_node(treap_node *left, treap_node *right, treap_node *parent, 
        rand_weight_type weight, size_type size, const T &amp;value): 
        left(left), right(right), parent(parent), weight(weight),
        size(size), value(value) &#123;&#125;

    void update_size() &#123;
        size = 1 + (left ? left-&gt;size : 0) + (right ? right-&gt;size : 0);
    &#125;
&#125;;

#define IMPL_ITERATOR_MOVE_NEXT do &#123; \
    if (!node) break; \
    if (node-&gt;right) &#123; \
        node = node-&gt;right; \
        while (node &amp;&amp; node-&gt;left) node = node-&gt;left; \
    &#125; else &#123; \
        bool from_right = true; \
        while (from_right) &#123; \
            if (!node-&gt;parent) &#123; node = nullptr; break; &#125; \
            from_right = node-&gt;parent-&gt;right == node; \
            node = node-&gt;parent; \
        &#125; \
    &#125; \
&#125; while (0)

#define IMPL_ITERATOR_MOVE_PREV do &#123; \
    if (!node) break; \
    if (node-&gt;left) &#123; \
        node = node-&gt;left; \
        while (node &amp;&amp; node-&gt;right) node = node-&gt;right; \
    &#125; else &#123; \
        bool from_left = true; \
        while (from_left) &#123; \
            if (!node-&gt;parent) &#123; node = nullptr; break; &#125; \
            from_left = node-&gt;parent-&gt;left == node; \
            node = node-&gt;parent; \
        &#125; \
    &#125; \
&#125; while (0)

#define TREAP_ITERATOR_DECL(name, qualifier, inc, dec) \
template &lt;typename T&gt; struct name &#123; \
    qualifier treap_node&lt;T&gt; *node; bool past_the_end; \
    name(): node(nullptr), past_the_end(true) &#123;&#125; \
    name(qualifier treap_node&lt;T&gt; *node, bool past_the_end) \
        : node(node), past_the_end(past_the_end) &#123;&#125; \
    name(qualifier treap_node&lt;T&gt; *node): node(node), past_the_end(false) &#123;&#125; \
    qualifier T &amp;operator *() qualifier &#123; \
        if (!node || past_the_end) \
            throw std::runtime_error(&quot;dereferencing null/past-end iterator&quot;); \
        return node-&gt;value; \
    &#125; \
    bool operator ==(const name&lt;T&gt; &amp;b) const &#123; \
        return node == b.node &amp;&amp; past_the_end == b.past_the_end; \
    &#125; \
    bool operator !=(const name&lt;T&gt; &amp;b) const &#123; \
        return node != b.node || past_the_end != b.past_the_end; \
    &#125; \
    name&lt;T&gt; &amp;operator ++() &#123; \
        qualifier treap_node&lt;T&gt; *backup = node; \
        IMPL_ITERATOR_MOVE_##inc; \
        if (!node) past_the_end = true, node = backup; \
        return *this; \
    &#125; \
    name&lt;T&gt; operator ++(int) &#123; \
        name&lt;T&gt; ret(*this); \
        return ++(*this), ret; \
    &#125; \
    name&lt;T&gt; &amp;operator --() &#123; \
        if (past_the_end) past_the_end = false; \
        else IMPL_ITERATOR_MOVE_##dec; \
        if (!node) \
            throw std::runtime_error(&quot;can&#39;t decrement at the beginning&quot;); \
        return *this; \
    &#125; \
    name&lt;T&gt; operator --(int) &#123; \
        name&lt;T&gt; ret(*this); \
        return --(*this), ret; \
    &#125; \
&#125;

TREAP_ITERATOR_DECL(treap_iterator, /* NO QUALIFIER */, NEXT, PREV);
TREAP_ITERATOR_DECL(reverse_treap_iterator, /* NO QUALIFIER */, PREV, NEXT);
TREAP_ITERATOR_DECL(const_treap_iterator, const, NEXT, PREV);
TREAP_ITERATOR_DECL(const_reverse_treap_iterator, const, PREV, NEXT);

template &lt;typename T, typename Compare = std::less&lt;T&gt;&gt;
class treap_multiset &#123;
public:
    using key_type = T;
    using value_type = T;
    using size_type = typename treap_node&lt;T&gt;::size_type;
    using key_compare = Compare;
    using value_compare = Compare;
    using node_type = treap_node&lt;T&gt;*;
    using iterator = treap_iterator&lt;T&gt;;
    using reverse_iterator = reverse_treap_iterator&lt;T&gt;;
    using const_iterator = const_treap_iterator&lt;T&gt;;
    using const_reverse_iterator = const_reverse_treap_iterator&lt;T&gt;;

    treap_multiset(): root(nullptr) &#123;&#125;

    treap_multiset(const treap_multiset &amp;b): root(deep_copy(b.root)), comp(b.comp) &#123;&#125;

    treap_multiset(treap_multiset &amp;&amp;b): root(b.root), comp(b.comp) &#123;&#125;

    ~treap_multiset() &#123; if (root) recursive_free(root); &#125;

    bool empty() const &#123; return root == nullptr; &#125;

    size_type size() const &#123; return root ? root-&gt;size : 0; &#125;

    size_type max_size() const &#123; return 0x7FFFFFFF; &#125;

    key_compare key_comp() const &#123; return comp; &#125;

    value_compare value_comp() const &#123; return comp; &#125;

    iterator begin() 
        &#123; return iterator(leftmost(root)); &#125;

    const_iterator begin() const 
        &#123; return const_iterator(leftmost(root)); &#125;

    const_iterator cbegin() const 
        &#123; return const_iterator(leftmost(root)); &#125;

    iterator end() 
        &#123; return iterator(rightmost(root), true); &#125;

    const_iterator end() const 
        &#123; return const_iterator(rightmost(root), true); &#125;

    const_iterator cend() const 
        &#123; return const_iterator(rightmost(root), true); &#125;

    reverse_iterator rbegin() 
        &#123; return reverse_iterator(rightmost(root)); &#125;

    const_reverse_iterator rbegin() const 
        &#123; return const_reverse_iterator(rightmost(root)); &#125;

    const_reverse_iterator crbegin() const 
        &#123; return const_reverse_iterator(rightmost(root)); &#125;

    reverse_iterator rend() 
        &#123; return reverse_iterator(leftmost(root), true); &#125;

    const_reverse_iterator rend() const 
        &#123; return const_reverse_iterator(leftmost(root), true); &#125;

    const_reverse_iterator crend() const 
        &#123; return const_reverse_iterator(leftmost(root), true); &#125;

    iterator insert(const value_type &amp;value) &#123;
        node_type left, right;
        split_le(root, value, left, nullptr, right, nullptr);
        node_type temp = new treap_node&lt;T&gt;(value);
        root = join(join(left, temp), right);
        return iterator(temp);
    &#125;

    iterator insert(iterator position, const value_type &amp;value) 
        &#123; return insert(value); &#125;

    template &lt;typename II&gt;
    void insert(II first, II last) &#123; 
        for (; first != last; first++) 
            insert(*first); 
    &#125;

    size_type rank(iterator it) const &#123; return rank(it.node); &#125;
    
    size_type rank(const_iterator it) const &#123; return rank(it.node); &#125;

    iterator at(size_type index) &#123;
        if (index &lt; 0 || index &gt; size()) return end();
        return iterator(at_internal(index));
    &#125;

    const_iterator at(size_type index) const &#123;
        if (index &lt; 0 || index &gt; size()) return end();
        return const_iterator(at_internal(index));
    &#125;

    void erase(iterator pos) &#123;
        assert_valid(pos);
        node_type a, b, c;
        size_type rank = this-&gt;rank(pos.node);
        split_size(root, rank, a, nullptr, c, nullptr);
        split_size(a, rank - 1, a, nullptr, b, nullptr);
        root = join(a, c);
        // assert(b == pos.node);
        delete b;
    &#125;

    size_type erase(const value_type &amp;key) &#123;
        node_type a, b, c;
        split_le(root, key, a, nullptr, c, nullptr);
        split_re(a, key, a, nullptr, b, nullptr);
        root = join(a, c);
        if (b) &#123;
            size_type ret = b-&gt;size;
            recursive_free(b);
            return ret;
        &#125;
        return 0;
    &#125;

    void erase(iterator first, iterator last) &#123;
        size_type rank_first = rank(first);
        size_type rank_last = rank(last);
        node_type a, b, c;
        split_size(root, rank_last, a, nullptr, c, nullptr);
        split_size(a, rank_last - 1, a, nullptr, b, nullptr);
        root = join(a, c);
        if (b) recursive_free(b);
    &#125;

    void clear() &#123; if (root) recursive_free(root); &#125;

    void swap(treap_multiset &amp;b) &#123; swap(root, b.root); &#125;

    iterator find(const value_type &amp;key) &#123;
        node_type ret = find_internal(key);
        return ret ? iterator(ret) : end();
    &#125;

    const_iterator find(const value_type &amp;key) const &#123;
        node_type ret = const_cast&lt;treap_multiset&lt;T&gt;*&gt;(this)-&gt;find_internal(key);
        return ret ? const_iterator(ret) : end();
    &#125;

    size_type count(const value_type &amp;key) const &#123;
        node_type a, b, c;
        treap_multiset&lt;T&gt; *thiz = const_cast&lt;treap_multiset&lt;T&gt;*&gt;(this);
        thiz-&gt;split_le(root, key, a, nullptr, c, nullptr);
        thiz-&gt;split_re(root, key, a, nullptr, b, nullptr);
        size_type ret = b ? b-&gt;size : 0;
        thiz-&gt;root = thiz-&gt;join(thiz-&gt;join(a, b), c);
        return ret;
    &#125;

    iterator lower_bound(const value_type &amp;key) &#123;
        node_type ret = lower_bound_internal(key);
        return ret ? iterator(ret) : end();
    &#125;

    const_iterator lower_bound(const value_type &amp;key) const &#123;
        node_type ret = const_cast&lt;treap_multiset&lt;T&gt;*&gt;(this)-&gt;lower_bound_internal(key);
        return ret ? const_iterator(ret) : end();
    &#125;

    iterator upper_bound(const value_type &amp;key) &#123;
        node_type ret = upper_bound_internal(key);
        return ret ? iterator(ret) : end();
    &#125;

    const_iterator upper_bound(const value_type &amp;key) const &#123;
        node_type ret = const_cast&lt;treap_multiset&lt;T&gt;*&gt;(this)-&gt;upper_bound_internal(key);
        return ret ? const_iterator(ret) : end();
    &#125;

    std::pair&lt;iterator, iterator&gt; equal_range(const value_type &amp;key) &#123;
        return std::make_pair(lower_bound(key), upper_bound(key));
    &#125;

    std::pair&lt;const_iterator, const_iterator&gt; equal_range(const value_type &amp;key) const &#123;
        return std::make_pair(lower_bound(key), upper_bound(key));
    &#125;

    size_type depth(node_type node) &#123;
        if (!node) return 0;
        return 1 + std::max(depth(node-&gt;left), depth(node-&gt;right));
    &#125;
    
private:
    Compare comp;
    node_type root;

    void recursive_free(node_type root) &#123;
        if (root-&gt;left) 
            recursive_free(root-&gt;left);       
        if (root-&gt;right) 
            recursive_free(root-&gt;right);
        delete root;
    &#125;

    void split_le(node_type root, const value_type &amp;key, 
        node_type &amp;left, node_type left_parent,
        node_type &amp;right, node_type right_parent) &#123;
        if (!root) &#123; left = right = nullptr; return; &#125;
        if (!comp(key, root-&gt;value)) &#123;
            left = root; root-&gt;parent = left_parent;
            split_le(root-&gt;right, key, root-&gt;right, root, right, right_parent);
        &#125; else &#123;
            right = root; root-&gt;parent = right_parent;
            split_le(root-&gt;left, key, left, left_parent, root-&gt;left, root);
        &#125;
        root-&gt;update_size();
    &#125;

    void split_re(node_type root, const value_type &amp;key, 
        node_type &amp;left, node_type left_parent,
        node_type &amp;right, node_type right_parent) &#123;
        if (!root) &#123; left = right = nullptr; return; &#125;
        if (comp(root-&gt;value, key)) &#123;
            left = root; root-&gt;parent = left_parent;
            split_re(root-&gt;right, key, root-&gt;right, root, right, right_parent);
        &#125; else &#123;
            right = root; root-&gt;parent = right_parent;
            split_re(root-&gt;left, key, left, left_parent, root-&gt;left, root);
        &#125;
        root-&gt;update_size();
    &#125;

    void split_size(node_type root, size_type size, 
        node_type &amp;left, node_type left_parent,
        node_type &amp;right, node_type right_parent) &#123;
        if (!root) &#123; left = right = nullptr; return; &#125;
        size_type left_size = 1 + (root-&gt;left ? root-&gt;left-&gt;size : 0);
        if (left_size &lt;= size) &#123;
            left = root; root-&gt;parent = left_parent;
            split_size(root-&gt;right, 
                size - left_size, root-&gt;right, root, right, right_parent);
        &#125; else &#123;
            right = root; root-&gt;parent = right_parent;
            split_size(root-&gt;left, size, left, left_parent, root-&gt;left, root);
        &#125;
        root-&gt;update_size();
    &#125;

    node_type join(node_type left, node_type right) &#123;
        if (!left) return right;
        if (!right) return left;
        if (left-&gt;weight &lt;= right-&gt;weight) &#123;
            node_type temp = join(left-&gt;right, right);
            if (temp) temp-&gt;parent = left;
            left-&gt;right = temp;
            left-&gt;update_size();
            return left;
        &#125; else &#123;
            node_type temp = join(left, right-&gt;left);
            if (temp) temp-&gt;parent = right;
            right-&gt;left = temp;
            right-&gt;update_size();
            return right;
        &#125;
    &#125;

    node_type leftmost(node_type x) const &#123;
        if (!x) return nullptr;
        node_type ret = x; while (ret-&gt;left) ret = ret-&gt;left;
        return ret;
    &#125;

    node_type rightmost(node_type x) const &#123;
        if (!x) return nullptr;
        node_type ret = x; while (ret-&gt;right) ret = ret-&gt;right;
        return ret;
    &#125;

    node_type find_internal(const value_type &amp;key) &#123;
        node_type a, b, c;
        split_le(root, key, a, nullptr, c, nullptr);
        split_re(root, key, a, nullptr, b, nullptr);
        root = join(join(a, b), c);
        return b;
    &#125;

    node_type lower_bound_internal(const value_type &amp;key) &#123;
        node_type left, right;
        split_re(root, key, left, nullptr, right, nullptr);
        node_type ret = leftmost(right);
        root = join(left, right);
        return ret;
    &#125;

    node_type upper_bound_internal(const value_type &amp;key) &#123;
        node_type left, right;
        split_le(root, key, left, nullptr, right, nullptr);
        node_type ret = leftmost(right);
        root = join(left, right);
        return ret;
    &#125;

    node_type at_internal(size_type index) const &#123;
        node_type temp = root;
        while (true) &#123;
            size_type left_size = 1 + (temp-&gt;left ? temp-&gt;left-&gt;size : 0);
            if (index == left_size) return temp;
            else if (index &lt; left_size) temp = temp-&gt;left;
            else temp = temp-&gt;right, index -= left_size;
        &#125;
        return nullptr; // UNREACHABLE
    &#125;

    size_type rank(node_type node) &#123;
        bool from_right = true;
        size_type ret = 0;
        while (node) &#123;
            if (from_right)
                ret += 1 + (node-&gt;left ? node-&gt;left-&gt;size : 0);
            if (node-&gt;parent)
                from_right = node == node-&gt;parent-&gt;right;
            node = node-&gt;parent;
        &#125;
        return ret;
    &#125;

    node_type deep_copy(node_type node) &#123;
        if (!node) return nullptr;
        node_type left = deep_copy(node-&gt;left);
        node_type right = deep_copy(node-&gt;right);
        node_type ret = new treap_node&lt;T&gt;(
            left, right, nullptr,
            node-&gt;weight, node-&gt;size, node-&gt;value
        );
        if (left) left-&gt;parent = ret;
        if (right) right-&gt;parent = ret;
        return ret;
    &#125;

    void assert_valid(iterator it) &#123;
        if (!it.node || it.past_the_end)
            throw std::runtime_error(&quot;invalid iterator&quot;);
        node_type temp = it.node;
        while (temp-&gt;parent) temp = temp-&gt;parent;
        if (temp != root)
            throw std::runtime_error(&quot;invalid iterator&quot;);
    &#125;
&#125;;</code></pre>
<p>(The code above hasn't been thoroughly tested yet and could still contain bugs).</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/Tanh%E7%BA%BF%E6%80%A7%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/Tanh%E7%BA%BF%E6%80%A7%E5%8C%96/" class="post-title-link" itemprop="url">基于反双曲正切函数的马达线性化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-09-28 05:15:04" itemprop="dateModified" datetime="2018-09-28T05:15:04-04:00">2018-09-28</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概况">概况</h1>
<p>由于VEX中PWM频率偏低，因此马达的响应并不是线性的，例如马达指令在较小时存在死区，在较大时对转速的影响可以忽略不计等等。以269马达的数据为例（393也是类似）：</p>
<p><img src="http://ovzrr9kke.bkt.clouddn.com/18-9-28/8570621.jpg" /></p>
<p>那么如何让马达的响应变得线性呢？从数学角度出发，我们需要试图找到，或者逼近以上马达曲线<span class="math inline">\(f\)</span>的<strong>反函数</strong><span class="math inline">\(g = f^{-1}\)</span>，对于输出我们应用反函数再应用到马达上，由于马达曲线是单调的，因此在理想状况下，这波操作以后马达的响应就是线性的了，这一过程也称作<strong>马达线性化</strong>。</p>
<p>出于简单起见，我们规定这个<span class="math inline">\(g\)</span>的定义域和值域都是<span class="math inline">\([-127, 127]\)</span>，这样的话，理论上大部分原来没有使用线性化的PID算法可以较为简单地加上线性化（不然的话就需要从零开始调参）。显然由马达曲线的单调性可得<span class="math inline">\(g(127) = 127\)</span>，以及<span class="math inline">\(g(-127) = -127\)</span>。</p>
<p>目前机器人社实践过的线性化算法有：</p>
<ol type="1">
<li>去除死区的简单线性化：只比没有线性化好一点，简单来说就是对输出的指令加一个bias，这样就不会有死区的问题。</li>
<li>三段线性插值线性化：就是被WSJ吹爆的所谓模型，本质是把马达曲线分为三段并分别用线性函数近似，效果很好，缺点是调参较为复杂。</li>
<li>二次函数线性化：我们发现马达曲线的形状有点像<span class="math inline">\(f(x) = \sqrt x\)</span>的图像，因此我们使用二次函数为反函数进行线性化，效果一般。</li>
<li>反双曲正切线性化：本篇主题，效果较好。</li>
<li>真·模型线性化：使用马达模型直接计算马达曲线进行线性化，效果最好，可以针对不同的电量，场地状况，扭矩实时给出不同的曲线，缺点是计算慢。</li>
</ol>
<h1 id="数学推导">数学推导</h1>
<p>直觉上，有没有觉得马达曲线的图像很像<span class="math inline">\(\tanh\)</span>函数的图像？</p>
<p><img src="http://ovzrr9kke.bkt.clouddn.com/18-9-28/66159356.jpg" /></p>
<p>因此我们选择使用双曲正切函数的反函数来进行线性化： <span class="math display">\[
\tanh^{-1}(x) = \frac{1}{2}\ln\left(\frac{1 + x}{1 - x}\right)
\]</span> 为了适应死区，以及满足上文中定义域和值域的要求，我们魔改拓展一下上式： <span class="math display">\[
g(x) = a\operatorname{sgn}(x) + \frac{127 - a}{2b}\ln\left(\frac{c + x}{c - x}\right)
\]</span> 解释一下各参数的意义：</p>
<ol type="1">
<li><span class="math inline">\(a\)</span>是死区，一般来说<span class="math inline">\(5 \le a \le 20\)</span>。</li>
<li><span class="math inline">\(b\)</span>是我叫做“缩放因子”的参数，其图像意义是<strong>把原双曲正切函数自变量<span class="math inline">\([-b, b]\)</span>这一段的图像看做马达函数图像形状上的近似</strong>。从图像上可以看到，一般<span class="math inline">\(2 \le b \le 3\)</span>。</li>
<li><span class="math inline">\(c\)</span>是一个依赖于<span class="math inline">\(a, b\)</span>的参数，由<span class="math inline">\(g(127) = 127\)</span>，我们反解得<span class="math inline">\(c = 127\frac{e^{2b} + 1}{e^{2b} - 1}\)</span>。</li>
</ol>
<p>就完了，不难吧？</p>
<h1 id="代码">代码</h1>
<p>注意变量名可能和推导中用到的符号并不一致：</p>
<pre class="line-numbers"><code class="language-cpp">typedef struct &#123;
    float a, b;
    float alpha;
&#125; TanhLinearizer;

void initTanhLinearizer(TanhLinearizer *t, float deadband, float scale = 2.333333) &#123;
    t-&gt;b = scale * 2;
    t-&gt;a = 127 - deadband;
    float x = exp(2 * scale);
    t-&gt;alpha = 127 * (x + 1) / (x - 1);
&#125;

int getTanhLinearizedOutput(TanhLinearizer *t, int cmd) &#123;
    if (cmd &gt; 127) cmd = 127;
    if (cmd &lt; -127) cmd = -127;
    int s = sgn(cmd);
    cmd = fabs(cmd);
    return round(t-&gt;a / t-&gt;b * log((t-&gt;alpha + cmd) / (t-&gt;alpha - cmd)) + s * (127 - t-&gt;a));
&#125;</code></pre>
<h1 id="效果">效果</h1>
<p>马达曲线的反函数应该原本是这个样子的（就是原图像转一转）：</p>
<p><img src="http://ovzrr9kke.bkt.clouddn.com/18-9-28/24070987.jpg" /></p>
<p>然后在<span class="math inline">\(a = 8, b = 3\)</span>时我们的线性化算法给出的反函数是这个样子的：</p>
<p><img src="http://ovzrr9kke.bkt.clouddn.com/18-9-28/83393060.jpg" /></p>
<p>是不是很像呢？实测的效果确实也是极好的。</p>
<h1 id="更多">更多</h1>
<p>其实马达函数的图像不只是像<span class="math inline">\(\tanh\)</span>啦，其实观察一下你也可以说它像<span class="math inline">\(\arctan\)</span>之类的，自然也可以发展出一套线性化的方法，从的来说看图像猜函数只能说是一种近似，最好自然是找出马达曲线精确的计算方法，也就是建模。但是这类线性化方法的一大好处就是<strong>计算量很小，很快</strong>，因此往往更多地得到应用。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/Treap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/Treap/" class="post-title-link" itemprop="url">Treap</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-09-17 09:26:00" itemprop="dateModified" datetime="2018-09-17T09:26:00-04:00">2018-09-17</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概念">概念</h1>
<p>众所周知，BST在特定的插入顺序下常常会退化成链，从而使单次查找的时间复杂度退化为<span class="math inline">\(O(n)\)</span>，这是很糟糕的，因此出现了一箩筐的平衡树，在保证BST性质的同时，尽量保持BST的平衡。</p>
<p>Treap就是当中概念比较简单而且比较好写的一种<del>真的吗？</del>。Treap是Tree和Heap的合成，即“树堆”，其精髓就在于通过维护，使得一棵树在<strong>保有BST性质的同时，也具有大根堆的性质</strong>。为此，每个节点都会随机生成一个额外的权值用于堆性质的维护：</p>
<pre class="line-numbers"><code class="language-cpp">struct node &#123;
    int l, r; // 左右子树
    int cnt, sz; // 当前键值副本树与子树（包括自身）大小
    int val, w; // 键值与随机权值
&#125; t[N];

int newnode(int val) &#123;
    t[++tot].val = val;
    t[tot].cnt = t[tot].sz = 1;
    t[tot].l = t[tot].r = 0;
    t[tot].w = rand();
    return tot;
&#125;

void pushup(int p) &#123; // 维护sz
    t[p].sz = t[t[p].l].sz + t[t[p].r].sz + t[p].cnt;
&#125;</code></pre>
<p>为了防止讨论边界条件，我们插入两个值为<span class="math inline">\(\pm \infty\)</span>的节点：</p>
<pre class="line-numbers"><code class="language-cpp">void build() &#123;
    tot = 0;
    rt = newnode(-INF);
    t[rt].r = newnode(INF);
    pushup(rt);
&#125;</code></pre>
<h1 id="旋转">旋转</h1>
<p>改变BST的形状而不破坏其性质的操作是二叉树的旋转，分为右旋（zig）和左旋（zag）两种，以右旋为例，右旋把一个节点<span class="math inline">\(p\)</span>的左子树<span class="math inline">\(q\)</span>绕其“向右（顺时针）”旋转到原来<span class="math inline">\(p\)</span>的位置，并且让<span class="math inline">\(p\)</span>成为<span class="math inline">\(q\)</span>的右子树，<span class="math inline">\(q\)</span>原来的右子树成为<span class="math inline">\(p\)</span>的左子树，左旋类似：</p>
<p><img src="http://ovzrr9kke.bkt.clouddn.com/18-9-17/36711485.jpg" /></p>
<p>落实在代码上，就是：</p>
<pre class="line-numbers"><code class="language-cpp">void zig(int &amp;p) &#123;
    int q = t[p].l;
    t[p].l = t[q].r, t[q].r = p;
    p = q; pushup(t[p].r); pushup(p); 
&#125;

void zag(int &amp;p) &#123;
    int q = t[p].r;
    t[p].r = t[q].l, t[q].l = p;
    p = q; pushup(t[p].l); pushup(p); 
&#125;</code></pre>
<p><strong>注意<code>pushup</code>的顺序。</strong></p>
<h1 id="排名相关查询">排名相关查询</h1>
<p>我们接下来考虑平衡树的前两个查询操作，分别是查排名和按排名查数，两个都相对简单，可以递归实现：</p>
<pre class="line-numbers"><code class="language-cpp">int rank(int p, int val) &#123;
    if (p == 0) return 0;
    if (val == t[p].val) return t[t[p].l].sz + 1;
    if (val &lt; t[p].val) return rank(t[p].l, val);
    return t[t[p].l].sz + t[p].cnt + rank(t[p].r, val);
&#125;

int query(int p, int rk) &#123;
    if (p == 0) return INF;
    if (t[t[p].l].sz &gt;= rk) return query(t[p].l, rk);
    if (t[t[p].l].sz + t[p].cnt &gt;= rk) return t[p].val;
    return query(t[p].r, rk - t[t[p].l].sz - t[p].cnt);
&#125;</code></pre>
<p><strong>注意这里查询的结果包含<span class="math inline">\(\pm \infty\)</span>，要去掉。</strong></p>
<h1 id="前驱后继查询">前驱后继查询</h1>
<p>接下来考虑查询<span class="math inline">\(x\)</span>的前驱/后继的操作，以前驱为例，我们初始化答案<span class="math inline">\(ans\)</span>为<span class="math inline">\(- \infty\)</span>，有以下几种情况：</p>
<ol type="1">
<li>没有找到<span class="math inline">\(x\)</span>节点：那么答案就在经过的节点上。</li>
<li>找到<span class="math inline">\(x\)</span>节点，可惜是叶子：同上，答案在经过的节点上。</li>
<li>找到<span class="math inline">\(x\)</span>节点，不是叶子：若<span class="math inline">\(x\)</span>节点有左子树<span class="math inline">\(p\)</span>，从<span class="math inline">\(p\)</span>开始一路往右走直到不存在右子树为止，此时节点对应的值即为前驱。</li>
</ol>
<p>代码：</p>
<pre class="line-numbers"><code class="language-cpp">int querypre(int val) &#123;
    int ans = 1; // t[1].val = -inf
    int p = rt;
    while (p) &#123;
        if (val == t[p].val) &#123;
            if (t[p].l) &#123;
                p = t[p].l;
                while (t[p].r) p = t[p].r;
                ans = p;
            &#125;
            break;
        &#125;
        if (t[p].val &lt; val &amp;&amp; t[p].val &gt; t[ans].val) ans = p;
        p = val &lt; t[p].val ? t[p].l : t[p].r;
    &#125;
    return t[ans].val;
&#125;

int querynxt(int val) &#123;
    int ans = 2; // t[2].val = inf
    int p = rt;
    while (p) &#123;
        if (val == t[p].val) &#123;
            if (t[p].r) &#123;
                p = t[p].r;
                while (t[p].l) p = t[p].l;
                ans = p;
            &#125;
            break;
        &#125;
        if (t[p].val &gt; val &amp;&amp; t[p].val &lt; t[ans].val) ans = p;
        p = val &lt; t[p].val ? t[p].l : t[p].r;
    &#125;
    return t[ans].val;
&#125;</code></pre>
<h1 id="插入">插入</h1>
<p>递归进行，同时注意维护大根堆性质即可：</p>
<pre class="line-numbers"><code class="language-cpp">void insert(int &amp;p, int val) &#123;
    if (p == 0) &#123;
        p = newnode(val);
        return;
    &#125;
    if (val == t[p].val) &#123;
        t[p].cnt++;
        pushup(p);
        return;
    &#125;
    if (val &lt; t[p].val) &#123;
        insert(t[p].l, val);
        if (t[p].w &lt; t[t[p].l].w) zig(p);
    &#125; else &#123;
        insert(t[p].r, val);
        if (t[p].w &lt; t[t[p].r].w) zag(p);
    &#125;
    pushup(p);
&#125;</code></pre>
<h1 id="删除">删除</h1>
<p>我们利用旋转一路把要删的节点转到叶子的位置，然后直接删除即可，同时一路上维护堆的性质：</p>
<pre class="line-numbers"><code class="language-cpp">void remove(int &amp;p, int val) &#123;
    if (p == 0) return;
    if (val == t[p].val) &#123;
        if (t[p].cnt &gt; 1) &#123;
            t[p].cnt--;
            pushup(p);
            return;
        &#125;
        if (t[p].l || t[p].r) &#123;
            if (t[p].r == 0 || t[t[p].l].w &gt; t[t[p].r].w)
                zig(p), remove(t[p].r, val);
            else
                zag(p), remove(t[p].l, val);
            pushup(p);
        &#125; else p = 0;
        return;
    &#125;
    val &lt; t[p].val ? remove(t[p].l, val) : remove(t[p].r, val);
    pushup(p);
&#125;</code></pre>
<h1 id="完整代码">完整代码</h1>
<p>以下是通过普通平衡树模板题的全部代码，共计150行左右，感觉平衡树这个东西代码量还是有点恐怖，而且需要注意非常多的细节，需要结合理解记忆：</p>
<pre class="line-numbers"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;

using namespace std;
const int N = 100010;
const int INF = 0x3f3f3f3f;
struct node &#123;
    int l, r;
    int cnt, sz;
    int val, w;
&#125; t[N];
int n, tot = 0, rt;

int newnode(int val) &#123;
    t[++tot].val = val;
    t[tot].cnt = t[tot].sz = 1;
    t[tot].l = t[tot].r = 0;
    t[tot].w = rand();
    return tot;
&#125;

void pushup(int p) &#123;
    t[p].sz = t[t[p].l].sz + t[t[p].r].sz + t[p].cnt;
&#125;

void zig(int &amp;p) &#123;
    int q = t[p].l;
    t[p].l = t[q].r, t[q].r = p;
    p = q; pushup(t[p].r); pushup(p); 
&#125;

void zag(int &amp;p) &#123;
    int q = t[p].r;
    t[p].r = t[q].l, t[q].l = p;
    p = q; pushup(t[p].l); pushup(p); 
&#125;

void build() &#123;
    tot = 0;
    rt = newnode(-INF);
    t[rt].r = newnode(INF);
    pushup(rt);
&#125;

int rank(int p, int val) &#123;
    if (p == 0) return 0;
    if (val == t[p].val) return t[t[p].l].sz + 1;
    if (val &lt; t[p].val) return rank(t[p].l, val);
    return t[t[p].l].sz + t[p].cnt + rank(t[p].r, val);
&#125;

int query(int p, int rk) &#123;
    if (p == 0) return INF;
    if (t[t[p].l].sz &gt;= rk) return query(t[p].l, rk);
    if (t[t[p].l].sz + t[p].cnt &gt;= rk) return t[p].val;
    return query(t[p].r, rk - t[t[p].l].sz - t[p].cnt);
&#125;

int querypre(int val) &#123;
    int ans = 1;
    int p = rt;
    while (p) &#123;
        if (val == t[p].val) &#123;
            if (t[p].l) &#123;
                p = t[p].l;
                while (t[p].r) p = t[p].r;
                ans = p;
            &#125;
            break;
        &#125;
        if (t[p].val &lt; val &amp;&amp; t[p].val &gt; t[ans].val) ans = p;
        p = val &lt; t[p].val ? t[p].l : t[p].r;
    &#125;
    return t[ans].val;
&#125;

int querynxt(int val) &#123;
    int ans = 2;
    int p = rt;
    while (p) &#123;
        if (val == t[p].val) &#123;
            if (t[p].r) &#123;
                p = t[p].r;
                while (t[p].l) p = t[p].l;
                ans = p;
            &#125;
            break;
        &#125;
        if (t[p].val &gt; val &amp;&amp; t[p].val &lt; t[ans].val) ans = p;
        p = val &lt; t[p].val ? t[p].l : t[p].r;
    &#125;
    return t[ans].val;
&#125;

void insert(int &amp;p, int val) &#123;
    if (p == 0) &#123;
        p = newnode(val);
        return;
    &#125;
    if (val == t[p].val) &#123;
        t[p].cnt++;
        pushup(p);
        return;
    &#125;
    if (val &lt; t[p].val) &#123;
        insert(t[p].l, val);
        if (t[p].w &lt; t[t[p].l].w) zig(p);
    &#125; else &#123;
        insert(t[p].r, val);
        if (t[p].w &lt; t[t[p].r].w) zag(p);
    &#125;
    pushup(p);
&#125;

void remove(int &amp;p, int val) &#123;
    if (p == 0) return;
    if (val == t[p].val) &#123;
        if (t[p].cnt &gt; 1) &#123;
            t[p].cnt--;
            pushup(p);
            return;
        &#125;
        if (t[p].l || t[p].r) &#123;
            if (t[p].r == 0 || t[t[p].l].w &gt; t[t[p].r].w)
                zig(p), remove(t[p].r, val);
            else
                zag(p), remove(t[p].l, val);
            pushup(p);
        &#125; else p = 0;
        return;
    &#125;
    val &lt; t[p].val ? remove(t[p].l, val) : remove(t[p].r, val);
    pushup(p);
&#125;

int main() &#123;
    srand(time(0)); build();
    scanf(&quot;%d&quot;, &amp;n);
    while (n--) &#123;
        int op, x;
        scanf(&quot;%d%d&quot;, &amp;op, &amp;x);
        switch (op) &#123;
        case 1: insert(rt, x); break;
        case 2: remove(rt, x); break;
        case 3: printf(&quot;%d\n&quot;, rank(rt, x) - 1); break;
        case 4: printf(&quot;%d\n&quot;, query(rt, x + 1)); break;
        case 5: printf(&quot;%d\n&quot;, querypre(x)); break;
        case 6: printf(&quot;%d\n&quot;, querynxt(x)); break;
        &#125;
    &#125;
    return 0;
&#125; </code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/Sublinear/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/Sublinear/" class="post-title-link" itemprop="url">次线性算法与有序判定问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-07-11 23:17:56" itemprop="dateModified" datetime="2020-07-11T23:17:56-04:00">2020-07-11</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是次线性算法">什么是次线性算法？</h1>
<p>如何衡量算法的效率？一般来说，问题（以及对应的算法）可以分为以下几类：</p>
<ol type="1">
<li>不可判定问题。这种问题不存在算法。</li>
<li>指数时间可解。这种问题虽然存在算法但是就目前我们的技术水平，对于大输入，它们没办法在可接受的时间内返回结果。</li>
<li>多项式时间可解。这些算法可以在现在的电脑上较为高效地运行。</li>
<li>线性时间可解。这是大多数人认为的最高效算法，一般来说不会有比这更高效的了（读取输入就是线性的，不读完输入怎么计算输出？）</li>
<li><strong>次线性时间算法</strong>。“次线性”(sublinear)即“线性以下”，指在利用低于与输入线性的资源（可以是时间也可以是空间）的情况下解决问题的一类算法。这类算法有着非常不可思议的特性：它甚至都不会看完完整的输入！</li>
</ol>
<p>为什么我们需要次线性算法？</p>
<p>大数据时代我们要处理的数据是在是太多了，光是谷歌一天就会产生20PB的数据，我们根本没有足够的时空资源来哪怕运行线性的算法或者把它们全部过一遍！但是我们又希望从这些数据中挖掘有价值的结论，就只能求助于次线性算法了。</p>
<p>因为次线性算法没法看到完整的输入，给出错误的结果自然是情有可原的（在精确解没法在次线性时间内算出的情况下）。因此，次线性算法多是<strong>近似算法</strong>。同时，因为如果一个算法是确定性的，对手就可以预判这个算法会看那部分输入，并针对这个造出会让算法100%翻车的数据，因此<strong>随机化</strong>在次线性算法的设计也经常出现。</p>
<h1 id="查询模型">查询模型</h1>
<p>好，既然次线性算法不能把输入完整地读一遍，那么要怎么样才能获取输入的信息呢？我们将次线性算法获取输入信息的方式称为<strong>查询</strong>（query）。而算法的难易自然和可以进行的查询方式有着很大的关系，因此我们还需要一组规则定义在一个问题中可以进行何种方式的查询，这种规则称一个问题的<strong>查询模型</strong>（query model）。例如，在以数组为输入的问题当中，常见的查询方式是按照一个下标询问对应的值，在以图为输入的问题当中，查询可以是按照两点查询边权……可以看到，查询模型是因问题而异的。</p>
<h1 id="有序判定问题sortedness-problem">有序判定问题（Sortedness Problem）</h1>
<h2 id="定义">定义</h2>
<p><strong>输入：</strong>一个<span class="math inline">\(n\)</span>个元素的数组<span class="math inline">\(A\)</span>。</p>
<p><strong>查询模型：</strong>对于一个整数<span class="math inline">\(1\le i \le n\)</span>，查询<span class="math inline">\(A_i\)</span>的值。</p>
<p><strong>目标：</strong>在尽量少的时间内（假设一次查询时<span class="math inline">\(\mathcal{O}(1)\)</span>的）<strong>判断这个数组是否是有序</strong>（此处单指<strong>升序</strong>）的。</p>
<p>很显然，任何一个确定性的算法都必须进行<span class="math inline">\(\Omega(n)\)</span>次查询才能解决这个问题（不然肯定会有漏看的）。</p>
<p>因此我们退而求其次：如果运用随机化的话，我们能不能在<span class="math inline">\(o(n)\)</span>次查询之内给出正确概率至少为<span class="math inline">\(\frac{1}{2}+\epsilon\ (\epsilon &gt;0)\)</span>的答案呢？</p>
<p>（正确概率在这里只要大于<span class="math inline">\(\frac{1}{2}\)</span>就行，精确的值没有意义，因为我们总是可以重复运行不靠谱的算法提高正确率）</p>
<p>答案还是不行（证明课上似乎没讲？）</p>
<p>那我们怎么办？只好稍微把题目修改一下，再退而求其次看看能不能有高效的<strong>近似算法</strong>了。</p>
<h2 id="修改后的定义">修改后的定义</h2>
<p>我们不妨寻找这么一个算法，它</p>
<ol type="1">
<li>在数组有序的时候输出是</li>
<li>在数组“非常无序”的时候输出否</li>
<li>而对于那种非常接近有序的数组，我们干脆不管。</li>
</ol>
<p>设计这样的算法显然比设计能够精确解决这个问题的算法要容易多了。</p>
<p>那么怎么样算是“非常无序”，怎么样算是“接近有序”呢？显然，我们需要在数学上给予这些描述严谨的定义。</p>
<p><strong>定义：</strong>对于<span class="math inline">\(\epsilon\in(0,1)\)</span>，如果需要至少修改<span class="math inline">\(\epsilon n\)</span>个数才能让数组<span class="math inline">\(A\)</span>变为有序，那么称数组<span class="math inline">\(A\)</span>是<span class="math inline">\(\epsilon\)</span>无序（<span class="math inline">\(\epsilon\)</span>-far from sorted）的。</p>
<p>那么我们就可以进一步精炼我们上面的问题了：我们需要设计一个算法，使其</p>
<ol type="1">
<li>在<span class="math inline">\(A\)</span>有序的时候输出是</li>
<li>在<span class="math inline">\(A\)</span> <span class="math inline">\(\epsilon\)</span>无序的时候输出否</li>
</ol>
<p>（<span class="math inline">\(\epsilon\)</span>是算法的一个参数）</p>
<p>从这里其实可以看到对于近似算法的一种设计思路：对于数值型的问题，我们通过对于最优解的放缩定义了近似比<span class="math inline">\(\alpha\)</span>，而对于判定型的问题，我们试图放宽需要判定的条件。在上面的问题当中我们相当于变相假设，或者说承诺了<span class="math inline">\(A\)</span>要么是有序要么是<span class="math inline">\(\epsilon\)</span>无序的，因此这种问题被称作promise problem。</p>
<h2 id="二元数组">二元数组</h2>
<p>我们先从最简单的情形开始分析：如果数组只有<span class="math inline">\(0\)</span>和<span class="math inline">\(1\)</span>两种元素呢？</p>
<h3 id="初步分析">初步分析</h3>
<p>显然此时数组有序等价于所有的<span class="math inline">\(0\)</span>都在<span class="math inline">\(1\)</span>前面。</p>
<p>我们不妨定义两个集合，<span class="math inline">\(L_1\)</span>和<span class="math inline">\(R_0\)</span>。如果将数组里的元素从左到右排列，<span class="math inline">\(L_1\)</span>表示最靠左的<span class="math inline">\(\frac{\epsilon n}{2}\)</span>个<span class="math inline">\(1\)</span>的下标集合，<span class="math inline">\(R_0\)</span>表示最靠右的<span class="math inline">\(\frac{\epsilon n}{2}\)</span>个<span class="math inline">\(0\)</span>的下标集合。</p>
<p>显然在数组有序时，<span class="math inline">\(L_1\)</span>整体都在<span class="math inline">\(R_0\)</span>右边。而当数组不有序时，有可能：</p>
<ol type="1">
<li><span class="math inline">\(L_1\)</span>和<span class="math inline">\(R_0\)</span>的区间重叠。</li>
<li><span class="math inline">\(L_1\)</span>在<span class="math inline">\(R_0\)</span>的左边。</li>
</ol>
<p>接下来我们证明：</p>
<p><strong>引理：</strong>如果<span class="math inline">\(A\)</span>是<span class="math inline">\(\epsilon\)</span>无序的，那么<span class="math inline">\(L_1\)</span>必定在<span class="math inline">\(R_0\)</span>左边且不重叠。</p>
<p><strong>证明：</strong>我们使用反证法，不妨假设<span class="math inline">\(L_1\)</span>和<span class="math inline">\(R_0\)</span>有重叠的部分： <span class="math display">\[
0,0,\cdots,\rlap{\overbrace{1,\cdots,1,0,1}^{L_1} }1,\cdots,1,\underbrace{ {\color{blue}{0} },{\color{red}{1} },0,\cdots,0}_{R_0},\cdots1,1
\]</span></p>
<p><span class="math inline">\(\color{red}1\)</span>是<span class="math inline">\(L_1\)</span>中最右边的<span class="math inline">\(1\)</span>，<span class="math inline">\(\color{blue}0\)</span>是<span class="math inline">\(R_0\)</span>中最左边的<span class="math inline">\(0\)</span>。</p>
<p>由<span class="math inline">\(L_1,R_0\)</span>的定义可知，<span class="math inline">\(\color{red}1\)</span>左侧的<span class="math inline">\(1\)</span>的数量严格小于<span class="math inline">\(\frac{\epsilon n}{2}\)</span>，<span class="math inline">\(\color{blue}0\)</span>右侧的<span class="math inline">\(0\)</span>的数量也严格小于<span class="math inline">\(\frac{\epsilon n}{2}\)</span>。而注意到如果把<span class="math inline">\(\color{red}1\)</span>的左侧<span class="math inline">\(1\)</span>改成<span class="math inline">\(0\)</span>，把<span class="math inline">\(\color{blue}0\)</span>右侧的<span class="math inline">\(0\)</span>的改成<span class="math inline">\(1\)</span>，那么数组就变得有序了，而此时我们修改的元素数量严格小于<span class="math inline">\(\epsilon n\)</span>，这和数组是<span class="math inline">\(\epsilon\)</span>无序的前提是矛盾的。</p>
<h3 id="算法">算法</h3>
<p>接下来我们给出能够以<span class="math inline">\(1-\delta\)</span>的成功率判定二元数组有序性的算法：</p>
<ol type="1">
<li>从数组当中随机选取<span class="math inline">\(t=\frac{2}{\epsilon}\ln\frac{2}{\delta}\)</span>个下标<span class="math inline">\(i_1,\cdots,i_t\)</span>（为了简化分析，允许下标重复）。</li>
<li>查询<span class="math inline">\(A_{i_1},\cdots, A_{i_t}\)</span>的值。</li>
<li>如果在<span class="math inline">\(\left\{A_{i_1},\cdots, A_{i_t}\right\}\)</span>当中发现了逆序对，输出否，否则输出是。</li>
</ol>
<h3 id="分析">分析</h3>
<p>很显然，如果数组是有序的，那么我们的算法一定会输出是，成功率<span class="math inline">\(1&gt;1-\delta\)</span>。</p>
<p>而如果数组是<span class="math inline">\(\epsilon\)</span>-无序的，为了证明此时的成功率至少为<span class="math inline">\(1-\delta\)</span>，我们只需要证明 <span class="math display">\[
\operatorname{Pr}[\text{wrong answer}] \le \delta
\]</span> 即错误（输出了是）概率不大于<span class="math inline">\(\delta\)</span>。</p>
<p>设随机事件<span class="math inline">\(E_L\)</span>表示在随机选取的<span class="math inline">\(t\)</span>个下标中，至少有一个下标来自<span class="math inline">\(L_1\)</span>，<span class="math inline">\(E_R\)</span>表示至少有一个下标来自<span class="math inline">\(R_0\)</span>。</p>
<p>那么由之前的引理，如果<span class="math inline">\(E_L\cap E_R\)</span>，我们一定找得到逆序对。</p>
<p>因此只有可能在<span class="math inline">\(\overline{E_L\cap E_R}\)</span>才有可能出错： <span class="math display">\[
\begin{aligned}
    \operatorname{Pr}[\text{wrong answer}] \le \operatorname{Pr}\left[\overline{E_L}\cup\overline{E_R} \right] \le \operatorname{Pr}\left[\overline{E_L}\right] +  \operatorname{Pr}\left[\overline{E_R}\right]
\end{aligned}
\]</span> 而 <span class="math display">\[
\begin{aligned}
    \operatorname{Pr}\left[\overline{E_L}\right] &amp;= \left(1-\frac{\left|L_1\right|}{n}\right) ^ t \\
    &amp;= \left(1-\frac{\epsilon}{2}\right)^{\frac{2}{\epsilon}\ln\frac{2}{\delta}} \\
    &amp;\le \left(e^{-\frac{\epsilon}{2}}\right)^{\frac{2}{\epsilon}\ln\frac{2}{\delta}} \\
    &amp;= \frac{\delta}{2}
\end{aligned}
\]</span> 倒数第二步我们运用了不等式<span class="math inline">\(1+x\le e^x\)</span>。</p>
<p>同理可证<span class="math inline">\(\operatorname{Pr}\left[\overline{E_R}\right] \le \frac{\delta}{2}\)</span>，因此 <span class="math display">\[
\operatorname{Pr}[\text{wrong answer}] \le \operatorname{Pr}\left[\overline{E_L}\right] +  \operatorname{Pr}\left[\overline{E_R}\right] \le \frac{\delta}{2} + \frac{\delta}{2} = \delta
\]</span> 证毕。</p>
<h3 id="时间复杂度">时间复杂度</h3>
<p>随机采样花费的时间复杂度为<span class="math inline">\(\mathcal{O}(t)\)</span>。</p>
<p>查询子数组花费的时间复杂度也是<span class="math inline">\(\mathcal{O}(t)\)</span>。</p>
<p>而在子数组当中查找逆序对也可以被优化成<span class="math inline">\(\mathcal{O}(t)\)</span>，实现的方法有很多，例如可以计算<span class="math inline">\(1\)</span>的下标的最小值和<span class="math inline">\(0\)</span>的下标的最大值进行比较等。</p>
<p>因此这个算法的时间复杂度就是<span class="math inline">\(\mathcal O(t) = \mathcal O\left(\frac{1}{\epsilon}\ln\frac{1}{\delta}\right)\)</span>，和<span class="math inline">\(n\)</span>无关。</p>
<h2 id="一般情况">一般情况</h2>
<p>接下来我们来看数组元素可以是任意数字的情况。</p>
<p>我们之前随机采样的想法还能继续沿用吗？</p>
<p>考虑如下情况： <span class="math display">\[
3,2,1{\color{red}|}6,5,4{\color{red}|}9,8,7
\]</span> 虽然这个数组是<span class="math inline">\(\frac{2}{3}\)</span>无序的，但是如果我的随机采样在每个段中只挑了一个元素，那采样出来的子序列却一定是有序的，我们的算法就被糊弄过去了。</p>
<p>这就是问题所在：如果我们把一个数组分成若干段“总体有序，但局部无序”的连续段，显然这样的段最多可以有<span class="math inline">\(\mathcal O(n)\)</span>个。而为了能够在子序列当中找到逆序对，就必须从同一个段当中至少选两个数。而由生日悖论可知，为了大概率确保能从一个段中选两个数，我们必须至少随机选<span class="math inline">\(\mathcal O\left(\sqrt n\right)\)</span>个数——这让我们之前的分析几乎废掉。</p>
<p>那怎么办呢？</p>
<p>考虑一个有序的数组所具有的性质。在算法层面，一个熟悉的性质便是：<strong>可以进行二分查找</strong>。</p>
<p>这给我们一个思路：如果我们不管三七二十一在给定的数组上跑二分，如果二分翻车了，那么数组一定是无序的，如果二分没翻车，数组或许就是有序的。</p>
<p>如何定义二分有没有“翻车”？或者说，如何定义一次正常的二分？</p>
<p>引入<em>一致二分查找</em>（Consistent Binary Search）的概念，如果对于一次二分查找，</p>
<ol type="1">
<li>我最后找到了我要找的那个数（也就是说，如果我要找的是<span class="math inline">\(A_i\)</span>，而我的二分最后终止于下标<span class="math inline">\(i\)</span>），</li>
<li>假设二分的左右端点和终点分别为<span class="math inline">\(l,r,m\)</span>，二分的过程中<span class="math inline">\(A_l &lt; A_m &lt; A_r\)</span>始终成立，</li>
</ol>
<p>那么我们称这次二分查找是“一致的”或“相容的”（我觉得翻译成哪个似乎都不大合适）。</p>
<h3 id="算法-1">算法</h3>
<p>在二分思想的指引下我们提出如下的算法：</p>
<ol type="1">
<li>随机选择一个下标<span class="math inline">\(i\)</span>并查询<span class="math inline">\(A_i\)</span>的值。</li>
<li>二分查找<span class="math inline">\(A_i\)</span>。</li>
<li>如果这次二分查找是一致的，那么输出是，反之输出否。</li>
</ol>
<h3 id="分析-1">分析</h3>
<p><strong>引理：</strong>如果对于<span class="math inline">\(A_i\)</span>和<span class="math inline">\(A_j\)</span>的二分查找都是一致的，而且<span class="math inline">\(i&lt;j\)</span>，一定有<span class="math inline">\(A_i&lt;A_j\)</span>。</p>
<p><strong>证明：</strong>虽然两次二分查找中前几层的搜索区间可能相同，但由于<span class="math inline">\(i &lt; j\)</span>，到了某一层一定会出现<span class="math inline">\(A_i\)</span>往左边，<span class="math inline">\(A_j\)</span>往右边的分歧。假设该层搜索区间的中点是<span class="math inline">\(A_m\)</span>，显然对<span class="math inline">\(A_i\)</span>的二分搜索之所以在这层之后往左走是因为<span class="math inline">\(A_i &lt; A_m\)</span>，同理可知<span class="math inline">\(A_j&gt;A_m\)</span>，将二式组合引理便得证。</p>
<p>假设<span class="math inline">\(C\)</span>表示所有对下标对应的数进行的二分搜索是一致的下标的集合。则由刚刚的引理，由<span class="math inline">\(C\)</span>中下标组成的原数组的子序列一定是有序的。因为原数组是<span class="math inline">\(\epsilon\)</span>无序的，因此必然有<span class="math inline">\(|C|&lt;(1-\epsilon) n\)</span>（可以通过反证法证明）。</p>
<p>这个结论有什么意义呢？要知道我们的算法在原数组有序的时候一定输出正确的结果，而在原数组无序时，我们算法只有在抽到<span class="math inline">\(C\)</span>中的下标时才会做出误判。因此我们算法的错误率的上界为<span class="math inline">\(1-\epsilon\)</span>。</p>
<p>在得出这个上界之后，我们就可以改进我们的算法了：</p>
<ol type="1">
<li>将之前的算法运行<span class="math inline">\(k=\frac{1}{\epsilon}\ln\frac{1}{\delta}\)</span>遍。</li>
<li>如果<span class="math inline">\(k\)</span>次运行的结果都为是，则输出是，反之则输出否。</li>
</ol>
<p>这样的错误率是多少呢？ <span class="math display">\[
\begin{aligned}
    \operatorname{Pr}[\text{wrong answer}] &amp;\le \left(1-\epsilon\right)^k \\
    &amp;= \left(1-\epsilon\right)^{\frac{1}{\epsilon}\ln\frac{1}{\delta}} \\
    &amp;\le \left(e^{-\epsilon}\right)^{\frac{1}{\epsilon}\ln\frac{1}{\delta}} \\
    &amp; = \delta
\end{aligned}
\]</span> 因此正确率至少为<span class="math inline">\(1-\delta\)</span>，符合我们的要求。而这个算法的时间复杂度是<span class="math inline">\(\mathcal O\left(\frac{1}{\epsilon}\ln\frac{1}{\delta}\log n\right)\)</span>，也是相当优秀的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/Projection%20and%20Least%20Square/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/Projection%20and%20Least%20Square/" class="post-title-link" itemprop="url">投影、最小二乘拟合与QR分解笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-29 21:01:42" itemprop="dateModified" datetime="2021-04-29T21:01:42-04:00">2021-04-29</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="投影">投影</h1>
<p>高中的时候就学过，向量<span class="math inline">\(\boldsymbol b\)</span>在<span class="math inline">\(\boldsymbol a\)</span>上的投影为 <span class="math display">\[
\boldsymbol p = \frac{\boldsymbol a^{\mathrm T}\boldsymbol b}{\boldsymbol a^{\mathrm T}\boldsymbol a} \cdot \boldsymbol a
\]</span> 当时推导主要利用了点积的几何意义$a b = |a||b|$。在代数意义上上式是怎么推导的呢？</p>
<p>其实也不难：注意到<span class="math inline">\(\boldsymbol b\)</span>和其投影<span class="math inline">\(\boldsymbol p\)</span>的差一定是垂直于基向量<span class="math inline">\(\boldsymbol a\)</span>的。因为<span class="math inline">\(\boldsymbol p\)</span>与<span class="math inline">\(\boldsymbol a\)</span>平行，设<span class="math inline">\(\boldsymbol p = x\boldsymbol a\)</span> <span class="math display">\[
\begin{aligned}
    \boldsymbol a^{\mathrm T}\left(\boldsymbol b - x\boldsymbol a\right) &amp;= 0 \\
    \Rightarrow \boldsymbol a^{\mathrm T}x\boldsymbol a &amp;= \boldsymbol a^{\mathrm T}\boldsymbol b \\
    \Rightarrow x\boldsymbol a^{\mathrm T}\boldsymbol a &amp;= \boldsymbol a^{\mathrm T}\boldsymbol b \\
    \Rightarrow x &amp;= \frac{\boldsymbol a^{\mathrm T}\boldsymbol b}{\boldsymbol a^{\mathrm T}\boldsymbol a}
\end{aligned}
\]</span> 我们就得到了一开始的结论。如果把<span class="math inline">\(\boldsymbol a\)</span>写到左边（因为是向量的实数积所以可以交换） <span class="math display">\[
p = \boldsymbol a\cdot \frac{\boldsymbol a^{\mathrm T}\boldsymbol b}{\boldsymbol a^{\mathrm T}\boldsymbol a} = \frac{\boldsymbol a\boldsymbol a^{\mathrm T}}{\boldsymbol a^{\mathrm T}\boldsymbol a}\boldsymbol b
\]</span> 我们这下看清楚了：将<span class="math inline">\(\boldsymbol b\)</span>转变为其在<span class="math inline">\(\boldsymbol a\)</span>上的投影的是一个矩阵！这个矩阵<span class="math inline">\(P = \frac{\boldsymbol a\boldsymbol a^{\mathrm T}}{\boldsymbol a^{\mathrm T}\boldsymbol a}\)</span>被称为<strong>投影矩阵</strong>。</p>
<p>代数推导和投影矩阵有啥用？它们可以让我们把投影从投影到一个向量推广到投影到向量空间。</p>
<p>考虑如何把一个向量<span class="math inline">\(\boldsymbol b\)</span>投影到矩阵<span class="math inline">\(A = \begin{bmatrix} \boldsymbol {a_1} &amp;\boldsymbol {a_2} &amp;\cdots &amp;\boldsymbol {a_n}\end{bmatrix}\)</span>的列空间上（假设<span class="math inline">\(A\)</span>的列向量线性无关）。我们一样考虑<span class="math inline">\(\boldsymbol b\)</span>与<span class="math inline">\(\boldsymbol p\)</span>的差，其一定垂直于<span class="math inline">\(C(A)\)</span>，自然也垂直于<span class="math inline">\(\boldsymbol {a_1} \cdots \boldsymbol {a_n}\)</span>，于是就有： <span class="math display">\[
\boldsymbol {a_k} ^{\mathrm T}\left(\boldsymbol b - \boldsymbol p\right) = 0, \quad k = 1,2,\cdots,n
\]</span> 或者写在一起： <span class="math display">\[
\begin{bmatrix}
    \boldsymbol {a_1}^{\mathrm T} \\
    \boldsymbol {a_2}^{\mathrm T} \\
    \vdots \\
    \boldsymbol {a_n}^{\mathrm T} \\
\end{bmatrix}
\left(\boldsymbol b  - \boldsymbol p\right) = \boldsymbol 0 \Rightarrow 
A^{\mathrm T} \left(\boldsymbol b  - \boldsymbol p\right) = \boldsymbol 0
\]</span> 因为<span class="math inline">\(\boldsymbol p \in C(A)\)</span>，所以<span class="math inline">\(\boldsymbol p\)</span>是<span class="math inline">\(A\)</span>列向量的线性组合，可以写作<span class="math inline">\(\boldsymbol p = A\boldsymbol x\)</span>。于是我们就得到了方程 <span class="math display">\[
A^{\mathrm T} \left(\boldsymbol b  - A\boldsymbol x\right) = \boldsymbol 0 \Rightarrow A^{\mathrm T}A\boldsymbol x = A^{\mathrm T}\boldsymbol b
\]</span> 因为<span class="math inline">\(A\)</span>的列是线性无关的，所以<span class="math inline">\(A^{\mathrm T}A\)</span>是可逆的（这个我们待会证明），于是我们可以解得 <span class="math display">\[
\boldsymbol x = \left(A^{\mathrm T}A\right)^{-1}A^{\mathrm T}\boldsymbol b
\]</span> 即 <span class="math display">\[
\boldsymbol p = A\left(A^{\mathrm T}A\right)^{-1}A^{\mathrm T}\boldsymbol b
\]</span> 此时我们很清楚地看到，投影矩阵是<span class="math inline">\(P = A\left(A^{\mathrm T}A\right)^{-1}A^{\mathrm T}\)</span>。</p>
<hr />
<p>我们接下来证明之前我们用到的一个结论：<strong><span class="math inline">\(A^{\mathrm T}A\)</span>可逆的充分必要条件是<span class="math inline">\(A\)</span>的列向量线性无关</strong>。</p>
<p>我们发现这个结论等价于：<span class="math inline">\(A^{\mathrm T}A\)</span>和<span class="math inline">\(A\)</span>有相同的零空间。</p>
<p>怎么证明？一个方向是简单的： <span class="math display">\[
A\boldsymbol x = \boldsymbol 0 \Rightarrow A^{\mathrm T}\left(A\boldsymbol x\right) = \boldsymbol 0 \Rightarrow A^{\mathrm T} A\boldsymbol x = \boldsymbol 0
\]</span> 反方向的证明需要一些技巧： <span class="math display">\[
A^{\mathrm T} A\boldsymbol x = \boldsymbol 0 \Rightarrow \boldsymbol x^{\mathrm T} A^{\mathrm T} A\boldsymbol x = 0 \Rightarrow \left(A\boldsymbol x\right)^{\mathrm T}A\boldsymbol x = 0 \Rightarrow A\boldsymbol x = \boldsymbol 0
\]</span> 倒数第二步写得有点花里胡哨其实就是向量自己和自己的点积，如果是零的话显然原向量就是零。</p>
<p>证毕。</p>
<h1 id="最小二乘拟合">最小二乘拟合</h1>
<p>投影和最小二乘拟合是怎么联系起来的呢？</p>
<p>线性拟合的本质是用给定的若干列向量的线性组合表示另一个向量。</p>
<p>比如我有一组数据<span class="math inline">\(\boldsymbol x,\boldsymbol y\)</span>，我的模型是<span class="math inline">\(y = a + bx\)</span>，拟合的过程就是用向量<span class="math inline">\(\boldsymbol 1\)</span>和<span class="math inline">\(\boldsymbol x\)</span>的线性组合表示<span class="math inline">\(\boldsymbol y\)</span>的过程： <span class="math display">\[
\begin{bmatrix}
    1 &amp;x_1 \\
    1 &amp;x_2  \\
    \vdots &amp;\vdots\\
    1 &amp;x_n 
\end{bmatrix}
\begin{bmatrix}
    a \\
    b
\end{bmatrix} \stackrel{?}{=} 
\begin{bmatrix}
    y_1 \\
    y_2 \\
    \vdots \\
    y_n 
\end{bmatrix}
\]</span> “线性拟合”的线性指的是这种组合的线性，和模型本身的线性是没有关系的。模型里面有二次项不要紧，只要二次项和其他项是线性组合的，那也不过是在左边的矩阵里多了一个列向量而已： <span class="math display">\[
\begin{bmatrix}
    1 &amp;x_1 &amp;x_1^2 \\
    1 &amp;x_2 &amp;x_2^2 \\
    \vdots &amp;\vdots &amp;\vdots \\
    1 &amp;x_n &amp;x_n^2
\end{bmatrix}
\begin{bmatrix}
    a \\
    b \\
    c
\end{bmatrix} \stackrel{?}{=} 
\begin{bmatrix}
    y_1 \\
    y_2 \\
    \vdots \\
    y_n 
\end{bmatrix}
\]</span> 那么我们发现线性拟合的本质其实就是解一个形如<span class="math inline">\(A\boldsymbol x = \boldsymbol b\)</span>的方程组（这里的<span class="math inline">\(\boldsymbol x\)</span>表示模型中各项的系数，和上面表示自变量的<span class="math inline">\(\boldsymbol x\)</span>没有关系），这个我们老熟悉了。</p>
<p>但是事情不太妙的就是<span class="math inline">\(A\)</span>又高又瘦，方程组比未知数多，所以几乎肯定不存在准确解。</p>
<p>什么时候存在准确解？<span class="math inline">\(\boldsymbol b\)</span>要在<span class="math inline">\(A\)</span>的列空间<span class="math inline">\(C(A)\)</span>里。</p>
<p>所以如果只能求近似解，我们可以考虑把<span class="math inline">\(\boldsymbol b\)</span>“近似到”<span class="math inline">\(C(A)\)</span>中的一个最近的向量，然后就能求解了。</p>
<p>这个“近似”的过程其实就是投影。在<span class="math inline">\(C(A)\)</span>中<span class="math inline">\(\boldsymbol b\)</span>的投影肯定最接近<span class="math inline">\(\boldsymbol b\)</span>，因为只有二者的差是和<span class="math inline">\(C(A)\)</span>垂直的，这很符合我们的代数直觉。</p>
<p>所以联系之前的投影的推导，假设这个投影向量是<span class="math inline">\(A\boldsymbol{\hat{x}}\)</span>，我们直接写出方程和解： <span class="math display">\[
A^{\mathrm T} \left(\boldsymbol b  - A\boldsymbol{\hat{x}} \right) = \boldsymbol 0 \Rightarrow \boldsymbol{\hat{x}} = \left(A^{\mathrm T}A\right)^{-1}A^{\mathrm T}\boldsymbol b
\]</span> 这就叫“最小二乘拟合”。</p>
<hr />
<p>如果非要较真，从微积分的角度理解一波也是可以的：定义拟合的误差函数为 <span class="math display">\[
L= \left|\boldsymbol b - A\boldsymbol{\hat x}\right| = \sum_{i = 1}^n \left(\boldsymbol b_i - \left(A\boldsymbol{\hat x}\right)_i\right)^2
\]</span> 如果要最小化<span class="math inline">\(L\)</span>，那么<span class="math inline">\(L\)</span>关于<span class="math inline">\(\boldsymbol{\hat x}\)</span>的所有分量的导数都为<span class="math inline">\(0\)</span>： <span class="math display">\[
\frac{\mathrm d L}{\mathrm d\boldsymbol{\hat x}_k} = 2\sum_{i = 1}^n A_{i, k} \left(\left(A\boldsymbol{\hat x}\right)_i - \boldsymbol b_i\right) =  0, \quad \forall k = 1, 2, \cdots, n
\]</span> 令<span class="math inline">\(A\)</span>第<span class="math inline">\(i\)</span>列的列向量为<span class="math inline">\(\boldsymbol a_i\)</span>，那么上面也可以写成 <span class="math display">\[
\frac{\mathrm d L}{\mathrm d\boldsymbol{\hat x}_k} = 2\boldsymbol a_k^{\mathrm T} \left(A\boldsymbol{\hat x} - \boldsymbol b\right) =  0, \quad \forall k = 1, 2, \cdots, n
\]</span> 并在一起得 <span class="math display">\[
2A^{\mathrm T}\left(A\boldsymbol{\hat x} - \boldsymbol b\right) =  0
\]</span> 这就是上面我们通过投影推出的方程。</p>
<p><span class="math inline">\(L\)</span>中的平方项也是最小二乘中“二”的由来。</p>
<h1 id="矩阵的gram-schmidt正交化">矩阵的Gram-Schmidt正交化</h1>
<p>我们发现无论是投影还是最小二乘拟合，计算<span class="math inline">\(A^{\mathrm T}A\)</span>和它的逆都是绕不过去的一步。<span class="math inline">\(A^{\mathrm T}A\)</span>本身就有一些特殊的性质，比如说其一定是正方阵，一定是对称的（通过转置等于自身易证）。但是这些性质在计算的时候帮助不大。如果我们能够优化<span class="math inline">\(A\)</span>的形态从而简化<span class="math inline">\(A^{\mathrm T}A\)</span>和它的逆的计算，那么各种算法的效率都会高上不少。</p>
<p>注意到<span class="math inline">\(A^{\mathrm T}A\)</span>中的每一个位置都是<span class="math inline">\(A\)</span>两个列向量的点积。<strong>如果<span class="math inline">\(A\)</span>当中的列向量是两两正交的，那么<span class="math inline">\(A^{\mathrm T}A\)</span>就变成了一个对角阵。对角阵的逆不要太好算！更进一步，如果<span class="math inline">\(A\)</span>的每一个列向量都是单位向量，那么<span class="math inline">\(A^{\mathrm T}A\)</span>就是单位阵，连逆都不用求了</strong>！</p>
<p>所以说啊，正交是个好东西。那对于一个矩阵<span class="math inline">\(A\)</span>，通过什么样的方式将其列向量完成正交化呢？</p>
<p>比较简单的一个算法称为Gram-Schmidt正交化。设<span class="math inline">\(A\)</span>的列向量为<span class="math inline">\(\boldsymbol {a_1},\cdots, \boldsymbol{a_n}\)</span>，则向量正交化之后的结果<span class="math inline">\(\boldsymbol{q_i}\)</span>可以这么计算： <span class="math display">\[
\boldsymbol{q_i} = \boldsymbol{a_i} - \sum_{j = 1}^{i - 1} \frac{\boldsymbol{q_j}^{\mathrm T}\boldsymbol{a_i}}{\boldsymbol{q_j}^{\mathrm T}\boldsymbol{q_j}} \boldsymbol{q_j}
\]</span> 即对于第<span class="math inline">\(i\)</span>个列向量通过减去其在所有之前的（完成正交化的）向量上的投影来确保其和前面的向量都正交。</p>
<p>最后，把所有的<span class="math inline">\(\boldsymbol{q_i}\)</span>除以其模完成归一化，我们就可以得到一个标准正交列向量组成的矩阵<span class="math inline">\(Q\)</span>，满足<span class="math inline">\(Q^{\mathrm T}Q = I\)</span>。（线性代数中常使用<span class="math inline">\(Q\)</span>表示列向量标准正交的矩阵）</p>
<p>从<span class="math inline">\(A\)</span>变到<span class="math inline">\(Q\)</span>的过程没有改变列空间，所以不会改变投影矩阵，但计算投影矩阵的开销大大降低了： <span class="math display">\[
P = Q\left(Q^{\mathrm T}Q\right)^{-1}Q^{\mathrm T} = QQ^{\mathrm T}
\]</span></p>
<h1 id="qr分解">QR分解</h1>
<p>Gram-Schmidt正交化的过程可以看作是在原矩阵上进行列变换，而列变换是可以用矩阵表示的。类比从高斯消元导出LU分解的思路，我们可以从Gram-Schimidt正交化导出一个矩阵的QR分解： <span class="math display">\[
A = QR
\]</span> 我们有<span class="math inline">\(A\)</span>，可以通过Gram-Schmidt正交化算出<span class="math inline">\(Q\)</span>，但<span class="math inline">\(R\)</span>怎么计算呢？因为<span class="math inline">\(Q^{\mathrm T}Q=I\)</span>，所以只要在等式两边同时乘以<span class="math inline">\(Q^{\mathrm T}\)</span>，就得到<span class="math inline">\(R=Q^{\mathrm T}A\)</span>。或者用<span class="math inline">\(Q\)</span>和<span class="math inline">\(A\)</span>的列向量表示： <span class="math display">\[
R = \begin{bmatrix}
    \boldsymbol{q_1}^{\mathrm T} \\
    \boldsymbol{q_2}^{\mathrm T} \\
    \vdots \\
    \boldsymbol{q_n}^{\mathrm T}
\end{bmatrix}
\begin{bmatrix}
    \boldsymbol{a_1} &amp;\boldsymbol{a_2} &amp;\cdots &amp;\boldsymbol{a_n}
\end{bmatrix}
= \begin{bmatrix}
    \boldsymbol{q_1}^{\mathrm T}\boldsymbol{a_1} &amp;\boldsymbol{q_1}^{\mathrm T}\boldsymbol{a_2} &amp;\cdots &amp;\boldsymbol{q_1}^{\mathrm T}\boldsymbol{a_n} \\
    \boldsymbol{q_2}^{\mathrm T}\boldsymbol{a_1} &amp;\boldsymbol{q_2}^{\mathrm T}\boldsymbol{a_2} &amp;\cdots &amp;\boldsymbol{q_2}^{\mathrm T}\boldsymbol{a_n} \\
    \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\
    \boldsymbol{q_n}^{\mathrm T}\boldsymbol{a_1} &amp;\boldsymbol{q_n}^{\mathrm T}\boldsymbol{a_2} &amp;\cdots &amp;\boldsymbol{q_n}^{\mathrm T}\boldsymbol{a_n}
\end{bmatrix}
\]</span> 注意到，因为<span class="math inline">\(\boldsymbol{q_i}\)</span>正交于所有<span class="math inline">\(\boldsymbol {q_j}(i &lt; j)\)</span>，而<span class="math inline">\(\boldsymbol{a_j}\)</span>又是由<span class="math inline">\(\boldsymbol{q_1},\cdots,\boldsymbol{q_j}\)</span>表示的，所以<span class="math inline">\(i &gt; j\)</span>时，<span class="math inline">\(\boldsymbol{q_i}^{\mathrm T}\boldsymbol{a_j} = 0\)</span>。所以<span class="math inline">\(R\)</span><strong>其实是一个上三角阵</strong>： <span class="math display">\[
R = \begin{bmatrix}
    \boldsymbol{q_1}^{\mathrm T}\boldsymbol{a_1} &amp;\boldsymbol{q_1}^{\mathrm T}\boldsymbol{a_2} &amp;\cdots &amp;\boldsymbol{q_1}^{\mathrm T}\boldsymbol{a_n} \\
    0 &amp;\boldsymbol{q_2}^{\mathrm T}\boldsymbol{a_2} &amp;\cdots &amp;\boldsymbol{q_2}^{\mathrm T}\boldsymbol{a_n} \\
    \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\
    0 &amp;0 &amp;\cdots &amp;\boldsymbol{q_n}^{\mathrm T}\boldsymbol{a_n}
\end{bmatrix}
\]</span> 再观察<span class="math inline">\(R\)</span>的各个非零位置的值以及Gram-Schimidt的公式，其实<span class="math inline">\(R\)</span>是可以在计算Gram-Schmidt正交化的时候顺便算出来的。</p>
<p>QR分解有什么用呢？之前我们说正交化不改变投影矩阵，原因是“正交化不改变列空间”，QR分解能让我们在代数上证明这一点： <span class="math display">\[
\begin{aligned}
    P &amp;= A\left(A^{\mathrm T}A\right)^{-1}A^{\mathrm T} \\
    &amp;= QR\left(R^{\mathrm T}Q^{\mathrm T}QR\right)^{-1}R^{\mathrm T}Q^{\mathrm T} \\
    &amp;= QR\left(R^{\mathrm T}R\right)^{-1}R^{\mathrm T}Q^{\mathrm T} \\
    &amp;= QRR^{-1}\left(R^{\mathrm T}\right)^{-1}R^{\mathrm T}Q^{\mathrm T} \\
    &amp;= QQ^{\mathrm T}
\end{aligned}
\]</span> 注：因为<span class="math inline">\(R\)</span>是一个方阵，所以我们这里能够把<span class="math inline">\(\left(R^{\mathrm T}R\right)^{-1}\)</span>改写成<span class="math inline">\(R^{-1}(R^{\mathrm T})^{-1}\)</span>。<span class="math inline">\(\left(A^{\mathrm T}A\right)^{-1}\)</span>是不能这么转换的，因为长方阵不存在常规意义上的逆。</p>
<p>类似地，QR分解还简化了最小二乘拟合的计算： <span class="math display">\[
\boldsymbol{\hat{x}} = \left(A^{\mathrm T}A\right)^{-1}A^{\mathrm T}\boldsymbol b = R^{-1}Q^{\mathrm T}\boldsymbol b
\]</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/PyMinecraft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/PyMinecraft/" class="post-title-link" itemprop="url">用Python非侵入式自动化原版Minecraft</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-02-23 07:34:40" itemprop="dateModified" datetime="2020-02-23T07:34:40-05:00">2020-02-23</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>似乎博客又有一个月没有更了呢<del>而且一个月前挖的坑似乎还没有填完? 持续咕咕咕</del></p>
<p>我前几天玩Minecraft挖矿的时候我就一直在思考一个问题</p>
<blockquote>
<p>如何自动化MC里面像挖矿这么无脑的操作呢？</p>
</blockquote>
<p>其实现成的想法还是很多的：</p>
<ol type="1">
<li>用粘液块和红石（Slimestone）实现半自动化（例如SciCraft里面的盾构）。SciCraft用这个方法挖了103000颗钻石，优点是纯原版，缺点是其实还是很肝，而且技术性非常强。</li>
<li>利用mod的解决方案：像IC2，Mekanism这些mod其实都有自动化的解决方案。优点是比较简单。缺点是非原版，通用性比较差，而且自动挖矿在这些mod里面基本上也是大后期了，搭这一套措施很肝。</li>
<li>利用客户端mod的解决方案：利用FreeCam或者透视这种客户端mod可以在服务端原版的情况下达到类似自动化的效果，但是缺点是这个是作弊。</li>
<li>Carpet Mod：这个mod的<code>/player</code>命令是在服务端生成一个假的玩家实体并进行操作，好处就是简单，快捷，不会掉线。而且Carpet现在搭了Fabric的顺风车更新得非常勤快。缺点就是服务端要装Carpet，如果不是自己开服基本用不了，而且说实话Carpet的自动化比较简单（本来是配合SciCraft那一套设计的）。</li>
<li><a target="_blank" rel="noopener" href="http://minerl.io/">MineRL</a>：直接利用强化学习解决一切自动化问题。优点是几乎啥都可以干，缺点是技术含量非常非常高，而且训练的硬件要求非常高。说实话我觉得是overkill。</li>
</ol>
<p>这些方案各有优缺点，其实对于我这种玩偶尔玩第三方服务器的人2、3、4基本上就可以否决掉了，1的话门槛比较高，5的话没有那硬件资源。所以这几天我自己试验了一个适合我需求的方案，还算不错。</p>
<h1 id="初步设计">初步设计</h1>
<p>简单来说呢，我的想法是这个样子的</p>
<ol type="1">
<li>不断截取游戏窗口</li>
<li>通过OCR读取F3界面的字符</li>
<li>获得玩家的位置</li>
<li>通过闭环控制器控制玩家行动</li>
<li>通过模拟键盘和鼠标事件来进行实际的控制</li>
</ol>
<p>这个解决方案和MineRL靠的比较近，都是比较贴近于实际玩游戏的过程。我最看重的一个有点就是这个解决方案完全不需要修改客户端，而且因为F3界面格式万年不变而且从很早版本就有了导致这个解决方案的版本兼容性超强，即使是玩第三方服务器第三方客户端也丝毫不虚。那么剩下来的就是用Python实现这一连串过程了。</p>
<h1 id="用到的第三方库">用到的第三方库</h1>
<pre class="line-numbers"><code class="language-python">import cv2 as cv
import numpy as np

import win32gui
import win32ui
import win32con

import keyboard
import mouse</code></pre>
<p>上面是图像处理标准操作，中间是Win32标准操作，下面是鼠标和按键模拟用的（其实用win32api也可以解决，但是我还是想保留一点OS兼容性）。</p>
<h1 id="游戏窗口截取">游戏窗口截取</h1>
<p>因为我用的是Windows所以这个部分理所应当地用Pywin32来做，我个人对于Win32 API不是特别地熟悉（常年面向MSDN编程），Pywin32做接口之后就更搞不清楚了，于是上网上东抄抄西抄抄就做完了。我把这部分代码理了一下，通用性还是比较高的。</p>
<pre class="line-numbers"><code class="language-python">Hwnd = int

def get_window_with_title(keyword: str) -&gt; Hwnd:
    &quot;&quot;&quot;
    Gets the first window whose title contains the keyword, if any
    !!! WIN 32 ONLY !!!
    :param keyword: the keyword
    :return: the first window whose title contains keyword, None if not found
    &quot;&quot;&quot;

    def callback(hwnd: Hwnd, extra: List[Hwnd]):
        if win32gui.IsWindowVisible(hwnd) and win32gui.IsWindowEnabled(hwnd) \
                and keyword in win32gui.GetWindowText(hwnd):
            extra.append(hwnd)

    ret: List[Hwnd] = []
    win32gui.EnumWindows(callback, ret)
    return ret[0] if ret else None


def capture_screen_of(hwnd: Hwnd, rect=None) -&gt; np.ndarray:
    &quot;&quot;&quot;
    Capture screen of hwnd, using win32 API
    !!! WIN 32 ONLY !!!
    :param hwnd: the window handle
    :param rect: the rectangle, default value None, which means to capture the whole window
    :return: the screen capture (RGBA) in numpy array format
    &quot;&quot;&quot;
    window_dc = win32gui.GetWindowDC(hwnd)
    dc_object = win32ui.CreateDCFromHandle(window_dc)
    compat_dc = dc_object.CreateCompatibleDC()
    bitmap = win32ui.CreateBitmap()
    if not rect:
        rect = win32gui.GetWindowRect(hwnd)
        rect = (0, 0, rect[2] - rect[0], rect[3] - rect[1])
    width, height = rect[2] - rect[0], rect[3] - rect[1]
    start = (rect[0], rect[1])
    bitmap.CreateCompatibleBitmap(dc_object, width, height)
    compat_dc.SelectObject(bitmap)
    compat_dc.BitBlt((0, 0), (width, height), dc_object, start, win32con.SRCCOPY)
    img = np.frombuffer(bitmap.GetBitmapBits(True), dtype=&#39;uint8&#39;)
    img.shape = (height, width, 4)
    dc_object.DeleteDC()
    compat_dc.DeleteDC()
    win32gui.ReleaseDC(hwnd, window_dc)
    win32gui.DeleteObject(bitmap.GetHandle())
    return img</code></pre>
<p>（出于常年写静态语言的习惯还是加上了type annotation）</p>
<h1 id="ocr">OCR</h1>
<p>这是最头大的部分了，我一开始的想法非常天真：Tesseract OCR，G家这么好的轮子不用干啥。结果</p>
<ol type="1">
<li>Tesseract下载下来好几十MB，这瞬间让整个项目的dependencies复杂了起来。</li>
<li>Tesseract似乎很慢，跑一次F3界面要跑0.5秒，我这算法要是按照2FPS的速度跑那玩家的反射弧要长出天际了。其实考虑到Tesseract很多都是在用LSTM这种速度也不奇怪。</li>
<li>Tesseract对于Minecraft默认像素风字体的支持不好。如果要提升效果就要额外train。</li>
</ol>
<p>这三个因素加起来最终还是把Tesseract枪毙了。Python常见的OCR解决方案似乎只有这一家，所以只能自己设计OCR算法了。</p>
<p>其实在我的这个场景里OCR的要求不高，因为</p>
<ol type="1">
<li>因为是截屏所以像素亮度很平整，也不会有扭曲或者畸变</li>
<li>我可以获取到Minecraft的字体文件</li>
</ol>
<p>这两个因素在一起让这里的OCR退化成了template matching。</p>
<p>从客户端<code>jar</code>文件里提取出来字体文件本身不是一件特别复杂的事，唯一可能复杂一点的地方就是要把字体位图当中透明色变成灰色：</p>
<pre class="line-numbers"><code class="language-python">font_atlas_file = &quot;unicode_page_00.png&quot; # Minecraft的Unicode字体位图
font_atlas = cv.imread(font_atlas_file, cv.IMREAD_UNCHANGED)
font_atlas = cv.threshold(font_atlas[:, :, 3], 127, 255, cv.THRESH_BINARY)[1]</code></pre>
<p>接下来是文字提取。经过我的测试Minecraft的F3界面文字在灰度图像下的前景色在<code>220-225</code>左右非常固定，而且文字背后半透明灰色的遮罩使文字的周围不会出现干扰。这样提取文字部分只需要threshold一下就解决了，运用OpenCV的代码非常简短：</p>
<pre class="line-numbers"><code class="language-python">f3_color = (221, 225)
...
# cap是截图
img = cv.cvtColor(cap, cv.COLOR_BGR2GRAY if cap.shape[2] == 3 else cv.COLOR_BGRA2GRAY)
img = cv.threshold(img, f3_color[1], 255, cv.THRESH_TOZERO_INV)[1]
img = cv.threshold(img, f3_color[0] - 1, 255, cv.THRESH_BINARY)[1]</code></pre>
<p>接下来只要对于字符集当中的每一个文字，从字体位图里面找到点阵字体然后跑模板匹配就行了</p>
<pre class="line-numbers"><code class="language-python">chars: List[Tuple[int, int, str]] = []
for ch in charset:
    font = bitmap_fonts[ord(ch)]
    x = cv.matchTemplate(img, font, cv.TM_CCORR_NORMED)
    # noinspection PyTypeChecker
    chars.extend(zip(*np.where(x &gt; match_threshold), repeat(ch)))</code></pre>
<p>最后是把识别出来的单个字符串联成行。这一部分的主要思路是把纵坐标在一定范围内的字符按照横坐标排序然后顺次拼接就行了。下面的代码还可以做亿点优化，但是这一部分不是本算法的瓶颈（上面的模式匹配才是），所以我懒了：</p>
<pre class="line-numbers"><code class="language-python">img_width = img.shape[1]
chars.sort(key=lambda tup: tup[0] * img_width + tup[1])
last_y = -1 - max_line_height_deviation
lines: List[List[Tuple[int, int, str]]] = []
for ch in chars:  
    if ch[0] - last_y &gt; max_line_height_deviation:
        last_y = ch[0]
        lines.append([])
    lines[-1].append(ch)
ret: List[str] = []
for line in lines: 
    line_str: str = &quot;&quot;
    error = True
    for (i, ch) in enumerate(line):
        if i &gt; 0 and ch[1] - line[i - 1][1] &gt; whitespace_width:  
            line_str += &#39; &#39;
        line_str += ch[2]
        error &amp;= ch[2] in [&#39;.&#39;, &#39;-&#39;, &#39;_&#39;]  
    if not error:
            ret.append(line_str)
return ret</code></pre>
<p>注意要集中处理的是有些字符会因为字体的原因容易被错误识别，例如<code>.</code>, <code>_</code>, <code>-</code>(后两个在MC的字体里面根本就是一样的)。这一部分要去除。同时因为空格无论怎么样都不会被模板匹配识别出来，所以要通过字间距的差别来插入。</p>
<p>这个算法的运行时间是和字符集大小成正比的，因此字符集的精简很重要。在这里我其实只采用了<code>0123456789XYZFLa./-</code>这些字符，这些数字和符号确保可以正常识别数字，<code>XYZ</code>确保可以识别坐标，<code>Fa</code>确保可以识别朝向（<code>Facing</code>），<code>L</code>确保可以识别指向（<code>Looking at</code>）。总体来说这一部分的算法虽然简陋但是堪堪够用。在精简字符集后可以跑到20FPS，已经是Tesseract的10倍多了。</p>
<p>在试验过程中比较有意思的一个发现是Minecraft的默认ASCII字体渲染是一个比较复杂的过程，似乎不是按照<code>ascii.png</code>上的内容直接来的（我的理解是似乎加了一些hint），导致模板匹配的思路在ASCII字体的时候是行不通的，必须在设置里面强制开启Unicode字体。</p>
<h1 id="读取玩家信息">读取玩家信息</h1>
<p>在OCR之后读取玩家信息就是水到渠成的事情了。我的OCR已经把行都划好了，只需要选取特定字符开头的行做一下字符串分割和parse就完成了。</p>
<h1 id="闭环控制">闭环控制</h1>
<p>最后一步当然是通过一个闭环控制器来控制玩家的运动。这一部分出于我在机器人社的经验我糊了一个P controller <del>ID部分懒得写了</del>来控制玩家的朝向，再写了个bang bang control来控制玩家的XZ坐标（在生存模式下Y坐标一般来说是控制不了的）。稍微比较烦的地方就是MC对于方位角的表示方式，需要一些分类讨论和转换。控制频率100Hz，效果差强人意，已经足够作为一个proof-of-concept了：</p>
<pre class="line-numbers"><code class="language-python">def control_thread_func(coord_tol: float = 0.5, yaw_tol: float = 2, pitch_tol: float = 2):
    &quot;&quot;&quot;
    The control thread. If abs(error_target) &lt;= x_target, then the target will be considered reached
    :param coord_tol: coordinate tolerance
    :param yaw_tol: yaw tolerance
    :param pitch_tol: pitch tolerance
    :return: runs forever
    &quot;&quot;&quot;
    kp_yaw, kp_pitch = 0.5, 0.4 
    global target_yaw
    global target_pitch
    global reached_yaw
    global reached_pitch
    global reached_coord
    w, a, s, d = False, False, False, False # 记录WASD四个键状态
    move_threshold = 0.5 # 如果在一个坐标分量上的偏差小于这个值那就不按这个分量上的按键了
    turn_threshold = 1.5 # 每一次鼠标至少要动这么多

    def key_cond(val, key, cond):
        if val and not cond:
            keyboard.release(key)
            return False
        if not val and cond:
            keyboard.press(key)
            return True
        return val

    while True:
        if not in_control or not player_info:
            time.sleep(0.05)
            continue

        yaw, pitch = player_info.facing
        coord = xyz2xz(player_info.coord)

        # 坐标控制
        error_coord = math.hypot(target_coord[0] - coord[0], target_coord[1] - coord[1])
        reached_coord = error_coord &lt; coord_tol
        theta = math.atan2(target_coord[0] - coord[0], target_coord[1] - coord[1])
        ws = math.cos(theta + math.radians(yaw)) * error_coord
        ad = math.sin(theta + math.radians(yaw)) * error_coord
        w = key_cond(w, &quot;w&quot;, ws &gt; move_threshold)
        s = key_cond(s, &quot;s&quot;, ws &lt; -move_threshold)
        a = key_cond(a, &quot;a&quot;, ad &gt; move_threshold)
        d = key_cond(d, &quot;d&quot;, ad &lt; -move_threshold)

        # 摄像头朝向控制
        target_pitch = max(-90, min(90, target_pitch))
        if auto_yaw and not reached_coord: 
            target_yaw = -math.degrees(math.atan2(target_x - x, target_z - z))
        if target_yaw &gt; 180:
            target_yaw -= 180
        if target_yaw &lt; -180:
            target_yaw += 180
        error_yaw = target_yaw - yaw
        if abs(error_yaw - 360) &lt; abs(error_yaw):
            error_yaw -= 360
        if abs(error_yaw + 360) &lt; abs(error_yaw):
            error_yaw += 360
        error_pitch = target_pitch - pitch
        reached_yaw = abs(error_yaw) &lt; yaw_tol
        reached_pitch = abs(error_pitch) &lt; pitch_tol
        if not reached_yaw:
            d_yaw = kp_yaw * error_yaw
            if abs(d_yaw) &lt; turn_threshold:
                d_yaw = math.copysign(turn_threshold, error_yaw)
        else:
            d_yaw = 0
        if not reached_pitch:
            d_pitch = kp_pitch * error_pitch
            if abs(d_pitch) &lt; turn_threshold:
                d_pitch = math.copysign(turn_threshold, error_pitch)
        else:
            d_pitch = 0
        mouse.move(d_yaw, d_pitch, absolute=False)

        time.sleep(0.01)</code></pre>
<h1 id="测试">测试</h1>
<p>写完之后我写了一个简单的挖矿脚本，可以挖1x2的矿道并且插上火把点亮：</p>
<pre class="line-numbers"><code class="language-python">def wait_turn():
    time.sleep(0.01)
    while player_info and (not reached_yaw or not reached_pitch):
        time.sleep(0.05)


def wait_coord():
    time.sleep(0.01)
    while player_info and not reached_coord:
        time.sleep(0.05)

def start_mining():
    global in_control
    global target_coord
    global target_yaw
    global target_pitch
    if player_info is None:
        return
    if player_info.target_block is None:
        return
    direction = xyz2xz(player_info.target_block - np.floor(player_info.coord))
    target_coord = xyz2xz(player_info.coord)
    target_yaw = -math.degrees(math.atan2(direction[0], direction[1]))
    in_control = True
    target_pitch = 0
    moved = 0
    wait_turn()
    try:
        while True:
            moved += 1
            mouse.press() # 开始挖摄像头正对的方向
            while np.linalg.norm(xyz2xz(player_info.target_block - np.floor(player_info.coord))) &lt; 1.:
                time.sleep(0.01)
            mouse.release() # 挖完了
            if moved % 5 == 0: # 每挖五格就插一个火把（在副手）
                target_yaw += 30
                wait_turn()
                mouse.right_click()
                time.sleep(0.1)
                target_yaw -= 30
            target_pitch = 40 # 低头
            wait_turn()
            mouse.press() # 开始挖下面的那一格
            while np.linalg.norm(xyz2xz(player_info.target_block - np.floor(player_info.coord))) &lt; 1.:
                time.sleep(0.01)
            mouse.release()
            target_coord = xyz2xz(np.floor(player_info.coord)) + np.array([0.5, 0.5]) + 0.7 * direction # 前进！
            target_pitch = 0 # 双眼平视前方
            wait_turn()
            wait_coord()
    except Exception:
        in_control = False
        mouse.release()
        print(&quot;exit&quot;)
        return
</code></pre>
<p>这个脚本运行的非常顺畅（虽然并不总是成功，这和玩家坐标控制的精度有很大关系）。已经初步有了实用价值。看起来我这个技术路线总体还是可行的。当然现在的功能非常简陋，但是F3的信息非常丰富，如果拓展一下用途还是非常丰富的。当然最重要的还是这个脚本可以适用于所有有F3界面的Minecraft版本，版本兼容性堪称完美，爽到。</p>
<p><del>写这个脚本花了2个小时，就是为了挖一个简单的矿，这么算来似乎有点亏？！</del></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/PanDownload/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/PanDownload/" class="post-title-link" itemprop="url">自己对于PanDownload的一些想法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-04-17 07:46:00" itemprop="dateModified" datetime="2020-04-17T07:46:00-04:00">2020-04-17</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>PanDownload前几天被封了。</p>
<p>网络上那个群情激奋啊，看B站连“百度的七宗罪”都出来了。还有人把GFW做的DNS污染，域名置换等和PanDownload做的“多线程下载百度云盘”相并列，不乏讥讽地质问为何遭到制裁的是看起来程度最轻的PanDownload。</p>
<p>我不是PanDownload的使用者，自己也很少用百度云盘，或许称不上是特别利益相关者吧。</p>
<p>但看到这个新闻的时候我是很矛盾的。</p>
<p>我讨厌百度吗？</p>
<p>肯定的，我从八年前开始用百度云盘，从不限速的年代一路用到限速的坑爹时代，不恨是不可能的。</p>
<p>我喜欢PanDownload吗？</p>
<p>喜欢的，我自己两三年以前还在用很多油猴的提取直连的脚本，这种绕开限速薅羊毛的软件我不要太喜闻乐见。</p>
<p>那在这次事件中我支持PanDownload吗？</p>
<p>我其实想保持中立。</p>
<p>我们对于PanDownload等一众软件的推崇源于对于百度免费用户限速的痛恶。由俭入奢易由奢入俭难，对于限速的痛恶则源于几年前限速不存在的事实。</p>
<p>但是仔细想想，免费的大云盘这件天上掉馅饼的事情合理吗？</p>
<p>参照如今硬盘的价格以及带宽的价格，我觉得百度留着云盘业务肯定不是做慈善的。在线存储是一种服务，是企业生产的一种产品，收费这件事情本身是无可厚非的。放眼国外市场，Dropbox，Google Drive等也没有做慈善的。不是空间小就是下载慢。</p>
<p>要说百度可恶，也就可恶给用户提供了“一开始的美好”，用2TB的存储空间诱惑用户，等用户粘性培养上来之后，在几年前再限速到一个坑爹的地步，这个时候你左右为难。付钱吧，跟几年前比感觉亏了，不付钱吧，自己很多数据还存着呢。反正百度这几年的潜台词是越来越明显了：不付钱别玩，让你免费用已经是施舍你了，还BB那么多干嘛。</p>
<p>这句话很让人恼火，非常让人恼火，但是仔细思考一下，似乎是对的。云盘是一个市场，在市场里哪有永远白嫖的份。这个时候最好的结局是期待着市场竞争逼着百度降价。但是我国云盘市场的竞争着实不够激烈，百度隐隐形成垄断之势，降价看来是遥遥无期了（话又说回来，一个月25块钱的价格换算成美元大概与Google Drive差不多，其实真没那么多好抱怨的）。</p>
<p>这个时候PanDownload以及一众多线程下载软件出现了。几十个线程一起下，让免费用户看到了曙光。</p>
<p>我们不妨把PanDownload看做是网盘市场的一个有力的竞争者（虽然竞争并非其初衷），把它的下载服务看做是一个全新的网盘产品，它提供的“网盘产品”的竞争性优势在于</p>
<ol type="1">
<li>和已有百度网盘资料的完全兼容</li>
<li>免费用户的高速下载</li>
</ol>
<p>如果PanDownload的网盘产品真的是独立而全新的，那百度该死，谁也不能阻止PanDownload一统江湖。</p>
<p>但是事实不是这个样子的，PanDownload提供的这个如此有竞争性的“产品”，是基于百度网盘的生产资料与资本建立起来的。PanDownload运用的多线程下载，亦或是其他软件的直链提取，这些都不是百度网盘官方提供的API，也不是百度网盘官方认可的。</p>
<p>因此，全民的喜闻乐见与对于百度的痛恨，也改变不了PanDownload不正当竞争（视作竞争者）或者说侵犯百度权益（是做第三方软件）的事实。</p>
<p>单纯地因为PanDownload是在造福人类，是在薅垃圾公司的羊毛，就对这种行为的本质视而不见，其实是违背法治社会的初衷的。</p>
<p>这就仿佛所有人都认为张三是人渣，李四替天行道把张三打死了就可以不犯法一样。事实上，哪怕张三是在逃的杀人犯过街喊打喊打，如果不处于类似正当防卫的情形，李四把张三打死也是不对的。故意杀人就是故意杀人。何况百度作为一家公司目前来看还没有在云盘的运营中触犯法律（或许有垄断？不清楚）。前几天在B站上看罗翔老师说“法律要考虑民众的诉求，但是要超越民众的偏见”。</p>
<p>百度这叫体量大，如果是一家新创业的公司，被这么一集体白嫖，搞得破产了怎么办？这种事情不是没有发生过。难道法律里面还要加入一条“如果体量够大而且民众不爽，某某法规就失效”？</p>
<p>如果对百度不爽，就尽量避免去用它。现在搭建一个自己的网盘已经是很简单的一件事情了。</p>
<p>何况部分用户离不开百度网盘的原因大概是因为下”资源“，所谓”资源“，又大致可以分为免费（说的不好一点就是盗版）的电影与一些淫秽资源。后者我不想多说啥（其实吧，我觉得一些黄站之于内容提供者也是PanDownload之于百度网盘的存在），但是免费下盗版竟然还有理了？</p>
<p>没错，一直白嫖一直爽是中文互联网的常态，我自己也爱装破解版软件，看视频听音乐能不付钱就不付钱，但是理直气壮地说出来又是另一回事情了。百度给你下就不错了，PanDownload让你下爽了就下爽了，但是这种处于灰色地带的软件，要较真起来，我们真的不占理。</p>
<p>或许吧，网民一直隐隐有一种心态，在网络上白嫖是对的，反正就是一堆数据拷来拷去，百度云盘也就是一个网站而已，付费下载闻所未闻。这种心态在我看来是有问题的。垄断着实可恶，但是支付给服务提供者报酬的道理还是不错的。</p>
<p>因此，我觉得PanDownload虽然对于我们是一款好软件，但是最近取缔PanDownload这一事，我觉得还是无可厚非的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chengyuan Ma</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js" integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha512-br8H6OngKoLht57WKRU5jz3Vr0vF+Tw4G6yhNN2F3dSDheq4JiaasROPJB1wy7PxPk7kV/+5AIbmoZLxxx7Zow==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-bash.min.js" integrity="sha512-JvRd44DHaJAv/o3wxi/dxhz2TO/jwwX8V5/LTr3gj6QMQ6qNNGXk/psoingLDuc5yZmccOq7XhpVaelIZE4tsQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-c.min.js" integrity="sha512-T6Lco61aWqCKSznWkd38lf159pD0+EwZ9UCEv6ARAvaWFiy/UHtYgOmlasT8lq5Ck17ZNHzbe5eHUablTGRXxw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cmake.min.js" integrity="sha512-M99z3be36IUB5pA3DWoJvjSYaZA9BiUqf1jXzVcjntASBZFNI53oDRzdJqGzH5voybcAx5Sg8F5QyryE6afD3g==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cpp.min.js" integrity="sha512-hxZJ6OUEpUl9/o4C1gMGvrAbeqDaldBiZbs08c/V8NcU7YImBFlqJAc7Uzjf3bh2W8Wx26/dVDyPk9cUMQY0Mw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-go.min.js" integrity="sha512-SgF1uayJ2/8TV+MhLasqygnm++vYRXswmrR2ZAmUCL4pXtf+6KzUgXPpn10Y6xca658sxOQEOsoP3MChfhke5A==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-java.min.js" integrity="sha512-PWHY6Vao4E9K4LsGBYCY0ttDeiWZwuUozTbJvSy9UFHRz2J4Bl7rcWML3wEnJTVuCJhSwGne/8My5gTo/gnbpg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-json.min.js" integrity="sha512-IC7rV8RslChgByOdUFC6ePqOGn+OwJhnKC3S5AezM8DAiOdGhJMwgsIvBChsa2yuxxoPbH2+W/kjNUM1cc+jUQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-kotlin.min.js" integrity="sha512-aTozTdtORp/xxS/dhRRDfmv/p1eyEMTje96MplkSOqdbKGGvOYIlogoGdtsh/BD91vaqKoAw9M7O/DodqqudIQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-julia.min.js" integrity="sha512-eTGeKQdDzC2rPAUVfM2Fa36s9B9wp138NEhzZqJpRSdJQ66BwLUot25r2YQveCRU5uYNVfX3gckDkl4byfBIWw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-latex.min.js" integrity="sha512-6D3l3Fy8g/hr6AeK2g1rcVZHyFjCqiqgUrwy0mBZTGFd8UwVcUDhzQeIIv3eYeXDecGPTtBOS9ctyRzJyUgypQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-rust.min.js" integrity="sha512-kgT7r2HlCEO4b+Rp3nJvm+/EMBwGMvv1WMdWkb3eNgnS91llMli8Y3T1CgnD8Hifqx50Q3XLUQXDd7PzKQQtUA==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-python.min.js" integrity="sha512-wK9tQmDrstGtZqTKcyVf3h457QGMlNriKs+fHmEkiCizrq0LVovfT3v1smeT1DlQetHhdRkkX1JSuZg5LoNHJg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-nginx.min.js" integrity="sha512-/MNzg8GlnVrAau/TZClh1jxgHNX0HDgidbGnHS5x1OtbKiNoK3e0XNd1oV16xmmeDHjisa3GKLArUau+43GZ4A==" crossorigin="anonymous"></script>
<script type = "text/javascript">
    document.addEventListener('pjax:complete', function() {
        if (typeof Prism !== 'undefined') {
            Prism.highlightAll();
        }
    });
</script>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  






  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    <div class="pjax">

  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



    </div>
</body>
</html>
