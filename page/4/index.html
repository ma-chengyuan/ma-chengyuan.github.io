<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ma-chengyuan.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="不务正业高中生一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="Chengyuan Ma&#39;s Blog">
<meta property="og:url" content="https://ma-chengyuan.github.io/page/4/index.html">
<meta property="og:site_name" content="Chengyuan Ma&#39;s Blog">
<meta property="og:description" content="不务正业高中生一枚">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chengyuan Ma">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ma-chengyuan.github.io/page/4/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.css" integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbggqjHJeyzx88I3rfwjS38WJag/ihH7lzuGlGHpDBymLirZQ==" crossorigin="anonymous" />
<title>Chengyuan Ma's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-65HSG5NCY6"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-65HSG5NCY6');
      }
    </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Chengyuan Ma's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-pagedewarp"><a href="/dewarp/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>PageDewarp</a></li>
        <li class="menu-item menu-item-english"><a href="/english/" rel="section"><i class="fa fa-globe-americas fa-fw"></i>English</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chengyuan Ma"
      src="/avatar.png">
  <p class="site-author-name" itemprop="name">Chengyuan Ma</p>
  <div class="site-description" itemprop="description">不务正业高中生一枚</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">95</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://kalasearch.cn/" title="https:&#x2F;&#x2F;kalasearch.cn&#x2F;" rel="noopener" target="_blank">卡拉搜索</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ma-chengyuan.github.io/2020/07/04/%E8%AE%A8%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/04/%E8%AE%A8%E5%88%86/" class="post-title-link" itemprop="url">计一次讨分失败</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-04 10:38:36" itemprop="dateCreated datePublished" datetime="2020-07-04T10:38:36-04:00">2020-07-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>数学出分了，我最后一题分数被扣光。</p>
<p><img src="/2020/07/04/%E8%AE%A8%E5%88%86/prob.jpg" class=""></p>
<p>我的答案是</p>
<p><img src="/2020/07/04/%E8%AE%A8%E5%88%86/mine.jpg" class=""></p>
<p>而很显然参考答案是</p>
<p><img src="/2020/07/04/%E8%AE%A8%E5%88%86/chen.jpg" class=""></p>
<p>嘛确实是不一样的。但是我的答案和参考答案是等价的啊！</p>
<p><img src="/2020/07/04/%E8%AE%A8%E5%88%86/proof.png" class=""></p>
<p>最多形式不优美，怎落得如此下场？</p>
<p>大概是老师批high了没注意到吧，我想，然后加了老师微信，自信满满地去讨回我失去的6分。</p>
<p>事实证明我还是太天真了。</p>
<blockquote>
<p>你期末分数多少啊？</p>
</blockquote>
<blockquote>
<p>哦，那是好学生啊，好学生看不出来？</p>
</blockquote>
<p>哦豁？！</p>
<blockquote>
<p>如果我没写“用《点到直线距离》一节里的知识”你还可以是对的？</p>
</blockquote>
<p>承认了？</p>
<blockquote>
<p>我说了用《点到直线距离》一节里的知识啊？你是不是没看题？</p>
</blockquote>
<p>不老师，我的条件也是基于点到直线距离的思想的，只是有一个额外的条件罢了。</p>
<blockquote>
<p>你这个额外的条件就是牵 强 附 会！</p>
</blockquote>
<p>我的额外条件和你的<span class="math inline">\(\delta\)</span>的功能是一样的啊……都是用于修正反例的特殊状况，何况我的主条件还是基于距离的。</p>
<blockquote>
<p>你这个充要条件根本没办法用！</p>
</blockquote>
<p>这就说不过去了， 我觉得用这个条件虽卖相不佳，但是真论应用起来不会复杂多少。</p>
<blockquote>
<p><span class="math inline">\(\delta\)</span>书里有你看到没有啊？你没有用<span class="math inline">\(\delta\)</span>就说明你的认知也就这个水平。如果你再坚持，你这方面的数学认知就到顶了，不会再有进步了！</p>
</blockquote>
<p>好，没想到<span class="math inline">\(\delta\)</span>是我的疏忽，但是我很好奇就凭寥寥数语和一道试题如何可以评判认知水平的？</p>
<p>先入为主的自信与居高临下的傲慢。</p>
<blockquote>
<p>你是个好学生，数学追求完美的，因此你要学会去仔细品味正确答案……</p>
</blockquote>
<p>又是好学生，我就不理解了你用这个先入为主的标签作甚？反衬？</p>
<p>数学追求完美还用你教？我承认我的答案形式上没有正解优雅，但是这无损其正确性！</p>
<p>我究竟是被高看了还是低看了？</p>
<blockquote>
<p>分我是不会给的。还有问题吗？</p>
</blockquote>
<p>我明白了。参考答案的简洁确实令人惊叹，谢谢老师。</p>
<p>诶，我究竟是讨分的还是去挨骂的？</p>
<p>老师你要是就事论事说我的答案和预设的方向不对我也就算了，毕竟应试考试难免这样。</p>
<p>你还点评起我的认知和能力来了？</p>
<p>你要是教了我两年就算了，还是在你我只说了几句话的情况下？</p>
<p>是不是每一个眼高手低的教师都有这种自认为见得多了的那种倨傲？我还真是见识了！</p>
<p>附加条件就是有问题，啊？</p>
<p>“追求完美”哈？</p>
<p>你倒是仔细数数从初中到高中有哪些判断的附加条件要加上一句<span class="math inline">\(\Delta &gt; 0\)</span>？那个时候不加附加条件算错，现在加了你又不高兴了？或者说没把附加条件并到<span class="math inline">\(d_1d_2\)</span>变成<span class="math inline">\(\delta_1\delta_2\)</span>你就不高兴了？</p>
<p>解析几何里面很多结论<span class="math inline">\(k\)</span>要存在算不算附加条件？算不算不完美？与之相比是不是向量要好得多，倾斜角要好得多，极坐标要好得多？我们是不是要全员追求完美抛弃有缺陷的斜率？</p>
<p>“用到点到直线距离这一节”哈？</p>
<p><span class="math inline">\(\delta\)</span>是这一节的内容，点到直线的距离就不是了吗？</p>
<p>都写了“试写出”了还整唯一标准答案？</p>
<p>我的答案和你的完全等价诶！</p>
<p>证明的思路也和你的大同小异诶！</p>
<p>就这样把所有分扣光？</p>
<p>我的结论好歹是对的，是不是应该和那些结论都是错的做一点区分？</p>
<p>就这样把一个90分以上黜落到90分一下？</p>
<p>很遗憾，虽然我理解了老师的理论（这无疑是一种可悲），但是从老师对我的态度我只能读出一种面对完全不认识的学生，一种不知何起的居高临下的自负与倨傲。</p>
<p>题目和答案都不错，我回去会好好欣赏的。</p>
<p>但这个老师就算了，我很庆幸高中前两年不是他教。</p>
<p>诶，自己真蠢，刚做题的时候天真地想期末大考能出出开放性探究题，讨分的时候天真地想老师或许只是疏忽而已。</p>
<p>到最后自讨没趣，只能在一个网络上无人问津的角落，乱发一通牢骚。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ma-chengyuan.github.io/2020/07/04/PACT0703/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/04/PACT0703/" class="post-title-link" itemprop="url">PACT 07/03 集合覆盖问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-04 06:29:26" itemprop="dateCreated datePublished" datetime="2020-07-04T06:29:26-04:00">2020-07-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="集合覆盖问题">集合覆盖问题</h1>
<h2 id="定义">定义</h2>
<p><strong>输入：</strong>全集<span class="math inline">\(\mathcal{U}\)</span>，以及一些集合的集合<span class="math inline">\(S=\{S_1,S_2,S_3,\cdots,S_n\}\)</span>，满足<span class="math inline">\(\forall i, S_i\subseteq \mathcal{U}\)</span>。</p>
<p><strong>目标：</strong>从<span class="math inline">\(S\)</span>中选择一个最小数目的集合，使得它们能够覆盖<span class="math inline">\(\mathcal{U}\)</span>中所有的元素（即并集为<span class="math inline">\(\mathcal U\)</span>）</p>
<p><img src="/2020/07/04/PACT0703/SC1.svg" class=""></p>
<p>如图，<span class="math inline">\(S_1,S_2,S_4\)</span>就构成一个集合覆盖。</p>
<h2 id="贪心算法及其分析">贪心算法及其分析</h2>
<p>我们的想法很简单：<strong>每次都取含有最多未覆盖元素的集合加入我们的覆盖集</strong>，不断循环直至所有集合都被覆盖。</p>
<p>我们定义<span class="math inline">\(\mathcal U_i\)</span>表示第<span class="math inline">\(i\)</span>次循环开始时未覆盖的元素集合，定义<span class="math inline">\(S_i\)</span>表示第<span class="math inline">\(i\)</span>次循环选择的集合，假设我们选了<span class="math inline">\(k\)</span>个集合。有引理：</p>
<p><strong>引理：</strong> <span class="math display">\[
\left|S_i \cap\mathcal{U}_i \right| \ge \frac{\left|\mathcal{U}_i\right|}{|\mathrm{OPT}|}
\]</span> 这个引理其实反映了一个“优于平均”的思想。</p>
<p><strong>证明：</strong> <span class="math display">\[
\begin{aligned}
    \left|\mathcal{U}_i\right| &amp;= \left|\bigcup_{Z\in\mathrm{OPT}}\left(Z\cap\mathcal{U}_i\right)\right| \\
    &amp;\le \sum_{Z\in\mathrm{OPT}}\left|Z\cap\mathcal{U}_i\right| \\
    &amp;\le \sum_{Z\in\mathrm{OPT}}\left|S_i\cap\mathcal{U}_i \right| \\
    &amp;= |\mathrm{OPT}||S_i\cap\mathcal{U}_i |
\end{aligned}
\]</span> 得证。</p>
<p><strong>定理：</strong>我们的算法是一个<span class="math inline">\(\mathcal{O}\left(\log n\right)\)</span>倍近似算法。</p>
<p><strong>证明：</strong>考虑每次循环开始时未覆盖元素的数量： <span class="math display">\[
\begin{aligned}
    |\mathcal U_1| &amp;= n \\
    |\mathcal U_2| &amp;= |\mathcal U_1| - |S_1\cap\mathcal{U}_1| \\
    &amp;\le |\mathcal U_1|\left(1-\frac{1}{|\mathrm{OPT}|}\right) \\
    |\mathcal U_3| &amp;= |\mathcal U_2| - |S_2\cap\mathcal{U}_2| \\
    &amp;\le |\mathcal U_2|\left(1-\frac{1}{|\mathrm{OPT}|}\right) \\
    &amp;\le |\mathcal U_1|\left(1-\frac{1}{|\mathrm{OPT}|}\right)^2 \\
    &amp;\vdots \\
    |\mathcal U_k| 
    &amp;\le |\mathcal U_1|\left(1-\frac{1}{|\mathrm{OPT}|}\right)^{k-1} \\
    &amp;= n\left(1-\frac{1}{|\mathrm{OPT}|}\right)^{k-1}
\end{aligned}
\]</span></p>
<p>因为<span class="math inline">\(\mathcal{U}_k\neq \emptyset\)</span>，有 <span class="math display">\[
\begin{aligned}
    1\le |\mathcal U_k| &amp;\le n\left(1-\frac{1}{|\mathrm{OPT}|}\right)^{k-1} \\
    1\le n\left(1-\frac{1}{|\mathrm{OPT}|}\right)^k &amp;\le n\left(e^{-\frac{1}{|\mathrm{OPT}|}}\right)^{k-1} \\ 
    e^{-\frac{k-1}{|\mathrm{OPT}|}} &amp;\ge  \frac{1}{n} \\
    -\frac{k-1}{|\mathrm{OPT}|} &amp;\ge -\ln n \\
    k &amp;\le  \ln n\cdot |\mathrm{OPT}|+1 \\
    k &amp;\le \mathcal O\left(\log n\right)|\mathrm{OPT}|
\end{aligned}
\]</span> 证毕。</p>
<h2 id="跑满上界的输入样例">跑满上界的输入样例</h2>
<p>对于这个算法而言我们的分析能不能更好一点呢？这里有一个可以让满足这个上界的例子：</p>
<p><img src="/2020/07/04/PACT0703/SC2.svg" class=""></p>
<p>最优解显然是<span class="math inline">\(2\)</span>个集合，但是我们的贪心算法每一次都可能选到红色的集合，而这样就需要<span class="math inline">\(\mathcal{O}\left(\log n\right)\)</span>个集合完成覆盖了。</p>
<h1 id="带权集合覆盖问题">带权集合覆盖问题</h1>
<p>如果把给每个集合赋予一个权重，而我们需要寻找一个权重和最小的覆盖集呢？这个问题被称作带权集合覆盖。</p>
<h2 id="贪心算法及其分析-1">贪心算法及其分析</h2>
<p>我们依然贪心，这个时候我们每次选择“性价比”最优的集合加入我们的覆盖集，设一个集合的权重为<span class="math inline">\(w(\cdot)\)</span>，那么<strong>我们每一次循环都挑选<span class="math inline">\(\frac{w(\cdot)}{|\cdot|}\)</span>最小的集合</strong>（<span class="math inline">\(|\cdot|\)</span>这里不算已经被覆盖的元素）。</p>
<p>如何分析这个算法？沿用分析不带权覆盖的记号，我们有引理：</p>
<p><strong>引理：</strong> <span class="math display">\[
\frac{w(S_i)}{|S_i\cap \mathcal{U}_i|} \le \frac{w(\mathrm{OPT})}{|\mathcal{U}_i|}
\]</span> <strong>证明：</strong> <span class="math display">\[
\begin{aligned}
    \left|\mathcal{U}_i\right| &amp;= \left|\bigcup_{Z\in\mathrm{OPT}}\left(Z\cap\mathcal{U}_i\right)\right| \\
    &amp;\le \sum_{Z\in\mathrm{OPT}}\left|Z\cap\mathcal{U}_i\right|
\end{aligned}
\]</span> 而由我们算法贪心的本质可知， <span class="math display">\[
\frac{w(S_i)}{|S_i \cap \mathcal{U}_i|} \le \frac{w(Z)}{|Z \cap \mathcal{U}_i|}, \quad \forall Z\in\mathrm{OPT}, Z\cap\mathcal{U}_i\neq\emptyset
\]</span> 也就是 <span class="math display">\[
|Z \cap \mathcal{U}_i| \le \frac{w(Z)}{w(S_i)}|S_i \cap \mathcal{U}_i|,\quad \forall Z\in\mathrm{OPT}, Z\cap\mathcal{U}_i\neq\emptyset
\]</span> 因此 <span class="math display">\[
\begin{aligned}
    \left|\mathcal{U}_i\right| &amp;\le \sum_{Z\in\mathrm{OPT}}\left|Z\cap\mathcal{U}_i\right| \\
    &amp;\le \sum_{Z\in\mathrm{OPT}}\frac{w(Z)}{w(S_i)}|S_i \cap \mathcal{U}_i| \\
    &amp;= \frac{|S_i \cap \mathcal{U}_i|}{w(S_i)}\sum_{Z\in\mathrm{OPT}}w(Z) \\
    &amp;= \frac{|S_i \cap \mathcal{U}_i|}{w(S_i)}w(\mathrm{OPT})
\end{aligned}
\]</span> 随后稍加变形便得引理，证毕。</p>
<p><strong>定理：</strong>我们的算法是一个<span class="math inline">\(\mathcal O\left(\log n\right)\)</span>倍近似算法。</p>
<p><strong>证明：</strong> <span class="math display">\[
\begin{aligned}
    |\mathcal U_1| &amp;= n \\
    |\mathcal U_2| &amp;= |\mathcal U_1| - |S_1\cap\mathcal{U}_1| \\
    &amp;\le |\mathcal U_1|\left(1-\frac{w(S_1)}{w(\mathrm{OPT})}\right) \\
    &amp;\le |\mathcal U_1|\exp\left(-\frac{w(S_1)}{w(\mathrm{OPT})}\right)\\
    |\mathcal U_3| &amp;= |\mathcal U_2| - |S_2\cap\mathcal{U}_2| \\
    &amp;\le |\mathcal U_2|\exp\left(-\frac{w(S_2)}{w(\mathrm{OPT})}\right) \\
    &amp;\le |\mathcal U_1|\exp\left(-\frac{w(S_1)+w(S_2)}{w(\mathrm{OPT})}\right) \\
    &amp;\vdots \\
    |\mathcal U_k| 
    &amp;\le |\mathcal U_1|\exp\left(-\frac{\sum_{i=1}^{k-1}w(S_i)}{w(\mathrm{OPT})}\right) \\
    &amp;= n\exp\left(-\frac{\sum_{i=1}^{k-1}w(S_i)}{w(\mathrm{OPT})}\right)
\end{aligned}
\]</span> 又因<span class="math inline">\(|\mathcal U_k| \ge 1\)</span>： <span class="math display">\[
\begin{aligned}
    n\exp\left(-\frac{\sum_{i=1}^{k-1}w(S_i)}{w(\mathrm{OPT})}\right) &amp;\ge 1 \\
    -\frac{\sum_{i=1}^{k-1}w(S_i)}{w(\mathrm{OPT})} &amp;\ge -\ln n \\
    \sum_{i=1}^{k-1}w(S_i) &amp;\le \ln n\cdot w(\mathrm{OPT})
\end{aligned}
\]</span> 证完了？还没有！我们的覆盖集的总代价是<span class="math inline">\(\sum_{i=1}^k w(S_i)\)</span>，还差一个<span class="math inline">\(S_k\)</span>没有处理呢！</p>
<p>但是注意到之前的结论： <span class="math display">\[
\frac{w(S_i)}{|S_i\cap \mathcal{U}_i|} \le \frac{w(\mathrm{OPT})}{|\mathcal{U}_i|}
\]</span> 而当<span class="math inline">\(i=k\)</span>时因为是最后一轮，自然有<span class="math inline">\(|S_k\cap \mathcal{U}_k| = |\mathcal{U}_k|\)</span>，因此便有 <span class="math display">\[
w(S_k) \le w(\mathrm{OPT})
\]</span> 和之前的式子相加： <span class="math display">\[
\begin{aligned}
    \sum_{i=1}^{k-1}w(S_i) + w(S_k) &amp;\le \ln n\cdot w(\mathrm{OPT}) + w(\mathrm{OPT})\\
    \sum_{i=1}^{k}w(S_i) &amp;\le (\ln n +1)w(\mathrm{OPT})  \\
    \sum_{i=1}^{k}w(S_i) &amp;\le \mathcal O(\log n) w(\mathrm{OPT})
\end{aligned}
\]</span> 证毕。</p>
<p>其实，如果我们不知道如何给<span class="math inline">\(w(S_k)\)</span>定界也没有关系。参考<span class="math inline">\(k\)</span>中心问题时我们使用的技巧，我们<strong>可以枚举尝试<span class="math inline">\(\mathrm{OPT}\)</span>当中权值最大的集合</strong>。</p>
<p>显然如果我们知道<span class="math inline">\(\mathrm{OPT}\)</span>当中权值最大的集合是什么，我们就会把权值大于这个集合的其他集合全部丢掉。这个时候我们算法的<span class="math inline">\(w(S_k)\)</span>自然就不大于<span class="math inline">\(w(\mathrm{OPT})\)</span>了。</p>
<p>但是我们怎么知道我们猜的对不对呢？对不对不重要，重要的是因为我们尝试了每一个集合，我们至少会猜对一次——而对于猜对的那一次，我们的分析全部成立，我们的代价一定是不大于<span class="math inline">\(\mathcal O(\log n) w(\mathrm{OPT})\)</span>的。因此，如果<strong>我们最后取所有尝试的最小值作为我们的解</strong>，我们的最终代价一定也是不大于<span class="math inline">\(\mathcal O(\log n) w(\mathrm{OPT})\)</span>（虽然最终代价未必是猜对的那一次的代价），我们的算法依然有效，而时间复杂度不过是多了一个<span class="math inline">\(n\)</span>而已。</p>
<p>这个技巧是很有意思的：如果可能性是多项式种，那么在只关注是否是多项式时间的近似算法当中，枚举一遍不失为一种好的思路。</p>
<h2 id="另外一种分析方法">另外一种分析方法</h2>
<p>令<span class="math inline">\(e_1,e_2,e_3,\cdots,e_n\)</span>表示第<span class="math inline">\(1,2,3,\cdots,n\)</span>个被覆盖的元素（我们一次选的集合很可能一次性覆盖好几个元素，在这种情况下这些元素的排列可以任意）。我们接下来<strong>把集合的权重分摊到元素上</strong>，对于被集合<span class="math inline">\(S_y\)</span>覆盖的元素<span class="math inline">\(e_i\)</span>，定义其代价为 <span class="math display">\[
\operatorname{price}(e_i) = \frac{w(S_y)}{|S_y \cap \mathcal{U}_y|}
\]</span> 很显然，因为覆盖到<span class="math inline">\(e_i\)</span>的时候<span class="math inline">\(e_i\)</span>后面的元素一定没有覆盖到，因此<span class="math inline">\(|S_y \cap \mathcal{U}_y| \ge n-i+1\)</span>。因此 <span class="math display">\[
\operatorname{price}(e_i) \le \frac{w(S_y)}{n-i+1}
\]</span> 又由之前的引理以及<span class="math inline">\(|S_y \cap \mathcal U_y| \le |\mathcal U_y|\)</span>，可得<span class="math inline">\(w(S_y) \le w(\mathrm{OPT})\)</span>，因此 <span class="math display">\[
\operatorname{price}(e_i) \le \frac{w(\mathrm{OPT})}{n-i+1}
\]</span> 而我们的覆盖集的总代价为 <span class="math display">\[
\begin{aligned}
    \sum_{i=1}^n w(S_i) &amp;= \sum_{i=1}^n \operatorname{price}(e_i) \\
        &amp;\le  \sum_{i=1}^n \frac{w(\mathrm{OPT})}{n-i+1} \\
        &amp;= w(\mathrm{OPT})\sum_{i=1}^n \frac{1}{n-i+1} \\
        &amp;= w(\mathrm{OPT})\sum_{i=1}^n  \frac{1}{i} \\
        &amp;= w(\mathrm{OPT}) H_n \\
        &amp;=  O(\log n) w(\mathrm{OPT})
\end{aligned}
\]</span></p>
<h2 id="跑满上界的输入样例-1">跑满上界的输入样例</h2>
<p>有一个大集合，包含所有元素，权值为<span class="math inline">\(1+\varepsilon\)</span>。</p>
<p>还有<span class="math inline">\(n\)</span>个只包含一个元素的小集合，权值为<span class="math inline">\(\frac{1}{n}, \frac{1}{n-1}, \frac{1}{n-2},\cdots\)</span>。</p>
<p>对于这个输入，我们的贪心算法会把所有小集合选掉，总权重为<span class="math inline">\(H_n = \mathcal{O}(\log n )\)</span>。而最优解为那个大集合，总权重为<span class="math inline">\(1+\varepsilon\)</span>，二者差<span class="math inline">\(\mathcal{O}(\log n )\)</span>倍，和我们的分析一致，这也说明如果算法不变，我们没办法单纯通过分析得出更好的结果了。</p>
<p>其实集合覆盖问题可以证明hardness就是<span class="math inline">\(\mathcal{O}(\log n )\)</span>的，只是这个证明不简单，上课的时候只是顺带提了一下。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ma-chengyuan.github.io/2020/07/04/PACT0702/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/04/PACT0702/" class="post-title-link" itemprop="url">PACT 07/02 TSP问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-04 03:30:38" itemprop="dateCreated datePublished" datetime="2020-07-04T03:30:38-04:00">2020-07-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="定义">定义</h1>
<p><strong>输入：</strong>完全图<span class="math inline">\(G=(V,E)\)</span>，边带正权，满足三角不等式。</p>
<p><strong>目标：</strong>构造一个周游所有顶点的最小权回路。</p>
<h1 id="下界估计">下界估计</h1>
<p><span class="math inline">\(\mathrm{OPT}\)</span>的下界是什么？</p>
<blockquote>
<p>Hasit: <span class="math inline">\(\mathrm{OPT} \ge n\cdot\min_{e \in E}\{w_e\}\)</span></p>
</blockquote>
<p>这确实是一个下界，但是太松了一点？</p>
<blockquote>
<p>Andrew T: <span class="math inline">\(\mathrm{OPT} \ge\)</span>边权最小的<span class="math inline">\(n\)</span>条边</p>
</blockquote>
<p>好一点了，但是还不够！</p>
<blockquote>
<p>我: <span class="math inline">\(\mathrm{OPT}\ge\)</span>每个顶点相邻的最小边权</p>
</blockquote>
<p>似乎还不够？</p>
<blockquote>
<p>Mona: <span class="math inline">\(\mathrm{OPT}\ge\)</span><strong>最小生成树边权和</strong></p>
</blockquote>
<p>没错！证明这个并不难，回路首先是一个连通子图，而连通子图中边数最小的当属生成树，而生成树边权和最小的是最小生成树，因此最小生成树的边权和是一张图中所有连通子图边权和的下界。</p>
<h1 id="基础近似算法以及分析">基础近似算法以及分析</h1>
<p>这启发我们先去构造<span class="math inline">\(G\)</span>的最小生成树：</p>
<p><img src="/2020/07/04/PACT0702/TSP1.svg" class=""></p>
<p>如何在其基础上构造回路呢？</p>
<p>我们不妨给每一条边复制一份：</p>
<p><img src="/2020/07/04/PACT0702/TSP2.svg" class=""></p>
<p>让后我们走一次DFS，下来的时候走黑边，上去的时候走绿边，整个回路的边权就是最小生成树边权的两倍。</p>
<p>但是这样的话很多点我们重复走了，因此实际走的时候如果接下来的几个点已经走过了我们就直接跳过，如图，数字表示访问顺序：</p>
<p><img src="/2020/07/04/PACT0702/TSP3.svg" class=""></p>
<p>（不难发现，节点的访问顺序就是DFS序）</p>
<p>由于三角不等式的存在，这个回路的边权一定小于最小生成树边权的两倍。</p>
<p>由于<span class="math inline">\(\mathrm{OPT}\ge\)</span>最小生成树边权，因此这个算法至少是一个<span class="math inline">\(2\)</span>倍近似算法。</p>
<h1 id="christofides算法">Christofides算法</h1>
<p>我们为什么要把最小生成树上的每一条边复制一下？我们的目的其实是<strong>让最小生成树变为一张欧拉图</strong>。有了欧拉图之后就可以求出欧拉回路，有了欧拉回路之后就可以通过跳过重复点抄近道（shortcutting）的方式得到哈密尔顿回路，也就是我们近似算法的解。</p>
<p>由此可见，一开始的欧拉图很重要。最小生成树之所以不是欧拉图，是因为里面可能会有奇度数的点，那么只要<strong>把奇度数的点变成偶度数不就行了嘛！</strong>我们之前把每条边都复制一下那无论度数奇偶都变成偶度数了，未免太粗暴了一点。</p>
<p>如何把奇度数变成偶度数呢？首先很显然奇度数的点只有偶数个（度数之和必须是偶数），因此我们想到可以把这些奇度数的点两两配对——或者用更专业的术语来讲，<strong>在这些奇度数点的导出子图上计算一个最小权完美匹配</strong>。我们知道一个偶数点图的最小权完美匹配是可以通过带花树算法（Blossom algorithm）在多项式时间内求出的，所以这个思路没有问题。</p>
<p><img src="/2020/07/04/PACT0702/TSP4.svg" class=""></p>
<p>现在我们有了一张欧拉图，只要求出欧拉回路然后在上面抄近道我们就得到了一条周游路线了。</p>
<p>这个算法被称为Christofides算法。</p>
<h1 id="christofides算法分析">Christofides算法分析</h1>
<p>如何分析这个最小权匹配的代价呢？</p>
<p>我们不妨考虑最优周游路线，以及在这条路线上的最小生成树的奇度数点：</p>
<p><img src="/2020/07/04/PACT0702/TSP6.svg" class=""></p>
<p>如果定义连接奇度数点的橘色环的代价是<span class="math inline">\(C\)</span>，显然由三角不等式有<span class="math inline">\(C\le \mathrm{OPT}\)</span>，而如果我们把这个环拆开，便会得到两个完美匹配：</p>
<p><img src="/2020/07/04/PACT0702/TSP5.svg" class=""></p>
<p>假设两个完美匹配的代价为<span class="math inline">\(C_1,C_2\)</span>，我们最小权匹配的代价为<span class="math inline">\(C^{\ast}\)</span>，显然有 <span class="math display">\[
C=C_1+C_2\ge C^{\ast} + C^{\ast} = 2C^{\ast}
\]</span> 因此可得 <span class="math display">\[
C^{\ast} \le \frac{1}{2}\mathrm{OPT}
\]</span> 同时我们知道最小生成树的代价<span class="math inline">\(\le \mathrm{OPT}\)</span>，因此整张欧拉图的代价<span class="math inline">\(\le \frac{3}{2}\mathrm{OPT}\)</span>，而抄近路得到的最终回路的代价只会更小，因此这是一个<span class="math inline">\(\frac{3}{2}\)</span>倍近似算法。</p>
<h1 id="令人绝望的一般tsp问题">令人绝望的一般TSP问题</h1>
<p><strong>引理：</strong>对于没有三角不等式的一般TSP问题，除非<span class="math inline">\(\mathsf{P}=\mathsf{NP}\)</span>，不存在任何<span class="math inline">\(2\)</span>倍近似算法以及更优的近似。</p>
<p><strong>证明：</strong>我们使用gap reduction来证明这一点。考虑哈密尔顿回路问题到TSP的规约。</p>
<p><strong>哈密尔顿回路问题：</strong>给定图<span class="math inline">\(G=(V,E)\)</span>，问是否存在哈密尔顿回路？</p>
<p><strong>一般TSP问题：</strong>给定边带权完全图<span class="math inline">\(G&#39;=(V&#39;,E&#39;)\)</span>，计算最小权回路。</p>
<p>如何规约？对于<span class="math inline">\(G\)</span>中有的边，令其在<span class="math inline">\(G&#39;\)</span>中的权值为<span class="math inline">\(1\)</span>；对于<span class="math inline">\(G\)</span>中没有的边，令其在<span class="math inline">\(G&#39;\)</span>中的权值为<span class="math inline">\(n+2\)</span>。</p>
<p>如此一来，如果<span class="math inline">\(G\)</span>存在哈密尔顿回路，则TSP解的代价为<span class="math inline">\(n\)</span>，反之则TSP的回路必定会至少用到一条<span class="math inline">\(G\)</span>中不存在的边，因此代价至少为<span class="math inline">\((n-1) + (n+2) = 2n+1\)</span>。</p>
<p>假设有一个TSP的<span class="math inline">\(2\)</span>倍近似算法，那么如果<span class="math inline">\(G\)</span>存在哈密尔顿回路这个算法只能输出<span class="math inline">\(n\)</span>，因为<span class="math inline">\(n\)</span>到<span class="math inline">\(2n+1\)</span>中间有很大的gap，而如果<span class="math inline">\(G\)</span>不存在哈密尔顿回路，算法就会输出至少是<span class="math inline">\(2n+1\)</span>的代价——因此，我们可以使用这个算法在多项式时间内解决NPC的哈密尔顿回路问题！而如果<span class="math inline">\(\mathsf{P} \neq \mathsf{NP}\)</span>，这是不可能的，因此不存在这样的算法。</p>
<p>绝望吧？</p>
<p>更绝望的事情是因为没有三角不等式我们的边权可以设得任意大，不止是<span class="math inline">\(n+2\)</span>，还可以是<span class="math inline">\(3n+2\)</span>，<span class="math inline">\(kn+2\)</span>……我们可以用以上的论证在假定<span class="math inline">\(\mathsf{P} \neq \mathsf{NP}\)</span>的前提下否决任意近似比的近似算法——也就是这个问题根本无从近似。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ma-chengyuan.github.io/2020/07/04/PACT0701/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/04/PACT0701/" class="post-title-link" itemprop="url">PACT 07/01 任务调度问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-04 03:23:26" itemprop="dateCreated datePublished" datetime="2020-07-04T03:23:26-04:00">2020-07-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="定义">定义</h1>
<p><strong>输入：</strong><span class="math inline">\(n\)</span>个任务，第<span class="math inline">\(i\)</span>个任务的运行时间为<span class="math inline">\(p_i\)</span>，共有<span class="math inline">\(m\)</span>个相同的机器（一个任务在每台机器上运行时间都相同）。每台机器同一时间只能运行一个任务，每个任务只能在一台机器上运行（不能拆分）。</p>
<p><strong>目标：</strong>合理地调度任务，使得完成所有任务的时间（makespan）最短。</p>
<h1 id="下界估计">下界估计</h1>
<p>自然而然地，我们首先思考<span class="math inline">\(\mathrm{OPT}\)</span>的下界。一个比较容易想到的下界是耗时最长的任务所需要的时间： <span class="math display">\[
\mathrm{OPT} \ge \max_{i} \{p_i\}
\]</span> 除此以外，考虑如果可以拆分任务，最短的运行时间是多少？自然是<span class="math inline">\(\frac{\sum_i p_i}{m}\)</span>，而这在现实中常常是做不到的，因此有： <span class="math display">\[
\mathrm{OPT} \ge \frac{\sum_i p_i}{m}
\]</span> 这两个下界对于之后的算法分析非常有用。</p>
<h1 id="算法">算法</h1>
<ol type="1">
<li>将所有的任务随机排成一列。</li>
<li>当一台机器完成了一个任务变得闲置了，马上把列表上的下一项任务安排到这个机器上去执行。</li>
<li>重复步骤2直至所有任务都被执行完毕。</li>
</ol>
<p>这个算法是非常简单且自然的。</p>
<h1 id="分析">分析</h1>
<p>我们算法给出结果的什么？自然是最后一个结束的任务的结束时间。如果我们设最后一个结束的任务为任务<span class="math inline">\(l\)</span>，且这个任务开始于<span class="math inline">\(s_l\)</span>，那么就有： <span class="math display">\[
\mathrm{Cost} = s_l+p_l
\]</span> 接下来我们进行放缩。</p>
<p>考虑<span class="math inline">\(s_l\)</span>的上界是什么？</p>
<p><img src="/2020/07/04/PACT0701/SIPM1.svg" class=""></p>
<p>很显然，<strong>在<span class="math inline">\(s_l\)</span>时刻，除了<span class="math inline">\(l\)</span>即将运行的那台机器，其他机器上必须有任务在运行或者刚刚空下来</strong>（如果有机器已经空了一阵子了，那当时<span class="math inline">\(l\)</span>就会被安排到那台机器上去跑），因此不难得出<span class="math inline">\(ms_l \le \sum_{i\neq l} p_i\)</span>，即 <span class="math display">\[
s_l \le \frac{\sum_{i \neq l}p_i}{m}
\]</span> 因此 <span class="math display">\[
\begin{aligned}
\mathrm{Cost} &amp;= s_l+p_l \\
&amp; \le \frac{\sum_{i \neq l}p_i}{m} + p_l \\
&amp;= \frac{\sum_{i}p_i}{m} + \left(1 - \frac{1}{m}\right) p_l \\
&amp;\le \frac{\sum_{i}p_i}{m} + \left(1 - \frac{1}{m}\right)\max_{i}\{p_i\} \\
&amp;\le \mathrm{OPT} + \left(1 - \frac{1}{m}\right)\mathrm{OPT} \\
&amp;= \left(2 - \frac{1}{m}\right)\mathrm{OPT}
\end{aligned}
\]</span> 我们就证明了我们的算法是一个<span class="math inline">\(2\)</span>倍近似算法！</p>
<h1 id="提升近似比">提升近似比</h1>
<p>能不能在这个算法的基础上提升呢？我们注意到将<span class="math inline">\(\mathrm{OPT}\)</span>作为<span class="math inline">\(p_l\)</span>的上界其实还是太松了。如果我们能够缩短<span class="math inline">\(p_l\)</span>，那上界的估计有没有改善的空间呢？</p>
<p>于是我们在原来算法的基础上不妨进行一个改进：与其在一开始将所有任务随机排列，不如<strong>将其按照运行时间从大到小的顺序进行排序</strong>。这也很符合直觉，一开始就把需要时间很长的任务跑完，之后肯定有些机器空着有些机器还在忙，这个时候就可以用完成时间比较短的小任务来灵活地填补这些空缺了。</p>
<p>这一下让近似比提升了多少呢？</p>
<p><strong>引理：</strong>加上排序之后的算法具有<span class="math inline">\(\frac{3}{2}\)</span>的近似比。</p>
<p><strong>证明：</strong>我们不妨分类讨论，</p>
<p><strong>情形1. </strong><span class="math inline">\(p_l \le \frac{1}{2}\mathrm{OPT}\)</span>，这个时候按照我们上文分析的路子走直接就可以得到<span class="math inline">\(\mathrm{Cost} \le \frac{3}{2}\mathrm{OPT}\)</span>，就做完了。</p>
<p><strong>情形2. </strong><span class="math inline">\(p_l &gt; \frac{1}{2}\mathrm{OPT}\)</span>，此时所有<span class="math inline">\(l\)</span>之前的任务也肯定具有大于<span class="math inline">\(\frac{1}{2} \mathrm{OPT}\)</span>的运行时间。注意到<strong>我们不需要考虑<span class="math inline">\(p_l\)</span>之后的任务</strong>，因为依据定义<span class="math inline">\(l\)</span>是最后结束的，后面的任务对于我们的结果没有影响。那<span class="math inline">\(l\)</span>之前的任务在最优调度里面是怎么样的呢？反证法可以很快说明：<strong>在最优调度里面，每一台机器至多只能处理一件任务</strong>（忽略<span class="math inline">\(l\)</span>之后的任务）！也就是说事实上<span class="math inline">\(l\)</span>以及之前的任务数目加起来不会超过机器数<span class="math inline">\(m\)</span>，那再想一想在这种机器充足的情况下，我们的算法在分配这些任务的时候也是一个机器一个任务，<span class="math inline">\(p_l\)</span>必定是从一开始就执行的，因此<span class="math inline">\(\mathrm{Cost}=p_l\)</span>，而显然<span class="math inline">\(\mathrm{OPT} \ge p_l\)</span>，因此必有<span class="math inline">\(\mathrm{Cost} = \mathrm{OPT}\)</span>，结束。（事实上，由于<span class="math inline">\(l\)</span>还是最后结束的任务，不难想通在一机器一任务的情形下，<span class="math inline">\(l\)</span>之前的所有任务都一定和<span class="math inline">\(l\)</span>花费相同的时间，或<span class="math inline">\(l\)</span>就是我们算法分配的第一个任务。）</p>
<p>综上所述，近似比是<span class="math inline">\(\frac{3}{2}\)</span>。</p>
<h1 id="进一步提升近似比">进一步提升近似比</h1>
<p>通过对于上述论证的些许修改，我们其实可以证明：</p>
<p><strong>引理：</strong>加上排序之后的算法具有<span class="math inline">\(\frac{4}{3}\)</span>的近似比。</p>
<p><strong>证明：</strong>我们故技重施：</p>
<p><strong>情形1. </strong><span class="math inline">\(p_l \le \frac{1}{3}\mathrm{OPT}\)</span>，这个时候我们直接就可以得到<span class="math inline">\(\mathrm{Cost} \le \frac{4}{3}\mathrm{OPT}\)</span>。</p>
<p><strong>情形2. </strong><span class="math inline">\(p_l &gt; \frac{1}{3}\mathrm{OPT}\)</span>，此时所有<span class="math inline">\(l\)</span>之前的任务也肯定具有大于<span class="math inline">\(\frac{1}{3} \mathrm{OPT}\)</span>的运行时间。我们同样不考虑<span class="math inline">\(l\)</span>之后的任务。可以通过反证证明：<strong>在最优调度里，每一台机器至多只能处理两件任务！</strong>因此，我们确定有足够的机器让我们的算法得以这样调度任务：</p>
<p><img src="/2020/07/04/PACT0701/SIPM2.svg" class=""></p>
<p>（看着是不是很像双指针？）</p>
<p>具体来说，如果我们把机器按照第一个任务的耗时降序排序，那么它们第二个任务的耗时一定成升序排列。（这并不难证明：第一个任务耗时最短的机器一定能够先领到列表中最长的任务作为第二个任务，之后的机器领到的任务时间递减）</p>
<p>（在这里我们假定<span class="math inline">\(l\)</span>一定是第二个任务，如果<span class="math inline">\(l\)</span>从头开始运行而且时间特别长的话，参考上一节的证明）</p>
<p>而接下来我们证明这样的分配方式是最优的。</p>
<p>我们采取反证的方法：不妨假设在最优方案中存在两个机器，两个机器上都有两个任务，耗时分别为<span class="math inline">\((a,b)\)</span>和<span class="math inline">\((c,d)\)</span>，且<span class="math inline">\(a&gt;c,b&gt;d\)</span>。那么我们把两个机器上的第二个任务互换，变成<span class="math inline">\((a,d)\)</span>和<span class="math inline">\((c,b)\)</span>，不难发现此时完成任务的最短时间会减少，和“最优”矛盾。因此，对于最优方案的任意两台机器<span class="math inline">\((a,b)\)</span>和<span class="math inline">\((c,d)\)</span>，如果<span class="math inline">\(a&gt;c\)</span>那么<span class="math inline">\(b&lt;d\)</span>：</p>
<p><img src="/2020/07/04/PACT0701/SIPM3.svg" class=""></p>
<p>这正是我们算法所给出的调度方案。因此<span class="math inline">\(\mathrm{OPT}\)</span>不会比我们算法的结果更好了。</p>
<p>综上所述，近似比为<span class="math inline">\(\frac{4}{3}\)</span>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ma-chengyuan.github.io/2020/06/27/%E7%BB%84%E5%90%88%E6%B1%82%E5%92%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/27/%E7%BB%84%E5%90%88%E6%B1%82%E5%92%8C/" class="post-title-link" itemprop="url">论省选中有意思的一道组合题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-27 08:01:12" itemprop="dateCreated datePublished" datetime="2020-06-27T08:01:12-04:00">2020-06-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>省选结束了，本人作为划水3年的OIer宣告原地退役，唯一写出正解的是D1T2。我其实觉得这道题挺有意思的（虽然大佬们都说只是推式子而已……嘛，毕竟本来没期待自己能做出来），就写篇文章记一下自己的想法吧。</p>
<h1 id="题意">题意</h1>
<p>给定整数<span class="math inline">\(n, x, P\le 10^9\)</span>，以及一个<span class="math inline">\(m \le 1000\)</span>次整系数多项式<span class="math inline">\(f\)</span>，求 <span class="math display">\[
\left[\sum_{k=0}^nf(k)x^k\binom{n}{k}\right]\bmod P
\]</span></p>
<h1 id="心路历程">心路历程</h1>
<h2 id="先乱搞一波">先乱搞一波</h2>
<p>看到这个题目的第一眼我觉得颇为眼熟。虽然没学过奥数，印象当中《具体数学》里面花了很大笔墨讲由这种指数，多项式以及二项式系数组合而成的和式的处理方法，似乎最后也讲到了机械求和法，然并卵，印象止步于印象，机械求合法太复杂了自己并没有记下来。</p>
<p>但是自己的残存记忆告诉我机械求和法的第一步是把求和式化成超几何函数，虽然后者我更没办法但是本着有逼就要装的思想……为什么不试一试呢？</p>
<p>什么样的级数是超几何的？《具体数学》里面给出的方法是求相邻项之比<del>幸好这个我还没有忘记</del>，而显而易见地是多项式求比是求不出具有良好形式的结果的，因此<strong>多项式必须转化为性质更优良的下降阶乘幂处理</strong>（关于下降阶乘幂我记得两年之前就写过一篇成套方法和有限微积分的博文，现在想来下降阶乘幂在离散求和问题当中真的有非常良好的性质，我在这里就沿用《具体数学》里的记号了：<span class="math inline">\(k^{\underline m} = \prod_{i=0}^m (k-i)\)</span>）： <span class="math display">\[
\begin{aligned}
\frac{(k+1)^{\underline{m}}x^{k+1}\binom{n}{k+1}}{k^{\underline{m}}x^k\binom{n}{k}} &amp;= \frac{(k+1)x(n-k)}{(k-m+1)(k+1)} \\
&amp;= \frac{(n-k)x}{k-m+1}
\end{aligned}
\]</span> 不出所料，结果是一个有理函数，也就是说可以化成高斯超几何函数呢！</p>
<p>不出所料，半瓶水的某人也就知道这些了（悲）。</p>
<p>但是<strong>下降阶乘幂的思想是可以有的嘛</strong>！</p>
<h2 id="部分分摸鱼">部分分摸鱼</h2>
<p>在乱搞如预想的那般失败之后我就开始看部分分。</p>
<p>部分分里面有一个<span class="math inline">\(f\)</span>是常数的，愣了一会发现能用二项式定理，答案是<span class="math inline">\((1+x)^n\)</span>。</p>
<p>然后还有一个<span class="math inline">\(x=1\)</span>的。这个要怎么解决？</p>
<p>从最简单的一次多项式开始： <span class="math display">\[
\sum_{k=0}^nk\binom{n}{k}=?
\]</span> 推式子本人是不会的，结论也忘了，但是从组合意义上还是好想的：<strong><span class="math inline">\(k\binom{n}{k}\)</span>就是从<span class="math inline">\(n\)</span>个人里面选<span class="math inline">\(k\)</span>个人，然后钦定一个做队长的方案数，把它求和，就是从<span class="math inline">\(n\)</span>个人里面选若干人，然后从当中钦定一个队长的方案数。</strong>这是先选人再定队长的顺序，我们可以先选队长再选人嘛！从<span class="math inline">\(n\)</span>个人里面选一个队长有<span class="math inline">\(n\)</span>种方法，剩下的<span class="math inline">\((n-1)\)</span>个人要不要都行，所以是<span class="math inline">\(2^{n-1}\)</span>种，二者相乘： <span class="math display">\[
\sum_{k=0}^nk\binom{n}{k}=n2^{n-1}
\]</span> 就把一次的式子推出来了。</p>
<p>那二次的式子呢？ <span class="math display">\[
\sum_{k=0}^nk^2\binom{n}{k}=?
\]</span> 如果沿用之前运用组合意义化简的思路，那<span class="math inline">\(k^2\)</span>就有“可以重复选”的含义在，是不好处理的。但是之前的乱搞告诉我们，是不是化成下降阶乘幂会好处理一点呢？ <span class="math display">\[
\sum_{k=0}^nk(k-1)\binom{n}{k}=?
\]</span> 答案是肯定的，思路和一次的完全一样，只是从“选队长”变成了“选队长和副队长“，因此很快就可以得出： <span class="math display">\[
\sum_{k=0}^nk(k-1)\binom{n}{k}=n(n-1)2^{n-2}
\]</span> 然后就可以很快地推广出去了： <span class="math display">\[
\sum_{k=0}^nk^{\underline{m}}\binom{n}{k}=n^{\underline{m}}2^{n-m}
\]</span> 这样几个部分分就基本拿到了。</p>
<h2 id="把两者组合起来">把两者组合起来</h2>
<p>那如果<span class="math inline">\(x\neq 1\)</span>且<span class="math inline">\(f\)</span>非常数要怎么做呢？我们不妨还是把<span class="math inline">\(f\)</span>想成下降阶乘幂（怎么拆另说）： <span class="math display">\[
\sum_{k=0}^nk^{\underline{m}}x^k\binom{n}{k}=?
\]</span> 然后思考其组合意义，稍开脑洞即可得到：</p>
<p><strong><span class="math inline">\(k^{\underline{m}}x^k\binom{n}{k}\)</span>是从<span class="math inline">\(n\)</span>个人里面挑选<span class="math inline">\(k\)</span>个人，再给让当中<span class="math inline">\(m\)</span>人担任<span class="math inline">\(m\)</span>个不同职位，最后再让每个人从<span class="math inline">\(x\)</span>种颜色的帽子当中选一个戴上的方案数</strong>（不要问我怎么想到戴帽子的）。</p>
<p>因此，由加法原理，对其求和之后就是从<span class="math inline">\(n\)</span>个人里面挑选<em>若干</em>个人，再给让当中<span class="math inline">\(m\)</span>人担任<span class="math inline">\(m\)</span>个不同职位，最后再让每个人从<span class="math inline">\(x\)</span>种颜色的帽子当中选一个戴上的方案数。</p>
<p>那我们故技重施，调换顺序，不妨先从<span class="math inline">\(n\)</span>个人当中调出担任<span class="math inline">\(m\)</span>个职位的那<span class="math inline">\(m\)</span>个人（<span class="math inline">\(n^{\underline{m}}\)</span>种取法），再先让他们先选帽子（<span class="math inline">\(x^m\)</span>种选法），然后让剩下的<span class="math inline">\((n-m)\)</span>个人要不挑一个颜色的帽子进队要么滚蛋（<span class="math inline">\((1+x)^{n-m}\)</span>种取法）。于是就有了： <span class="math display">\[
\sum_{k=0}^nk^{\underline{m}}x^k\binom{n}{k}=n^{\underline{m}}x^m(1+x)^{n-m}
\]</span> 哇，式子就推出来了！</p>
<h2 id="多项式拆分">多项式拆分</h2>
<p>现在基于下降阶乘幂的式子已经推出来了，唯一剩下的就是把给定的<span class="math inline">\(f\)</span>拆成若干个下降阶乘幂的线性组合。 <span class="math display">\[
\sum_{i=0}^ma_ik^i = \sum_{j=0}^m b_jk^{\underline{j}}
\]</span> 即求<span class="math inline">\(b_j\)</span>的过程。</p>
<p>显而易见地，我们需要从高次到低次拆，这样后拆出来的幂才不会对之前的结果造成影响。</p>
<p>同时显然的是，我们需要知道下降阶乘幂展开后对应多项式的系数。</p>
<p>现在回过来看，朴素的多项式乘法是完全可以胜任的。但是写多项式乘法毕竟比较繁琐，不如观察多项式系数的规律。</p>
<p>令<span class="math inline">\(c[m, n]\)</span>表示下降阶乘幂<span class="math inline">\(x^{\underline m}\)</span>的展开式当中<span class="math inline">\(x^n\)</span>的系数。则由下降阶乘幂的定义： <span class="math display">\[
x^{\underline m} = x^{\underline{m-1}}[x-(m-1)],\quad (m\ge 1)
\]</span> 可以得出递推式： <span class="math display">\[
c[m,n]=c[m-1,n-1]-(m-1)c[m-1,n]
\]</span> 边界条件是<span class="math inline">\(c[0,0] = 1\)</span>以及<span class="math inline">\(c[m,0]=0\quad \forall m&gt;0\)</span>。这是一个类似杨辉三角的递推式，自然可以在<span class="math inline">\(\mathcal{O}\left(m^2\right)\)</span>的时间内算出来，代码也好写。</p>
<p>至此，这道题目就完全解决了。</p>
<p>其实不止如此，这个三角在考场上让我感到非常眼熟，回去查证了一下，果然<span class="math inline">\(c[m,n]\)</span>就是所谓的<strong>带符号的第一类斯特林数</strong>，“下降阶乘幂的展开系数”正是其重要的性质之一。</p>
<h2 id="感想">感想</h2>
<p>这道题对我的感触是比较深刻的，尤其是做出来之后，颇有一种成就感。</p>
<p>细想来，我组合数学的公式其实几乎都没有背过，故而几乎所有的式子都是现场推出来的。而且推理的方式也不纯代数的暴算，而是通过combinatorial proof的方式。自从PACT学来这招之后我觉得这种方法实在是精妙。在最后自己还稀里糊涂地推演出了斯特林数的递推公式，或许这种高大上的组合数本身离我们就不遥远吧。</p>
<p>而话又说回来，大佬们看我写的这篇文章，只怕有些不耐烦与乏味吧。那些认真学习过组合数学的选手，大概看到这道题只剩下满满的套路，毕竟斯特林数名声在外，falling factorial这个套路熟悉了也不难想到，而类似的组合式子大概课后的习题会有很多吧。看到诸多大佬将D1T2云淡风轻地说成“裸的推式子”，他们做这道题时的从容大概可见一斑。只有像自己这样偶尔翻翻《组合数学》和《具体数学》，半瓶水晃荡的，才会在考场上各种心情复杂，一惊一乍了。</p>
<p>然而换一个角度，我觉得这道题对我来说真的不错，自己之前偶尔翻翻书也是。作为一道数学题，这道题并没有远远超出我的见识让我一筹莫展，也没有远远低于我的见识让我秒杀，恰是我稍微努力一下就能解决的。而这次考试正是给了日渐颓废，游手好闲的我一个“努力一下”的契机。就结果来看，解决这道题不仅给了我市选的信心，也给了我组合数学的信心，还让我在结题过程中观赏到了极佳的风景，似乎确实不赖。尤其是后者，若放在平时做题，随时可以查找资料，正确答案触手可及，那结论得出时大概也不会有考场上那么惊喜，那么愉悦了。</p>
<h2 id="逆-转">逆 转</h2>
<p>啊？出分了？！</p>
<p>我考个250都能压线进队？！</p>
<p>我可是根本就没认真复习啊，半年没碰OI了……</p>
<p>唉，看来这次强行退役失败了，心情复杂……</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ma-chengyuan.github.io/2020/04/17/IceBoat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/17/IceBoat/" class="post-title-link" itemprop="url">从技术角度看Minecraft的高级冰船技术</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-17 10:43:44" itemprop="dateCreated datePublished" datetime="2020-04-17T10:43:44-04:00">2020-04-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景">背景</h1>
<p>最近比较无聊，偶尔会和同学们一起在Minecraft的私服上玩一会，现在地狱交通已经初见雏形了，nether hub已经搭好了，然而地狱交通网络应该基于哪一种运输方式还没有确定。常见的快速运输方式有两种：piston bolt和冰船。</p>
<p>很显然按照每天半个小时的游戏时间是不可能有精力做双向的piston bolt的，况且论最高速度冰船比piston bolt还是快上许多的，因此几乎毫无疑议地大家都选择了冰船。</p>
<p>这篇文章是在代码角度对于高级冰船技术的分析。</p>
<p>全文的代码均为使用官方mapping以及CFR编译器进行反编译所得（但愿这并不违反EULA）。</p>
<h1 id="带方向校准的高端冰船">带方向校准的高端冰船</h1>
<p>冰船系统一直为人所诟病，也是其不如piston bolt的一点是：它在运动中是需要玩家控制的。不仅要一直按着W，还要使用AD确保船头一直向前。这在直道冰船上还好，但在斜线冰船道上就非常非常麻烦。</p>
<p>幸好，Rays Works在几个月前分享了<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=hiQTnwqrfEU">解决方案</a>。其方案的思想是：</p>
<p>如果一开始船就放正，那么就只需要W而不需要左右调整了！</p>
<p>那怎么把船放正呢？</p>
<p>观察一下代码（<code>net/minecraft/world/item/BoatItem</code>）：</p>
<pre class="line-numbers"><code class="language-java">@Override
public InteractionResultHolder&lt;ItemStack&gt;use(Level level, Player player, InteractionHand interactionHand) &#123;
    Object object;
    ItemStack itemStack = player.getItemInHand(interactionHand);
    HitResult hitResult = BoatItem.getPlayerPOVHitResult(level, player, ClipContext.Fluid.ANY);
    ...
    if (hitResult.getType() == HitResult.Type.BLOCK) &#123;
        object = new Boat(level, hitResult.getLocation().x, hitResult.getLocation().y, hitResult.getLocation().z);
        ((Boat) object).setType(this.type);
        ((Boat) object).yRot = player.yRot; // !
        ...
        return InteractionResultHolder.success(itemStack);
    &#125;
    return InteractionResultHolder.pass(itemStack);
&#125;</code></pre>
<p><code>yRot</code>自然是Y-axis Rotation的意思，也就是说放下船的方向直接等于当时玩家的视角方向。</p>
<p>因此如果一开始视角方向， 那么问题就解决了！</p>
<p>如何确保每一次放船的时候视角方向都是一个固定值呢？</p>
<p>Rays Works的解决方案是：用另外一艘船！</p>
<p>在<code>net/minecraft/client/player/LocalPlayer</code>当中：</p>
<pre class="line-numbers"><code class="language-java">@Override
public boolean startRiding(Entity entity, boolean bl) &#123;
    if (!super.startRiding(entity, bl)) &#123;
        return false;
    &#125;
    ...
    if (entity instanceof Boat) &#123; // !!!
        this.yRotO = entity.yRot;
        this.yRot = entity.yRot;
        this.setYHeadRot(entity.yRot);
    &#125;
    return true;
&#125;</code></pre>
<p>可以看到，当玩家乘上船的一瞬间，玩家的视角方向会强制调整到船的方向。</p>
<p>因此我们只需要准备一艘校准船，确保这艘船的角度正确，之后要使用的时候直接先做上这艘船再立刻放船再坐上新放的船就可以了（简单来说就是三连右键）。</p>
<p>这就是Rays Works视频的主旨，我这里只是找到了对应的源代码而已。</p>
<h1 id="放置角度与minecraft的角度系统">放置角度与Minecraft的角度系统</h1>
<p>Rays Works在视频当中宣称通过它的方法可以把冰道修到任何角度与朝向。</p>
<p>似乎没有什么不对？只要把校准船放到任意角度就行了。</p>
<p>然而在Ray的视频当中可以看到，有的时候明明船放下去是45°，不一会就转到了46.4°，Ray坦言这是这套冰船系统唯一比较麻烦的地方。Ray提出的解决方案是：</p>
<blockquote>
<p>If that happens, just remove this boat and place in a new one. ……and do it a couple times it actually fixes itself.</p>
</blockquote>
<p>并认为这是一个随机行为，具有一定意义上的周期性，等一会就好了。</p>
<p>事实并非如此。有一些角度是无论如何都放不到的，刚放下去一会就会微微一转，然后角度就变了。属实糟心，我在自己服务器里面放了20次都没有放成功。那个时候我终于意识到Ray的claim可能是在扯淡，于是去看了下代码。</p>
<p>代码里面似乎没有任何一处体现了“微微一转”这种行为。最上面<code>BoatItem</code>的代码就是直接把<code>yRot</code>设成了玩家的<code>yRot</code>。我用全文搜索对于<code>yRot</code>产生修改的片段，没有一处是这样的。<code>yRot</code>是用<code>float</code>存储的，应该不会产生舍入误差这种事情。</p>
<p>整个事情让我对于Minecraft的屎山代码不由生出一份敬畏，我开始觉得这是玄学问题，直到看见<code>net/minecraft/network/protocol/game/ClientboundAddEntityPacket</code>的构造函数……</p>
<pre class="line-numbers"><code class="language-java">public class ClientboundAddEntityPacket implements Packet&lt;ClientGamePacketListener&gt; &#123;
    ...
    private int xRot;
    private int yRot;

    public ClientboundAddEntityPacket(int n, UUID uUID, double d, double d2, double d3, float f, float f2, EntityType&lt;?&gt; entityType, int n2, Vec3 vec3) &#123;
        ...
        this.xRot = Mth.floor(f * 256.0f / 360.0f);
        this.yRot = Mth.floor(f2 * 256.0f / 360.0f);
        ...
    &#125;
&#125;</code></pre>
<p>以及<code>net/minecraft/client/multiplayer/PacketListener</code>如何处理这个packet的:</p>
<pre class="line-numbers"><code class="language-java"> @Override
 public void handleAddEntity(ClientboundAddEntityPacket clientboundAddEntityPacket) &#123;
     Entity entity;
     ...
     if (entity != null) &#123;
         entity.xRot = (float)(clientboundAddEntityPacket.getxRot() * 360) / 256.0 f;
         entity.yRot = (float)(clientboundAddEntityPacket.getyRot() * 360) / 256.0 f;
         ...
     &#125;
 &#125;</code></pre>
<p>哦……原来还真有舍入误差这回事……Mojang大概想省空间，虽然rotation在客户端和服务端内部都是<code>float</code>存储的，但是在网络传输的时候硬是塞到了<code>byte</code>里面。于是在这一层转换的帮助下，Minecraft理论上就只有256种可能的角度了。</p>
<p>我猜测的整个放船的流程大致如下：</p>
<ol type="1">
<li>客户端玩家手持船右键</li>
<li>客户端发出一个<code>ServerboundUseItemPacket</code></li>
<li>服务端接收到<code>ServerboundUseItemPacket</code>，然后执行<code>BoatItem</code>有关的代码</li>
<li>服务端新增船的实体，想客户端发送<code>ClientboundAddEntityPacket</code>，这个时候角度被舍入了</li>
<li>客户端收到<code>ClientboundAddEntityPacket</code>，将本地的船同步为舍入的角度，在10gt的插值作用下体现为“微微一转”</li>
<li>玩家坐上去，这个时候一系列网络同步把服务端的船的角度也舍入了</li>
</ol>
<pre class="line-numbers mermaid"><code class="language-none">sequenceDiagram
    participant Client
    participant Server
    Note left of Client: Player right clicks
    Client-&gt;&gt;Server: ServerboundUseItemPacket
    Note right of Server: Execute code in &lt;br/&gt; BoatItem.use
    Server-&gt;&gt;Client: ClientboundAddEntityPacket</code></pre>
<p>因此，微微一转的问题其实根本就不是Ray说的随机事件，而是在网络传输当中舍入误差加上客户端线性插值带来的现象。看似的随机只是因为F3的精度不够，44.99和45.01都显示为45.0，虽然从代码当中我们可以清晰地看到两个数的舍入结果是不一样的。</p>
<p>这么做的好处是对于90°，45°等特殊角这一层舍入可以保证绝对的精确，避免了放成45.01°然后在船上开1000格偏离航道的惨剧。缺点是很多角度就不能精确达到了。两个相邻的可达角度差1.40625°，大概勉强可以接受。</p>
<p>话又说回来了，<code>ServerboundMovePlayerPacket</code>这种同步玩家信息倒是还是用<code>float</code>作为载体的。所以玩家的角度还是很精确的？难道是因为玩家相对于实体少很多所以有更多流量可以挥霍？</p>
<p>我再次对于Minecraft的代码肃然起敬。</p>
<h1 id="辅助高级冰船的scarpet脚本">辅助高级冰船的Scarpet脚本</h1>
<p>在知道这些之后我们就可以有针对性地设计冰道了，因为人比较懒所以我写了一个scarpet的脚本：</p>
<pre class="line-numbers"><code class="language-none">__command() -&gt; null;

_ice_mark(x, y, z) -&gt; create_marker(&#39;ICE&#39;, l(x + 0.5, y + 0.5, z + 0.5));

_mark_x(y, x1, z1, x2, z2, w) -&gt; (
    if(x1 &gt; x2, l(x1, x2, z1, z2) = l(x2, x1, z2, z1));
    k = (z2 - z1) / (x2 - x1);
    for(range(x1, x2 + 1),
        x = _; z = round((x - x1) * k + z1);
        for(range(-w + 1, w), _ice_mark(x, y, z + _))
    )
);

_mark_z(y, x1, z1, x2, z2, w) -&gt; (
    if(z1 &gt; z2, l(x1, x2, z1, z2) = l(x2, x1, z2, z1));
    k = (x2 - x1) / (z2 - z1);
    for(range(z1, z2 + 1),
        z = _; x = round((z - z1) * k + x1);
        for(range(-w + 1, w), _ice_mark(x + _, y, z))
    )
);

mark(y, x1, z1, x2, z2, w) -&gt; (
    dx = abs(x1 - x2); dz = abs(z1 - z2);
    if(dx == 0 || dx &lt; dz, _mark_z(y, x1, z1, x2, z2, w),
        _mark_x(y, x1, z1, x2, z2, w))
);

clear() -&gt; remove_all_markers();

_wrap_deg(x) -&gt; (
    tmp = x % 360.0;
    if(tmp &lt; -180, tmp + 360, tmp &gt; 180, tmp - 360, tmp)
);

_wrap_internal(x) -&gt; (
    tmp = x % 360.0;
    if (tmp &lt; 0, tmp + 360, tmp)
);

_angle(x1, z1, x2, z2) -&gt; -atan2(x2 - x1, z2 - z1);

_floor_angle(x) -&gt; _wrap_deg(floor(x * 256 / 360.0) * 360 / 256);

angle(x1, z1, x2, z2) -&gt; (
    theta = _angle(x1, z1, x2, z2);
    print(str(&#39;exact yaw: %f&#39;, theta));
    lb = floor_angle(_wrap_internal(theta));
    ub = floor_angle(_wrap_internal(theta + 360.0 / 256));
    print(str(&#39;floored yaw (lb): %f&#39;, lb));
    print(str(&#39;floored yaw (ub): %f&#39;, ub));
    ret = if(abs(lb - theta) &lt; abs(ub - theta), lb, ub);
    print(str(&#39;suggested yaw: %f&#39;, ret));
);

_best_angle(x1, z1, x2, z2) -&gt; (
    theta = _angle(x1, z1, x2, z2);
    lb = floor_angle(_wrap_internal(theta));
    ub = floor_angle(_wrap_internal(theta + 360.0 / 256));
    if(abs(lb - theta) &lt; abs(ub - theta), lb, ub)
);

adjust(x1, z1, x2, z2, dir) -&gt; (
    x = _best_angle(x1, z1, x2, z2);
    ov = 360; opt = 0;
    print(str(&#39;yaw: %f&#39;, x));
    if(
        dir == &#39;x&#39;,
        for(range(x2 - 1000, x2 + 1000), 
            tmp = abs(_angle(x1, z1, _, z2) - x);
            if (tmp &lt; ov, ov = tmp; opt = _)
        );
        print(str(&#39;%f %f %f %f&#39;, x1, z1, opt, z2)),
        dir == &#39;z&#39;,
        for(range(z2 - 1000, z2 + 1000), 
            tmp = abs(_angle(x1, z1, x2, _) - x);
            if (tmp &lt; ov, ov = tmp; opt = _)
        );
        print(str(&#39;%f %f %f %f&#39;, x1, z1, x2, opt)),
        print(&#39;direction must either be x or z&#39;)
    )
)</code></pre>
<p>用法如下：</p>
<ol type="1">
<li><p><code>/iceboat y x1 z1 x2 z2 w</code>标记一条从<span class="math inline">\((x_1,y,z_1)\)</span>到<span class="math inline">\((x_2,y,z_2)\)</span>的，宽度为<span class="math inline">\(2w-1\)</span>的冰道。</p></li>
<li><p><code>/iceboat clear</code>清除标记。</p></li>
<li><p><code>/iceboat angle x1 z1 x2 z2</code>计算站在<span class="math inline">\((x_1,z_1)\)</span>望向<span class="math inline">\((x_2,z_2)\)</span>的视角方向，最近的两个可达角度，以及推荐的可达角度。</p></li>
<li><p><code>/iceboat adjust x1 z1 x2 z2 x/z</code>固定<span class="math inline">\((x_1,z_1)\)</span>，沿<span class="math inline">\(x/z\)</span>轴在<span class="math inline">\((x_2,z_2)\)</span>附近寻找最贴近可达角度的方块坐标。考虑到在几千格之后哪怕0.7°的角度差都会有导致最终百格的偏差，这个命令非常重要。在算法实现角度，用三分写是最快的，但是考虑到从-180°到180°有一个不连续间断点，导致写三分会涉及到一些繁琐的细节。我比较懒，所以就用了比较慢的写法（这个写法其实也有明显bug，但是我不准备修）。</p></li>
</ol>
<p>常见的使用流程：</p>
<ol type="1">
<li>确定冰道的两点。</li>
<li>固定一点（通常是nether hub或者已经固定留好空间的端点），使用<code>/iceboat adjust</code>微调另一端点的位置。同时计算得出角度。</li>
<li>使用<code>/iceboat mark</code>标记放冰的位置。</li>
<li>放冰。</li>
<li>使用<code>/iceboat clear</code>清除标记。</li>
</ol>
<p>目前比较不人性化的一点是carpet的<code>create_marker</code>用的是隐形盔甲架实现的，hitbox的制约导致有的时候放不了方块，用area effect cloud可能可以解决这个问题。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ma-chengyuan.github.io/2020/04/17/PanDownload/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/17/PanDownload/" class="post-title-link" itemprop="url">自己对于PanDownload的一些想法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-17 07:46:00" itemprop="dateCreated datePublished" datetime="2020-04-17T07:46:00-04:00">2020-04-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>PanDownload前几天被封了。</p>
<p>网络上那个群情激奋啊，看B站连“百度的七宗罪”都出来了。还有人把GFW做的DNS污染，域名置换等和PanDownload做的“多线程下载百度云盘”相并列，不乏讥讽地质问为何遭到制裁的是看起来程度最轻的PanDownload。</p>
<p>我不是PanDownload的使用者，自己也很少用百度云盘，或许称不上是特别利益相关者吧。</p>
<p>但看到这个新闻的时候我是很矛盾的。</p>
<p>我讨厌百度吗？</p>
<p>肯定的，我从八年前开始用百度云盘，从不限速的年代一路用到限速的坑爹时代，不恨是不可能的。</p>
<p>我喜欢PanDownload吗？</p>
<p>喜欢的，我自己两三年以前还在用很多油猴的提取直连的脚本，这种绕开限速薅羊毛的软件我不要太喜闻乐见。</p>
<p>那在这次事件中我支持PanDownload吗？</p>
<p>我其实想保持中立。</p>
<p>我们对于PanDownload等一众软件的推崇源于对于百度免费用户限速的痛恶。由俭入奢易由奢入俭难，对于限速的痛恶则源于几年前限速不存在的事实。</p>
<p>但是仔细想想，免费的大云盘这件天上掉馅饼的事情合理吗？</p>
<p>参照如今硬盘的价格以及带宽的价格，我觉得百度留着云盘业务肯定不是做慈善的。在线存储是一种服务，是企业生产的一种产品，收费这件事情本身是无可厚非的。放眼国外市场，Dropbox，Google Drive等也没有做慈善的。不是空间小就是下载慢。</p>
<p>要说百度可恶，也就可恶给用户提供了“一开始的美好”，用2TB的存储空间诱惑用户，等用户粘性培养上来之后，在几年前再限速到一个坑爹的地步，这个时候你左右为难。付钱吧，跟几年前比感觉亏了，不付钱吧，自己很多数据还存着呢。反正百度这几年的潜台词是越来越明显了：不付钱别玩，让你免费用已经是施舍你了，还BB那么多干嘛。</p>
<p>这句话很让人恼火，非常让人恼火，但是仔细思考一下，似乎是对的。云盘是一个市场，在市场里哪有永远白嫖的份。这个时候最好的结局是期待着市场竞争逼着百度降价。但是我国云盘市场的竞争着实不够激烈，百度隐隐形成垄断之势，降价看来是遥遥无期了（话又说回来，一个月25块钱的价格换算成美元大概与Google Drive差不多，其实真没那么多好抱怨的）。</p>
<p>这个时候PanDownload以及一众多线程下载软件出现了。几十个线程一起下，让免费用户看到了曙光。</p>
<p>我们不妨把PanDownload看做是网盘市场的一个有力的竞争者（虽然竞争并非其初衷），把它的下载服务看做是一个全新的网盘产品，它提供的“网盘产品”的竞争性优势在于</p>
<ol type="1">
<li>和已有百度网盘资料的完全兼容</li>
<li>免费用户的高速下载</li>
</ol>
<p>如果PanDownload的网盘产品真的是独立而全新的，那百度该死，谁也不能阻止PanDownload一统江湖。</p>
<p>但是事实不是这个样子的，PanDownload提供的这个如此有竞争性的“产品”，是基于百度网盘的生产资料与资本建立起来的。PanDownload运用的多线程下载，亦或是其他软件的直链提取，这些都不是百度网盘官方提供的API，也不是百度网盘官方认可的。</p>
<p>因此，全民的喜闻乐见与对于百度的痛恨，也改变不了PanDownload不正当竞争（视作竞争者）或者说侵犯百度权益（是做第三方软件）的事实。</p>
<p>单纯地因为PanDownload是在造福人类，是在薅垃圾公司的羊毛，就对这种行为的本质视而不见，其实是违背法治社会的初衷的。</p>
<p>这就仿佛所有人都认为张三是人渣，李四替天行道把张三打死了就可以不犯法一样。事实上，哪怕张三是在逃的杀人犯过街喊打喊打，如果不处于类似正当防卫的情形，李四把张三打死也是不对的。故意杀人就是故意杀人。何况百度作为一家公司目前来看还没有在云盘的运营中触犯法律（或许有垄断？不清楚）。前几天在B站上看罗翔老师说“法律要考虑民众的诉求，但是要超越民众的偏见”。</p>
<p>百度这叫体量大，如果是一家新创业的公司，被这么一集体白嫖，搞得破产了怎么办？这种事情不是没有发生过。难道法律里面还要加入一条“如果体量够大而且民众不爽，某某法规就失效”？</p>
<p>如果对百度不爽，就尽量避免去用它。现在搭建一个自己的网盘已经是很简单的一件事情了。</p>
<p>何况部分用户离不开百度网盘的原因大概是因为下”资源“，所谓”资源“，又大致可以分为免费（说的不好一点就是盗版）的电影与一些淫秽资源。后者我不想多说啥（其实吧，我觉得一些黄站之于内容提供者也是PanDownload之于百度网盘的存在），但是免费下盗版竟然还有理了？</p>
<p>没错，一直白嫖一直爽是中文互联网的常态，我自己也爱装破解版软件，看视频听音乐能不付钱就不付钱，但是理直气壮地说出来又是另一回事情了。百度给你下就不错了，PanDownload让你下爽了就下爽了，但是这种处于灰色地带的软件，要较真起来，我们真的不占理。</p>
<p>或许吧，网民一直隐隐有一种心态，在网络上白嫖是对的，反正就是一堆数据拷来拷去，百度云盘也就是一个网站而已，付费下载闻所未闻。这种心态在我看来是有问题的。垄断着实可恶，但是支付给服务提供者报酬的道理还是不错的。</p>
<p>因此，我觉得PanDownload虽然对于我们是一款好软件，但是最近取缔PanDownload这一事，我觉得还是无可厚非的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ma-chengyuan.github.io/2020/04/03/Gradle%E5%88%9D%E6%8E%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/03/Gradle%E5%88%9D%E6%8E%A2/" class="post-title-link" itemprop="url">Gradle初探</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-03 10:26:36" itemprop="dateCreated datePublished" datetime="2020-04-03T10:26:36-04:00">2020-04-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>自己最近又在用JVM系的语言开新坑。这次终于说服自己从Jetbrains的温床里脱离出来改用了大家都在用的Gradle！感觉良好，在这里简单写一下大概咋用，给之后的自己留一个参考吧。</p>
<p>为什么自己要用Gradle呢？</p>
<ol type="1">
<li>Gradle作为一个开源的构建系统不与任何IDE绑定（比如说IDEA），这相当于增加了代码的兼容性。</li>
<li>Gradle里面可以直接从Maven Central上下库下来，省了我手动下库导入的过程，库更新了也好维护。这对我来说非常地有诱惑力。实测也非常舒服。</li>
<li>Gradle从设计上来说非常灵活，Gradle默认的构建脚本是用Groovy写的（当然也可以用Kotlin但是这似乎不是主流的样子），而不是只有标记功能的XML，这使Gradle一下子非常强大。</li>
<li>大家都在用的样子。</li>
<li>IDEA对于Gradle的支持非常棒！（所以到头来自己还是没有逃脱JB的舒适圈……）</li>
</ol>
<p>虽然说Gradle的功能很强大我目前的用法还是最初级的。我目前用的Gradle代码大致如下：</p>
<pre class="line-numbers"><code class="language-groovy">plugins &#123;
    id &#39;java&#39;
    id &#39;org.jetbrains.kotlin.jvm&#39; version &#39;1.3.61&#39;
&#125;

group &#39;chengyuan&#39;
version &#39;1.0-SNAPSHOT&#39;

sourceCompatibility = 1.8
project.ext.lwjglVersion = &quot;3.2.3&quot;
project.ext.lwjglNatives = &quot;natives-windows&quot;

repositories &#123;
    maven &#123; url &#39;http://maven.aliyun.com/nexus/content/groups/public/&#39; &#125;
    maven &#123; url &quot;https://oss.sonatype.org/content/repositories/snapshots/&quot; &#125;
    mavenCentral()
&#125;

dependencies &#123;
    implementation platform(&quot;org.lwjgl:lwjgl-bom:$lwjglVersion&quot;)
    
    implementation &quot;org.lwjgl:lwjgl&quot;
    implementation &quot;org.lwjgl:lwjgl-assimp&quot;
    implementation &quot;org.lwjgl:lwjgl-bgfx&quot;
    implementation &quot;org.lwjgl:lwjgl-glfw&quot;
    implementation &quot;org.lwjgl:lwjgl-nanovg&quot;
    implementation &quot;org.lwjgl:lwjgl-nuklear&quot;
    implementation &quot;org.lwjgl:lwjgl-openal&quot;
    implementation &quot;org.lwjgl:lwjgl-opengl&quot;
    implementation &quot;org.lwjgl:lwjgl-par&quot;
    implementation &quot;org.lwjgl:lwjgl-stb&quot;
    implementation &quot;org.lwjgl:lwjgl-vulkan&quot;
    runtimeOnly &quot;org.lwjgl:lwjgl::$lwjglNatives&quot;
    runtimeOnly &quot;org.lwjgl:lwjgl-assimp::$lwjglNatives&quot;
    runtimeOnly &quot;org.lwjgl:lwjgl-bgfx::$lwjglNatives&quot;
    runtimeOnly &quot;org.lwjgl:lwjgl-glfw::$lwjglNatives&quot;
    runtimeOnly &quot;org.lwjgl:lwjgl-nanovg::$lwjglNatives&quot;
    runtimeOnly &quot;org.lwjgl:lwjgl-nuklear::$lwjglNatives&quot;
    runtimeOnly &quot;org.lwjgl:lwjgl-openal::$lwjglNatives&quot;
    runtimeOnly &quot;org.lwjgl:lwjgl-opengl::$lwjglNatives&quot;
    runtimeOnly &quot;org.lwjgl:lwjgl-par::$lwjglNatives&quot;
    runtimeOnly &quot;org.lwjgl:lwjgl-stb::$lwjglNatives&quot;
    
    testCompile group: &quot;junit&quot;, name: &quot;junit&quot;, version: &quot;4.12&quot;
&#125;

compileKotlin &#123;
    kotlinOptions.jvmTarget = &quot;1.8&quot;
&#125;

compileTestKotlin &#123;
    kotlinOptions.jvmTarget = &quot;1.8&quot;
&#125;</code></pre>
<p>首先是<code>plugins</code>这段，这一段虽然重要但一般用不着特别操心，按照我的理解大概是语言支持的插件。</p>
<p>接下来是版本、JVM版本之类的，看着也很明白。</p>
<p>然后可以申明一些接下来会用到的常量。</p>
<p><code>repository</code>告诉Gradle从哪里找库。常见的源有内置的函数，例如<code>mavenCentral()</code>，<code>jcenter()</code>。如果是其他的Maven源也可以指定URL。比如说我这里用了阿里云的Maven镜像，在国内速度就会快上很多。</p>
<p>接下来是<code>dependencies</code>，这个是重头戏。</p>
<p>最常见的是<code>implementation</code>，这个后面一般跟库的Maven id。如果想直接引用本地文件可以用<code>files(...)</code>，如果是一个平台一个版本的可以用<code>platform(...)</code>。基本上这就覆盖了99%的用途。</p>
<p>此外还有<code>runtimeOnly</code>，这个和<code>implementation</code>的区别就是<code>runtimeOnly</code>的库是不参与编译的，只在运行期有效。这一般都是用JNI的一众native库和一些二级库。</p>
<p>还有<code>testCompile</code>，用这个修饰的库是只在跑单元测试的时候依赖的，因此基本上都是一些测试有关的库。我人懒，平时懒得写单元测试，因此这个我基本上不用。</p>
<p>这些就是我目前摸索出来的Gradle的基本用法，目前的感觉就是把IDEA里面的很多GUI的操作文字化，非常舒适，省了很多麻烦。更复杂的用法例如自定义build task等都可以在官网上找到（文档很丰富也是Gradle比较吸引人的点）。</p>
<p>最后有一点点想吐槽，就是Groovy似乎单引号和双引号都可以表示字符串。双引号的字符串支持插值，这似乎是唯一的予以区别。IDE默认生成的是单引号，LWJGL的打包器生成的是双引号，似乎最通用的是双引号，自己到底是用双引号还是单引号呢？这种东西真的是万恶之源。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ma-chengyuan.github.io/2020/03/29/FuckZhihu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/29/FuckZhihu/" class="post-title-link" itemprop="url">退乎，与自省</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-29 22:45:24" itemprop="dateCreated datePublished" datetime="2020-03-29T22:45:24-04:00">2020-03-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>上一次发文章已经是三个星期以前了。</p>
<p>感到一丝焦虑，但三个星期中确实没有做成值得写一写的事情是一个令人沮丧的事实。</p>
<p>开学了人忙了是一个原因。人一忙，一个矛盾愈发凸显。</p>
<p><strong>理性上对于系统化学习的追求与感性上沉溺于碎片化知识平台的矛盾。</strong></p>
<p>自己要应付AP考试还有一整本的Gregory Mankiw的经济学要看。</p>
<p>自己现在还在看柏拉图的《理想国》，书很好看，觉得很有启发。</p>
<p>地理的等级考也是要准备起来的。</p>
<p>文书也是要做起准备的。</p>
<p>个人的项目也是要做的。</p>
<p>退一步讲，自己还有一个追番TODO List还要十几部番要追，轻小说TODO List还有几部要抽空看。</p>
<p>当时间就剩下这么一点，知乎这么一个搅屎棍的存在就显得令人恼火了。</p>
<p>自己之前一直看不起快手和抖音，觉得这种垃圾玩意纯粹就是让人上瘾的。</p>
<p>可悲的是，自己也成了知乎的奴隶。</p>
<p>确实我在鄙视链上比抖音快手高一级，但是当鄙视链的每一根链环都足够拴着你吃屎的时候，其实区别不大。</p>
<p>知乎不知不觉成为了我常逛的唯一平台。居然占据了30%的耗电，难道这不恐怖吗？</p>
<p>只是为了看时事，结果刷了一个小时，难道这不恐怖吗？</p>
<p>我觉得是时候好好反思反思了。</p>
<p>要是这一个小时有营养就算了。</p>
<p>现在的知乎，90%的回答就是在玩烂梗。时政问题下就是两个极端的口诛笔伐，喊入关的喊入关，吹国外的吹国外，骂公知的骂公知。党同伐异，贴上标签就开骂，评论区里友善度堪比电竞祖安。</p>
<p>国家自信的大旗已经举起，反公知的政治正确俨然形成。这着实是好事，但是被这股情绪裹挟着消磨时间又是另一回事了。</p>
<p>人们说政治是一个门槛看起来低实际上高得很的学科。谁都能对政治发表一番高论，但是要使理论逻辑自洽，预测准确一致就需要非常高的水平。</p>
<p>知乎上大体是前者。山高死而入关兴，大家都在喊入关，要么就国家拟人化走一波，大家还就好这一口。</p>
<p>敢情我是来看波兰球动画的呢？</p>
<p>不然要么就恶政隐或者膜蛤走一波，下面的评论狂喊冲塔冲塔枪毙枪毙药丸药丸下个账号再见，不亦乐乎，谁说天朝子民不可妄议朝政？</p>
<p>但是我现在真的觉得让我们普罗大众表达诉求可以，玩键盘政治或许不值得提倡。</p>
<p>我记得16年刚玩知乎的时候，还是有很多很有意义的回答的。比如说人民群众喜闻乐见的知乎如意勺系列，虽然问题虚构荒诞，但是科普的目的确实达到了。每一篇文章洋洋洒洒干货十足，比起现在一千万和蜗牛的虚构问题不知道高到哪里去了。</p>
<p>现在还有这么多干货文章吗？有的，引经据典的回答终究是有的，之前在知乎上看到的毕导的科普视频也是很好的。但是这些都被大大稀释了，到现在，为了这么一篇好文章刷过50篇朱一旦，营销号，观察者网或者环球时报似乎不值得。</p>
<p>我不知道是资本的入驻使知乎变了味，还是推荐算法使然。</p>
<p>我倾向于后者。</p>
<p>推荐算法实在是太恐怖了。</p>
<p>它恐怖就恐怖在它是一个正反馈系统，平衡点是不稳定的。只要思想稍有偏差，就会迅速滚到一个极端去。</p>
<p>它迎合你，让你每一时刻都享受英雄所见略同的快感。很多时候看前两句句你就知道这篇文章要讲啥，但是禁不住讲的东西你喜欢，于是又看了下去。很多时候回答就只有两句，篇幅完全不重要。我逛知乎的心态已经从以往的获取知识，到寻求附和与认同为主，能看到啥就学啥为辅的情况了，非常可悲。自己当真就没有独立思考的能力和对此的自信？</p>
<p>小群体内的自我认同除了加深偏执以外不会引入新的思想，甚至还会降低你对异见的容忍度，看到不一样的观点就烦躁，哪怕它的长篇大论是真的有论点有论据有深度可以学到东西的。知乎里现在键政领域两极分化，推荐算法功不可没。</p>
<p>当一个问答网站将迎合用户，附和用户作为首要任务，而不是去挑战用户的认知，扩充用户的头脑的话，这个网站可就真的忘了初心，出了大问题了。</p>
<p>或许也没有忘初心，万一人家初心就是赚钱呢。</p>
<p>现在想想我每天干嘛？去知乎看人嘲讽美国防疫，还是看人调侃美股八熔八耻？</p>
<p>但是我又不是靠知乎获得这些信息的。我每天一大早都是自己去JHU的网站上查人数，自己查道指的。小米内置的资讯在遇到大新闻的时候也没落下。也就是我不断心理暗示知乎是一个获得时政新闻的平台，其实根本不是。那我天天去干嘛？我贱不贱啊？贱不贱啊？</p>
<p>自己完全是被动地被知乎牵着鼻子走，可太悲哀了。</p>
<p>另一方面，知乎的产品设计实在是太高明了。</p>
<p>我觉得我还是要回归搜索引擎。</p>
<p>搜索引擎有两个好，一个是它没有针对个人的推荐算法，另一个是你永远有主动权。你搜索什么它给什么。你不搜它不给，爽到。搜出来的结果分散于网络，不容易对于一个平台形成粘性。因此，只要搜索引擎的算法不是特别差（比如说Google），用搜索引擎就不会有大问题。</p>
<p>被搜索引擎带到知乎和直接在知乎搜索栏里搜索是完全两个不一样的概念。</p>
<p>搜索引擎的覆盖面比知乎高，那我为啥不用搜索引擎呢？</p>
<p>我要学习技术，我为啥不去SO、V2EX、SF之类的呢？</p>
<p>同样是刷手机，我为啥不去B站上看看罗翔追追番呢？前者能普法，后者比看垃圾梗更娱乐一点。</p>
<p>为什么呢？</p>
<p>自己之前真的是懒。妄想着知乎一个平台就够了，结果被灌屎，被偶尔尝到的糖吊着胃口，持续地被喂屎。</p>
<p>太糟糕了，实在是太糟糕了。</p>
<p>丹麦哲学家 Søren Kierkegaard 讲过一句话，现在想起来觉得实在是太对了。</p>
<blockquote>
<p>People demand freedom of speech as a compensation for the freedom of thought which they seldom use.</p>
</blockquote>
<p>把知乎卸了。搜索引擎搜到还是会看一下，但是不会主动逛了。</p>
<p>但愿不会真香。</p>
<hr />
<p>其实吧，我觉得，自己退出知乎的这个决定在我看来也是很可悲的。</p>
<p>因为这是我对于无法解决实际问题的一个逃避。</p>
<p>控制不住逛知乎，知乎用户粘性很高是外因，自己不自制是内因。外因通过内因而起作用。</p>
<p>有的时候我觉得虽然学校的政治课大多弱智，但是一些矛盾论以及唯物辩证的思路终究还是受用的。</p>
<p>自己究竟什么时候才会认认真真审视自己自制力不够的问题呢？</p>
<p>我如何才能避免自己看知乎变成看B站呢？</p>
<p>我自以为知乎比B站容易上瘾，先这么自以为着吧。与自己的颓废欲望做出妥协。</p>
<hr />
<p>搜索引擎让我掌握了主动权，但是主动权往往是不够的。我要主动搜啥呢？</p>
<p>正如YPM里面Humphrey说的，I have to know everything so that I can decide whether I need them!</p>
<p>我也有同学说知乎平台里面有很多宝藏回答，我自己也觉得很多时候知乎的热榜里有热点新闻，这是知乎的价值。</p>
<p>可以料想到的是，我现在退出知乎以后，终究要有一个信息平台顶替它的位置，keeping myself well-informed.</p>
<p>这个平台会是什么呢？</p>
<p>我不期望是一个正反馈的系统，今日头条之类的肯定不行。</p>
<p>直接看新闻？新闻是一个无反馈的系统，但为了避免被带入一家的政治立场当中去就要各种立场的新闻都看，不知道有没有时间。</p>
<p>并没有人设计过负反馈的信息平台，估计也不会有人设计这种吃力不讨好的玩意，虽然这是最好的。</p>
<p>朋友圈或许可以，让亲戚朋友代我受这些正反馈平台的戕害自然是最好不过的了（感觉自己的思想还是有点阴暗），反正他们在朋友圈几句话也不足以左右我本身的判断，他们转发的文章我也未必要看，我要的就是这件事情本身，这样我就可以自己去搜了。</p>
<p>唉。有的时候我觉得学数理之类的不用区分立场，逻辑与实验自有定论，省了我的脑细胞，是我作为理科生的幸运，但让我缺乏批判性思考的锻炼，又是我作为理科生的不幸。以至于面对正反馈带来的立场极端化不得不采取“闭关锁国”的战略，我也不知道是不是好事。我一直认为，如果有人能够依靠自己的批判性思维带来的负反馈效用力压推荐算法的正反馈，以至于在主流平台当中依然可以保持相对地客观，那是真的厉害。</p>
<p>另一种自暴自弃的思路莫过于，创造一种统一的政治立场，有一个绝对的权威来树立绝对的政治正确，这样大家都处在同一个立场，提前到达了正反馈的极限，正反馈也就没用了。这正如西方对于我国的态度。一个小圈子里互相认同而偏执是悲哀，但是如果几十亿人不断地相互认同而产生的根深蒂固的思潮，我也不知道是好是坏。它确实湮灭了所有的异见也降低了头脑在这个问题的负担，但也导致新思维的短缺。站在民智发展的角度来看，这样很危险，但是站在统战的角度上，这样似乎又不是不行。</p>
<p>我从未学过认知论也从未学过教育学，但是我推断人类的认知过程本身不可避免地是一个先天的正反馈过程，别人的认可是激励，别人的反驳是惩罚。在基础教育的过程中，“别人”单指老师与同学，因此这个思路被不断提倡，而当到了网络的辩论场，人们自动就会把“别人”的定义延拓了。要逆转这个态势，审慎地对待别人的认可，积极地面对别人的反驳，小心翼翼地避免矫枉过正，在这个时代还要对抗推荐算法，实在是不容易。而如果只有一个人能够做到这一步，那么这个人被孤立于群体之中，也未必如之前一样快乐。</p>
<p>因此我越看《理想国》，越觉得像里面的苏格拉底一样在辩论中不恼羞成怒诉诸于人身攻击，反而通过设问，在多个立场之间来回切换，将辩论用作真正探寻真理的途径而非自我膨胀的乱骂一通，实在是一种非常高明的智慧。我觉得自己离这个境界差远了，而对于是否所有人都能拥有这个智慧，是否应该拥有这份智慧，拥有这份智慧之后是否会感到快乐，我现在很悲观。</p>
<p>唉，自己社科不行，也只能乱发牢骚一通。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://ma-chengyuan.github.io/2020/03/02/Manjaro-VM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/02/Manjaro-VM/" class="post-title-link" itemprop="url">用LaTeX实时记数学笔记？！</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-02 01:50:04" itemprop="dateCreated datePublished" datetime="2020-03-02T01:50:04-05:00">2020-03-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我几个月前看到国外有人<a target="_blank" rel="noopener" href="https://castel.dev/post/lecture-notes-1/">分享</a>用LaTeX实时记1700页数学笔记的感受，当时就被惊艳到了，心生向往。这次因为疫情待在家里上在线课程，总算是给了我一个带电脑进课堂的机会。于是我也仿照原作者的做法尝试了用记LaTeX笔记，这篇文章就来写一写我配置环境时遇到的坑和使用感受。</p>
<h1 id="系统选择">系统选择</h1>
<p>原文的作者采用的是Ubuntu发行版+bspwm作为桌面管理器，但是bspwm太小众，网上的资料很少。而且实测装在Ubuntu上默认的配置在视觉上不协调（还要自己去装一个像样的状态栏，总之就是太烦了）。相比之下i3作为另一个Tiling Window Manager比bspwm资料多多了，也比较适合我这种小白。权衡之下我选用Manjaro + i3。在Virtual Box下安装。</p>
<h1 id="配置镜像">配置镜像</h1>
<p>这一步不是必须的，因为Manjaro的默认源在国内的速度也还可以接受（~400kBps）。但是换了交大的源之后可以到10MBps：</p>
<pre class="line-numbers shell"><code class="language-none">sudo pacman -Syy
sudo pacman-mirrors -i -c China -m rank
sudo pacman -Syyu</code></pre>
<p>然后编辑<code>/etc/pacman.conf</code>加上ArchLinuxCN的交大镜像：</p>
<pre class="line-numbers"><code class="language-ini">[archlinuxcn]
SigLevel = Optional TrustedOnly
Server = https://mirrors.sjtug.sjtu.edu.cn/archlinux-cn/$arch</code></pre>
<p>最后导入一下密钥环，镜像就配置完了：</p>
<pre class="line-numbers shell"><code class="language-none">sudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring</code></pre>
<h1 id="安装virtual-box-ga">安装Virtual Box GA</h1>
<p>Manjaro默认对于虚拟机的支持不是很好。我不选择在VMWare上装Manjaro的主要原因也是因为我没有找到VMWare下自动分辨率比较简单的解决方案。在Virtual Box下只要装Virtual Box Guest Addition就可以了，美滋滋。</p>
<p>先安装基本的编译套件：</p>
<pre class="line-numbers shell"><code class="language-none">sudo pacman -S gcc make</code></pre>
<p>然后查看一下Linux内核版本：</p>
<pre class="line-numbers shell"><code class="language-none">uname -r</code></pre>
<p>是5.4，因此安装5.4的headers：</p>
<pre class="line-numbers shell"><code class="language-none">sudo pacman -S linux54-headers</code></pre>
<p>之后在Virtual Box菜单下插入GA的iso文件。我最初是手动挂载的（因为找不到i3里面怎么开文件管理器），就是<code>sudo blkid</code>看一下设备然后<code>mount</code>（如果出现不支持<code>iso9660</code>直接重启）。后来意识到文件管理器的名字是<code>pcmanfm</code>，再发现默认可以直接<code>mod + F3</code>打开文件管理器，于是就可以在上面直接操作了。<code>cd</code>进去运行<code>autorun.sh</code>跑完重启。就发现可以自动适应外部分辨率以及共享剪贴板了，非常方便。</p>
<h1 id="配置键位">配置键位</h1>
<p>默认Manjaro配置的<code>mod</code>键是<code>super</code>，也就是Win键。但是实测Win键在虚拟机环境下会有小问题（例如Win + L总是会被Windows先拦截导致锁屏）。所以我到<code>~/.i3/config</code>里面把<code>mod</code>键改成了<code>alt</code>。我还把i3默认的<code>jkl:</code>键位改成了和Vim相一致的<code>hjkl</code>键位。</p>
<h1 id="中文相关">中文相关</h1>
<p>Manjaro默认的中文渲染很有问题（装系统的时候居然没有中文字体！）。因此需要手动配置中文的渲染。</p>
<p>我基本上是按照<a target="_blank" rel="noopener" href="https://wiki.archlinux.org/index.php/Font_Configuration/Chinese_(简体中文)">Arch Wiki</a>上的Android类字体配置的。但是Arch Wiki上没有配置给终端用的等宽字体，需要个人发挥一下。我最喜欢的等宽字体是Sarasa Gothic（因为有中文）（去除中文我现在最喜欢的是Jetbrains Mono）。我发现ArchLinuxCN的源上已经有这款字体了，于是直接安装：</p>
<pre class="line-numbers shell"><code class="language-none">sudo pacman -S ttf-sarasa-gothic</code></pre>
<p>然后修改<code>~/.Xresources</code></p>
<pre class="line-numbers"><code class="language-ini">URxvt.font: xft:Sarasa Term SC:size=12</code></pre>
<p>重启一下就好了（其实不用重启，<code>xrdb ~/.Xresources</code>也行？）</p>
<p>接着是输入法。我原来准备装搜狗的，但是搜狗因为各种奇奇怪怪的原因（比如说字体找不到，比如说默认装<code>fcitx</code>的时候没有<code>qt4</code>的支持需要额外安装）不能用，在各种坑之后我决定不用它改用sunpinyin+cloud pinyin的组合，试用下来也是相当令人满意的：</p>
<pre class="line-numbers shell"><code class="language-none">sudo pacman -S fcitx-im
sudo pacman -S fcitx-configtool
sudo pacman -S fcitx-sunpinyin fcitx-cloudpinyin</code></pre>
<p>安装后在<code>~/.xprofile</code>里面加上下列几行启用fcitx</p>
<pre class="line-numbers shell"><code class="language-none">export GTK_IM_MODULE=fcitx
export QT_IM_MODULE=fcitx
export XMODIFIERS=&quot;@im=fcitx&quot;
fcitx -d</code></pre>
<p>最后一行是我自己加上的，因为似乎由于一些原因fcitx它开机不自启……</p>
<h1 id="配置tex">配置TeX</h1>
<p>终于可以开始进入正题了，首先安装TeXLive：</p>
<pre class="line-numbers shell"><code class="language-none">sudo pacman -S texlive-most texlive-langchinese</code></pre>
<p>接着安装Vim Plug，在<code>~/.vimrc</code>里面写入自动安装脚本（手动安装亦可）以及一些基本的配置：</p>
<pre class="line-numbers"><code class="language-vim">set number
set tabstop=4
set softtabstop=4
set shiftwidth=4
set smartindent

syntax on

if empty(glob(&#39;~/.vim/autoload/plug.vim&#39;))
    silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
        \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif</code></pre>
<p>接着安装所必要的VimTeX插件以及UltiSnips插件并进行相关的配置：</p>
<pre class="line-numbers"><code class="language-vim">call plug#begin(&#39;~/.vim/plugged&#39;)

Plug &#39;lervag/vimtex&#39;
let g:tex_flavor=&#39;latex&#39;
let g:vimtex_view_method=&#39;zathura&#39;
let g:vimtex_quickfix_mode=0
set conceallevel=1
let g:tex_conceal=&#39;abdmg&#39;

Plug &#39;sirver/ultisnips&#39;
let g:UltiSnipsExpandTrigger=&#39;&lt;tab&gt;&#39;
let g:UltiSnipsJumpForwardTrigger=&#39;&lt;tab&gt;&#39;
let g:UltiSnipsJumpBackwardTrigger=&#39;&lt;s-tab&gt;&#39;
let g:UltiSnipsSnippetDirectories=[&#39;mysnippets&#39;]

call plug#end()</code></pre>
<p>安装Zathura作为PDF阅读器：</p>
<pre class="line-numbers shell"><code class="language-none">sudo pacman -S zathura zathura-pdf-mupdf</code></pre>
<p>我查到Manjaro i3终端默认的背景色是<code>#222D31</code>，因此在<code>~/.config/zathura/zathurarc</code>里面写入</p>
<pre class="line-numbers"><code class="language-none">set default-bg &quot;#222D31&quot;
set recolor &quot;true&quot;
set recolor-lightcolor &quot;#222D31&quot;
set recolor-darkcolor &quot;#FFFFFF&quot;</code></pre>
<p>这样Zathura打开白色的pdf文档的时候就会自动重新着色，完成了色调上的统一。</p>
<p>Vimtex默认使用<code>latexmk</code>编译，<code>latexmk</code>默认调用<code>pdflatex</code>。因为要用中文我们希望它调用<code>xelatex</code>，于是在<code>~/.latexmkrc</code>里面加上</p>
<pre class="line-numbers"><code class="language-none">$pdf_mode = 1;
$pdflatex = &#39;xelatex --shell-escape %O %S&#39;;</code></pre>
<p>现在随便打开一个tex文档，打出<code>\ll</code>，预览就冒出来了，非常方便。</p>
<h1 id="配置snippets">配置Snippets</h1>
<p>我基本上复制了作者原博客上的大部分snippets的定义。再加上了一些我觉得比较常用的：</p>
<pre class="line-numbers"><code class="language-none">snippet exm &quot;example&quot; bA
\begin&#123;example&#125;
$1
\end&#123;example&#125;
$0
endsnippet

snippet sln &quot;solution&quot; bA
\begin&#123;solution&#125;
$1
\end&#123;solution&#125;
$0
endsnippet

snippet -&gt; &quot;arrow&quot; A
\Rightarrow
endsnippet

snippet sc &quot;since&quot; wA
\because
endsnippet

snippet tf &quot;therefore&quot; wA
\therefore
endsnippet

snippet tx &quot;text&quot; wA
\text&#123;$1&#125;$0
endsnippet

snippet par &quot;()&quot; wA
\left($1\right)$0
endsnippet

snippet pbk &quot;[]&quot; wA
\left[$1\right]$0
endsnippet

snippet pbr &quot;&#123;&#125;&quot; wA
\left\\&#123;$1\right\\&#125;$0
endsnippet

snippet pabs &quot;||&quot; wA
\left|$1\right|$0
endsnippet

snippet enum &quot;enumerate&quot; bwA
\begin&#123;enumerate&#125;
$1
\end&#123;enumerate&#125;
$0
endsnippet

snippet ml &quot;multiline math&quot; bwA
\begin&#123;gather*&#125;
$1
\end&#123;gather*&#125;
$0
endsnippet</code></pre>
<p>笔记源文件的preamable定义如下，使用<code>fleqn</code>选项对所有方程进行左对齐，并定义<code>example</code>和<code>solution</code>环境方便记例题和解答：</p>
<pre class="line-numbers"><code class="language-latex">\documentclass[fleqn]&#123;ctexart&#125;

\usepackage&#123;amsthm&#125;
\usepackage&#123;amsmath&#125;
\usepackage&#123;amssymb&#125;
\usepackage&#123;tikz&#125;

\newtheorem*&#123;solution&#125;&#123;解&#125;
\newtheorem&#123;example&#125;&#123;例&#125;[subsection]

\begin&#123;document&#125;
    \maketitle
    ...
\end&#123;document&#125;</code></pre>
<p>最后的效果如下：</p>
<p><img src="https://s2.ax1x.com/2020/03/02/3RRrp6.png" alt="3RRrp6.png" /></p>
<p>成果：</p>
<p><img src="https://s2.ax1x.com/2020/03/02/3Rojqf.png" alt="3Rojqf.png" /></p>
<p>对比手写版：</p>
<p><img src="https://s2.ax1x.com/2020/03/02/3Ro6PJ.jpg" alt="3Ro6PJ.jpg" /></p>
<p>是不是看起来还不错？</p>
<h1 id="使用感受">使用感受</h1>
<h2 id="优点">优点</h2>
<ul>
<li>格式内容分离，便于重新排版与整理</li>
<li>字体统一美观（自己手写的字实在是太丑了哇）</li>
<li>例题的自动编号很赞！</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li><p>Vim原来就有两个常用的模式，输入法的使用又增加了一个模式。来回shift切换打断了编辑的流畅性，降低了效率。尤其是很多时候输入法还没切回英文就<code>jj</code>一下或者切片段，结果还要删掉，按shift，然后重新打，有的时候着实糟心。</p></li>
<li><p>Snippets多固然增加了效率，但是也增加了记忆的负担。对于我这种新手来说，过多的snippets只是把打LaTeX的时间转换成回忆用哪个snippet比较好的时间，一下子增加太多snippets也会降低效率。</p></li>
<li><p>错字的存在。搜狗输入法对于偶尔的打错具有自动修正的功能，但是无论是谷歌拼音还是sunpinyin在这方面都不行，加上很多时候这些输入法的选词并不智能，一个个看过来选词其实也是非常耗费时间的。</p></li>
<li><p>还是错字，例如“已知”错打成“一直”，英文可以配置spell checker做实时的纠正，这在原文当中也有提到，但是中文目前在这方面还缺乏支持。我听说百度有这方面的接口，但是不知道对于数学笔记专业性这么强的语料效果怎么样。Vim插件我是肯定没找到。</p></li>
<li><p>笔记的结构比较松散，在笔记本上我们可以拿箭头划来划去，有旁注也可以轻松插入，但是这在LaTeX当中绝非易事。很多时候数学笔记的格式很容易让人陷入纠结，比如说我乱打的一段</p>
<blockquote>
<p>设<span class="math inline">\(y=kx+b,\quad (k\neq 0)\)</span></p>
<p><span class="math inline">\(\Rightarrow x=\frac{y-b}{k}\)</span>又因为已知<span class="math inline">\(k=\tan \alpha\)</span>...</p>
</blockquote>
<p>这种格式要怎么排版呢？</p>
<ol type="1">
<li>是整个作为一个大的display style math，中文文字作为<code>\text&#123;&#125;</code>镶嵌其中？</li>
<li>还是一行一个display-style math?</li>
<li>还是有中文字的行用inline math，然后纯数学符号的行用display math?</li>
<li>要不要用<code>gather*</code>这种环境？</li>
</ol>
<p>又比如说如下这段：</p>
<blockquote>
<p><span class="math inline">\(\begin{cases}x=1 \\y=2\end{cases}\)</span>或<span class="math inline">\(\begin{cases}x=2 \\y=1\end{cases}\)</span></p>
</blockquote>
<p>手写起来非常简单，但是LaTeX代码呢？</p>
<pre class="line-numbers"><code class="language-latex">$\begin&#123;cases&#125; x=1 \\ y=2 \end&#123;cases&#125;$
或
$\begin&#123;cases&#125; x=2 \\ y=1 \end&#123;cases&#125;$</code></pre>
<p>一下子复杂了不少，更别说为了中间的“或”字需要输入法切换。这是snippets也难以挽救的低效。</p></li>
<li><p>我还没有试过画图。但是这一定是一个天坑。</p></li>
<li><p>如果编译失败那几乎是当场去世（悲）</p></li>
</ul>
<h1 id="总结">总结</h1>
<p>就我个人体验而言，用LaTeX记笔记虽然能够达到非常高的排版质量，但是并没有传说中的那么高效（尤其是在使用中文的背景之下）。用LaTeX整理笔记自然是极好的，但是用LaTeX在课堂上实时记笔记绝对属于一大作死行为（更别说你也不知道老师收不收LaTeX记得笔记对不？）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chengyuan Ma</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js" integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha512-br8H6OngKoLht57WKRU5jz3Vr0vF+Tw4G6yhNN2F3dSDheq4JiaasROPJB1wy7PxPk7kV/+5AIbmoZLxxx7Zow==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-bash.min.js" integrity="sha512-JvRd44DHaJAv/o3wxi/dxhz2TO/jwwX8V5/LTr3gj6QMQ6qNNGXk/psoingLDuc5yZmccOq7XhpVaelIZE4tsQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-c.min.js" integrity="sha512-T6Lco61aWqCKSznWkd38lf159pD0+EwZ9UCEv6ARAvaWFiy/UHtYgOmlasT8lq5Ck17ZNHzbe5eHUablTGRXxw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cmake.min.js" integrity="sha512-M99z3be36IUB5pA3DWoJvjSYaZA9BiUqf1jXzVcjntASBZFNI53oDRzdJqGzH5voybcAx5Sg8F5QyryE6afD3g==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cpp.min.js" integrity="sha512-hxZJ6OUEpUl9/o4C1gMGvrAbeqDaldBiZbs08c/V8NcU7YImBFlqJAc7Uzjf3bh2W8Wx26/dVDyPk9cUMQY0Mw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-go.min.js" integrity="sha512-SgF1uayJ2/8TV+MhLasqygnm++vYRXswmrR2ZAmUCL4pXtf+6KzUgXPpn10Y6xca658sxOQEOsoP3MChfhke5A==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-java.min.js" integrity="sha512-PWHY6Vao4E9K4LsGBYCY0ttDeiWZwuUozTbJvSy9UFHRz2J4Bl7rcWML3wEnJTVuCJhSwGne/8My5gTo/gnbpg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-json.min.js" integrity="sha512-IC7rV8RslChgByOdUFC6ePqOGn+OwJhnKC3S5AezM8DAiOdGhJMwgsIvBChsa2yuxxoPbH2+W/kjNUM1cc+jUQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-kotlin.min.js" integrity="sha512-aTozTdtORp/xxS/dhRRDfmv/p1eyEMTje96MplkSOqdbKGGvOYIlogoGdtsh/BD91vaqKoAw9M7O/DodqqudIQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-julia.min.js" integrity="sha512-eTGeKQdDzC2rPAUVfM2Fa36s9B9wp138NEhzZqJpRSdJQ66BwLUot25r2YQveCRU5uYNVfX3gckDkl4byfBIWw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-latex.min.js" integrity="sha512-6D3l3Fy8g/hr6AeK2g1rcVZHyFjCqiqgUrwy0mBZTGFd8UwVcUDhzQeIIv3eYeXDecGPTtBOS9ctyRzJyUgypQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-rust.min.js" integrity="sha512-kgT7r2HlCEO4b+Rp3nJvm+/EMBwGMvv1WMdWkb3eNgnS91llMli8Y3T1CgnD8Hifqx50Q3XLUQXDd7PzKQQtUA==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-python.min.js" integrity="sha512-wK9tQmDrstGtZqTKcyVf3h457QGMlNriKs+fHmEkiCizrq0LVovfT3v1smeT1DlQetHhdRkkX1JSuZg5LoNHJg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-nginx.min.js" integrity="sha512-/MNzg8GlnVrAau/TZClh1jxgHNX0HDgidbGnHS5x1OtbKiNoK3e0XNd1oV16xmmeDHjisa3GKLArUau+43GZ4A==" crossorigin="anonymous"></script>
<script type = "text/javascript">
    document.addEventListener('pjax:complete', function() {
        if (typeof Prism !== 'undefined') {
            Prism.highlightAll();
        }
    });
</script>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  






  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    <div class="pjax">

  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



    </div>
</body>
</html>
