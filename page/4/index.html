<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"alan20210202.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="不务正业高中生一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="Chengyuan Ma&#39;s Blog">
<meta property="og:url" content="https://alan20210202.github.io/page/4/index.html">
<meta property="og:site_name" content="Chengyuan Ma&#39;s Blog">
<meta property="og:description" content="不务正业高中生一枚">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chengyuan Ma">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://alan20210202.github.io/page/4/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.css" integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbggqjHJeyzx88I3rfwjS38WJag/ihH7lzuGlGHpDBymLirZQ==" crossorigin="anonymous" />
<title>Chengyuan Ma's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-65HSG5NCY6"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-65HSG5NCY6');
      }
    </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Chengyuan Ma's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-pagedewarp"><a href="/dewarp/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>PageDewarp</a></li>
        <li class="menu-item menu-item-english"><a href="/english/" rel="section"><i class="fa fa-globe-americas fa-fw"></i>English</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chengyuan Ma"
      src="/avatar.png">
  <p class="site-author-name" itemprop="name">Chengyuan Ma</p>
  <div class="site-description" itemprop="description">不务正业高中生一枚</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">86</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://kalasearch.cn/" title="https:&#x2F;&#x2F;kalasearch.cn&#x2F;" rel="noopener" target="_blank">卡拉搜索</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/02/23/PyMinecraft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/23/PyMinecraft/" class="post-title-link" itemprop="url">用Python非侵入式自动化原版Minecraft</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-02-23 19:16:19 / 修改时间：20:34:39" itemprop="dateCreated datePublished" datetime="2020-02-23T19:16:19+08:00">2020-02-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>似乎博客又有一个月没有更了呢<del>而且一个月前挖的坑似乎还没有填完? 持续咕咕咕</del></p>
<p>我前几天玩Minecraft挖矿的时候我就一直在思考一个问题</p>
<blockquote>
<p>如何自动化MC里面像挖矿这么无脑的操作呢？</p>
</blockquote>
<p>其实现成的想法还是很多的：</p>
<ol type="1">
<li>用粘液块和红石（Slimestone）实现半自动化（例如SciCraft里面的盾构）。SciCraft用这个方法挖了103000颗钻石，优点是纯原版，缺点是其实还是很肝，而且技术性非常强。</li>
<li>利用mod的解决方案：像IC2，Mekanism这些mod其实都有自动化的解决方案。优点是比较简单。缺点是非原版，通用性比较差，而且自动挖矿在这些mod里面基本上也是大后期了，搭这一套措施很肝。</li>
<li>利用客户端mod的解决方案：利用FreeCam或者透视这种客户端mod可以在服务端原版的情况下达到类似自动化的效果，但是缺点是这个是作弊。</li>
<li>Carpet Mod：这个mod的<code>/player</code>命令是在服务端生成一个假的玩家实体并进行操作，好处就是简单，快捷，不会掉线。而且Carpet现在搭了Fabric的顺风车更新得非常勤快。缺点就是服务端要装Carpet，如果不是自己开服基本用不了，而且说实话Carpet的自动化比较简单（本来是配合SciCraft那一套设计的）。</li>
<li><a target="_blank" rel="noopener" href="http://minerl.io/">MineRL</a>：直接利用强化学习解决一切自动化问题。优点是几乎啥都可以干，缺点是技术含量非常非常高，而且训练的硬件要求非常高。说实话我觉得是overkill。</li>
</ol>
<p>这些方案各有优缺点，其实对于我这种玩偶尔玩第三方服务器的人2、3、4基本上就可以否决掉了，1的话门槛比较高，5的话没有那硬件资源。所以这几天我自己试验了一个适合我需求的方案，还算不错。</p>
<h1 id="初步设计">初步设计</h1>
<p>简单来说呢，我的想法是这个样子的</p>
<ol type="1">
<li>不断截取游戏窗口</li>
<li>通过OCR读取F3界面的字符</li>
<li>获得玩家的位置</li>
<li>通过闭环控制器控制玩家行动</li>
<li>通过模拟键盘和鼠标事件来进行实际的控制</li>
</ol>
<p>这个解决方案和MineRL靠的比较近，都是比较贴近于实际玩游戏的过程。我最看重的一个有点就是这个解决方案完全不需要修改客户端，而且因为F3界面格式万年不变而且从很早版本就有了导致这个解决方案的版本兼容性超强，即使是玩第三方服务器第三方客户端也丝毫不虚。那么剩下来的就是用Python实现这一连串过程了。</p>
<h1 id="用到的第三方库">用到的第三方库</h1>
<pre class="line-numbers"><code class="language-python">import cv2 as cv
import numpy as np

import win32gui
import win32ui
import win32con

import keyboard
import mouse</code></pre>
<p>上面是图像处理标准操作，中间是Win32标准操作，下面是鼠标和按键模拟用的（其实用win32api也可以解决，但是我还是想保留一点OS兼容性）。</p>
<h1 id="游戏窗口截取">游戏窗口截取</h1>
<p>因为我用的是Windows所以这个部分理所应当地用Pywin32来做，我个人对于Win32 API不是特别地熟悉（常年面向MSDN编程），Pywin32做接口之后就更搞不清楚了，于是上网上东抄抄西抄抄就做完了。我把这部分代码理了一下，通用性还是比较高的。</p>
<pre class="line-numbers"><code class="language-python">Hwnd = int

def get_window_with_title(keyword: str) -&gt; Hwnd:
    &quot;&quot;&quot;
    Gets the first window whose title contains the keyword, if any
    !!! WIN 32 ONLY !!!
    :param keyword: the keyword
    :return: the first window whose title contains keyword, None if not found
    &quot;&quot;&quot;

    def callback(hwnd: Hwnd, extra: List[Hwnd]):
        if win32gui.IsWindowVisible(hwnd) and win32gui.IsWindowEnabled(hwnd) \
                and keyword in win32gui.GetWindowText(hwnd):
            extra.append(hwnd)

    ret: List[Hwnd] = []
    win32gui.EnumWindows(callback, ret)
    return ret[0] if ret else None


def capture_screen_of(hwnd: Hwnd, rect=None) -&gt; np.ndarray:
    &quot;&quot;&quot;
    Capture screen of hwnd, using win32 API
    !!! WIN 32 ONLY !!!
    :param hwnd: the window handle
    :param rect: the rectangle, default value None, which means to capture the whole window
    :return: the screen capture (RGBA) in numpy array format
    &quot;&quot;&quot;
    window_dc = win32gui.GetWindowDC(hwnd)
    dc_object = win32ui.CreateDCFromHandle(window_dc)
    compat_dc = dc_object.CreateCompatibleDC()
    bitmap = win32ui.CreateBitmap()
    if not rect:
        rect = win32gui.GetWindowRect(hwnd)
        rect = (0, 0, rect[2] - rect[0], rect[3] - rect[1])
    width, height = rect[2] - rect[0], rect[3] - rect[1]
    start = (rect[0], rect[1])
    bitmap.CreateCompatibleBitmap(dc_object, width, height)
    compat_dc.SelectObject(bitmap)
    compat_dc.BitBlt((0, 0), (width, height), dc_object, start, win32con.SRCCOPY)
    img = np.frombuffer(bitmap.GetBitmapBits(True), dtype=&#39;uint8&#39;)
    img.shape = (height, width, 4)
    dc_object.DeleteDC()
    compat_dc.DeleteDC()
    win32gui.ReleaseDC(hwnd, window_dc)
    win32gui.DeleteObject(bitmap.GetHandle())
    return img</code></pre>
<p>（出于常年写静态语言的习惯还是加上了type annotation）</p>
<h1 id="ocr">OCR</h1>
<p>这是最头大的部分了，我一开始的想法非常天真：Tesseract OCR，G家这么好的轮子不用干啥。结果</p>
<ol type="1">
<li>Tesseract下载下来好几十MB，这瞬间让整个项目的dependencies复杂了起来。</li>
<li>Tesseract似乎很慢，跑一次F3界面要跑0.5秒，我这算法要是按照2FPS的速度跑那玩家的反射弧要长出天际了。其实考虑到Tesseract很多都是在用LSTM这种速度也不奇怪。</li>
<li>Tesseract对于Minecraft默认像素风字体的支持不好。如果要提升效果就要额外train。</li>
</ol>
<p>这三个因素加起来最终还是把Tesseract枪毙了。Python常见的OCR解决方案似乎只有这一家，所以只能自己设计OCR算法了。</p>
<p>其实在我的这个场景里OCR的要求不高，因为</p>
<ol type="1">
<li>因为是截屏所以像素亮度很平整，也不会有扭曲或者畸变</li>
<li>我可以获取到Minecraft的字体文件</li>
</ol>
<p>这两个因素在一起让这里的OCR退化成了template matching。</p>
<p>从客户端<code>jar</code>文件里提取出来字体文件本身不是一件特别复杂的事，唯一可能复杂一点的地方就是要把字体位图当中透明色变成灰色：</p>
<pre class="line-numbers"><code class="language-python">font_atlas_file = &quot;unicode_page_00.png&quot; # Minecraft的Unicode字体位图
font_atlas = cv.imread(font_atlas_file, cv.IMREAD_UNCHANGED)
font_atlas = cv.threshold(font_atlas[:, :, 3], 127, 255, cv.THRESH_BINARY)[1]</code></pre>
<p>接下来是文字提取。经过我的测试Minecraft的F3界面文字在灰度图像下的前景色在<code>220-225</code>左右非常固定，而且文字背后半透明灰色的遮罩使文字的周围不会出现干扰。这样提取文字部分只需要threshold一下就解决了，运用OpenCV的代码非常简短：</p>
<pre class="line-numbers"><code class="language-python">f3_color = (221, 225)
...
# cap是截图
img = cv.cvtColor(cap, cv.COLOR_BGR2GRAY if cap.shape[2] == 3 else cv.COLOR_BGRA2GRAY)
img = cv.threshold(img, f3_color[1], 255, cv.THRESH_TOZERO_INV)[1]
img = cv.threshold(img, f3_color[0] - 1, 255, cv.THRESH_BINARY)[1]</code></pre>
<p>接下来只要对于字符集当中的每一个文字，从字体位图里面找到点阵字体然后跑模板匹配就行了</p>
<pre class="line-numbers"><code class="language-python">chars: List[Tuple[int, int, str]] = []
for ch in charset:
    font = bitmap_fonts[ord(ch)]
    x = cv.matchTemplate(img, font, cv.TM_CCORR_NORMED)
    # noinspection PyTypeChecker
    chars.extend(zip(*np.where(x &gt; match_threshold), repeat(ch)))</code></pre>
<p>最后是把识别出来的单个字符串联成行。这一部分的主要思路是把纵坐标在一定范围内的字符按照横坐标排序然后顺次拼接就行了。下面的代码还可以做亿点优化，但是这一部分不是本算法的瓶颈（上面的模式匹配才是），所以我懒了：</p>
<pre class="line-numbers"><code class="language-python">img_width = img.shape[1]
chars.sort(key=lambda tup: tup[0] * img_width + tup[1])
last_y = -1 - max_line_height_deviation
lines: List[List[Tuple[int, int, str]]] = []
for ch in chars:  
    if ch[0] - last_y &gt; max_line_height_deviation:
        last_y = ch[0]
        lines.append([])
    lines[-1].append(ch)
ret: List[str] = []
for line in lines: 
    line_str: str = &quot;&quot;
    error = True
    for (i, ch) in enumerate(line):
        if i &gt; 0 and ch[1] - line[i - 1][1] &gt; whitespace_width:  
            line_str += &#39; &#39;
        line_str += ch[2]
        error &amp;= ch[2] in [&#39;.&#39;, &#39;-&#39;, &#39;_&#39;]  
    if not error:
            ret.append(line_str)
return ret</code></pre>
<p>注意要集中处理的是有些字符会因为字体的原因容易被错误识别，例如<code>.</code>, <code>_</code>, <code>-</code>(后两个在MC的字体里面根本就是一样的)。这一部分要去除。同时因为空格无论怎么样都不会被模板匹配识别出来，所以要通过字间距的差别来插入。</p>
<p>这个算法的运行时间是和字符集大小成正比的，因此字符集的精简很重要。在这里我其实只采用了<code>0123456789XYZFLa./-</code>这些字符，这些数字和符号确保可以正常识别数字，<code>XYZ</code>确保可以识别坐标，<code>Fa</code>确保可以识别朝向（<code>Facing</code>），<code>L</code>确保可以识别指向（<code>Looking at</code>）。总体来说这一部分的算法虽然简陋但是堪堪够用。在精简字符集后可以跑到20FPS，已经是Tesseract的10倍多了。</p>
<p>在试验过程中比较有意思的一个发现是Minecraft的默认ASCII字体渲染是一个比较复杂的过程，似乎不是按照<code>ascii.png</code>上的内容直接来的（我的理解是似乎加了一些hint），导致模板匹配的思路在ASCII字体的时候是行不通的，必须在设置里面强制开启Unicode字体。</p>
<h1 id="读取玩家信息">读取玩家信息</h1>
<p>在OCR之后读取玩家信息就是水到渠成的事情了。我的OCR已经把行都划好了，只需要选取特定字符开头的行做一下字符串分割和parse就完成了。</p>
<h1 id="闭环控制">闭环控制</h1>
<p>最后一步当然是通过一个闭环控制器来控制玩家的运动。这一部分出于我在机器人社的经验我糊了一个P controller <del>ID部分懒得写了</del>来控制玩家的朝向，再写了个bang bang control来控制玩家的XZ坐标（在生存模式下Y坐标一般来说是控制不了的）。稍微比较烦的地方就是MC对于方位角的表示方式，需要一些分类讨论和转换。控制频率100Hz，效果差强人意，已经足够作为一个proof-of-concept了：</p>
<pre class="line-numbers"><code class="language-python">def control_thread_func(coord_tol: float = 0.5, yaw_tol: float = 2, pitch_tol: float = 2):
    &quot;&quot;&quot;
    The control thread. If abs(error_target) &lt;= x_target, then the target will be considered reached
    :param coord_tol: coordinate tolerance
    :param yaw_tol: yaw tolerance
    :param pitch_tol: pitch tolerance
    :return: runs forever
    &quot;&quot;&quot;
    kp_yaw, kp_pitch = 0.5, 0.4 
    global target_yaw
    global target_pitch
    global reached_yaw
    global reached_pitch
    global reached_coord
    w, a, s, d = False, False, False, False # 记录WASD四个键状态
    move_threshold = 0.5 # 如果在一个坐标分量上的偏差小于这个值那就不按这个分量上的按键了
    turn_threshold = 1.5 # 每一次鼠标至少要动这么多

    def key_cond(val, key, cond):
        if val and not cond:
            keyboard.release(key)
            return False
        if not val and cond:
            keyboard.press(key)
            return True
        return val

    while True:
        if not in_control or not player_info:
            time.sleep(0.05)
            continue

        yaw, pitch = player_info.facing
        coord = xyz2xz(player_info.coord)

        # 坐标控制
        error_coord = math.hypot(target_coord[0] - coord[0], target_coord[1] - coord[1])
        reached_coord = error_coord &lt; coord_tol
        theta = math.atan2(target_coord[0] - coord[0], target_coord[1] - coord[1])
        ws = math.cos(theta + math.radians(yaw)) * error_coord
        ad = math.sin(theta + math.radians(yaw)) * error_coord
        w = key_cond(w, &quot;w&quot;, ws &gt; move_threshold)
        s = key_cond(s, &quot;s&quot;, ws &lt; -move_threshold)
        a = key_cond(a, &quot;a&quot;, ad &gt; move_threshold)
        d = key_cond(d, &quot;d&quot;, ad &lt; -move_threshold)

        # 摄像头朝向控制
        target_pitch = max(-90, min(90, target_pitch))
        if auto_yaw and not reached_coord: 
            target_yaw = -math.degrees(math.atan2(target_x - x, target_z - z))
        if target_yaw &gt; 180:
            target_yaw -= 180
        if target_yaw &lt; -180:
            target_yaw += 180
        error_yaw = target_yaw - yaw
        if abs(error_yaw - 360) &lt; abs(error_yaw):
            error_yaw -= 360
        if abs(error_yaw + 360) &lt; abs(error_yaw):
            error_yaw += 360
        error_pitch = target_pitch - pitch
        reached_yaw = abs(error_yaw) &lt; yaw_tol
        reached_pitch = abs(error_pitch) &lt; pitch_tol
        if not reached_yaw:
            d_yaw = kp_yaw * error_yaw
            if abs(d_yaw) &lt; turn_threshold:
                d_yaw = math.copysign(turn_threshold, error_yaw)
        else:
            d_yaw = 0
        if not reached_pitch:
            d_pitch = kp_pitch * error_pitch
            if abs(d_pitch) &lt; turn_threshold:
                d_pitch = math.copysign(turn_threshold, error_pitch)
        else:
            d_pitch = 0
        mouse.move(d_yaw, d_pitch, absolute=False)

        time.sleep(0.01)</code></pre>
<h1 id="测试">测试</h1>
<p>写完之后我写了一个简单的挖矿脚本，可以挖1x2的矿道并且插上火把点亮：</p>
<pre class="line-numbers"><code class="language-python">def wait_turn():
    time.sleep(0.01)
    while player_info and (not reached_yaw or not reached_pitch):
        time.sleep(0.05)


def wait_coord():
    time.sleep(0.01)
    while player_info and not reached_coord:
        time.sleep(0.05)

def start_mining():
    global in_control
    global target_coord
    global target_yaw
    global target_pitch
    if player_info is None:
        return
    if player_info.target_block is None:
        return
    direction = xyz2xz(player_info.target_block - np.floor(player_info.coord))
    target_coord = xyz2xz(player_info.coord)
    target_yaw = -math.degrees(math.atan2(direction[0], direction[1]))
    in_control = True
    target_pitch = 0
    moved = 0
    wait_turn()
    try:
        while True:
            moved += 1
            mouse.press() # 开始挖摄像头正对的方向
            while np.linalg.norm(xyz2xz(player_info.target_block - np.floor(player_info.coord))) &lt; 1.:
                time.sleep(0.01)
            mouse.release() # 挖完了
            if moved % 5 == 0: # 每挖五格就插一个火把（在副手）
                target_yaw += 30
                wait_turn()
                mouse.right_click()
                time.sleep(0.1)
                target_yaw -= 30
            target_pitch = 40 # 低头
            wait_turn()
            mouse.press() # 开始挖下面的那一格
            while np.linalg.norm(xyz2xz(player_info.target_block - np.floor(player_info.coord))) &lt; 1.:
                time.sleep(0.01)
            mouse.release()
            target_coord = xyz2xz(np.floor(player_info.coord)) + np.array([0.5, 0.5]) + 0.7 * direction # 前进！
            target_pitch = 0 # 双眼平视前方
            wait_turn()
            wait_coord()
    except Exception:
        in_control = False
        mouse.release()
        print(&quot;exit&quot;)
        return
</code></pre>
<p>这个脚本运行的非常顺畅（虽然并不总是成功，这和玩家坐标控制的精度有很大关系）。已经初步有了实用价值。看起来我这个技术路线总体还是可行的。当然现在的功能非常简陋，但是F3的信息非常丰富，如果拓展一下用途还是非常丰富的。当然最重要的还是这个脚本可以适用于所有有F3界面的Minecraft版本，版本兼容性堪称完美，爽到。</p>
<p><del>写这个脚本花了2个小时，就是为了挖一个简单的矿，这么算来似乎有点亏？！</del></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/01/28/%E7%BB%84%E5%90%88%E6%81%92%E7%AD%89%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/28/%E7%BB%84%E5%90%88%E6%81%92%E7%AD%89%E5%BC%8F/" class="post-title-link" itemprop="url">论一个有趣组合恒等式的证明</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-01-28 20:33:26 / 修改时间：20:33:03" itemprop="dateCreated datePublished" datetime="2020-01-28T20:33:26+08:00">2020-01-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题">问题</h1>
<p>前几天在做探究性题目的时候碰到了一个组合恒等式： <span class="math display">\[
\sum_{k=1}^nk2^k\binom{2n-k-1}{n-1}=n\binom{2n}{n}
\]</span> 这个恒等式的右边最初是Mathematica给出的，当时把就我惊到了，一开始想用combinatorial proof的方法来证，但是想了两个晚上也想不出，自己的数学实在是太烂啦=_= 之后在翻《具体数学》的时候学了一点超几何函数的皮毛，总算使用超几何的方法诡异地证出来了。我又在Math StackExchange上发帖征集了一些初等的证明，在这里做一个汇总。</p>
<h1 id="初等证明">初等证明</h1>
<p><strong>引理1：</strong> <span class="math display">\[
\sum_{k=n}^{2n}2^{-k}\binom{k}{n}=1
\]</span> <strong>证明：</strong>源于<a target="_blank" rel="noopener" href="https://math.stackexchange.com/questions/1782432/how-to-prove-that-sum-i-0n-2i-binom2n-in-4n">这个帖子</a>。这个式子等价于： <span class="math display">\[
\sum_{k=n}^{2n}2^{2n-k}\binom{k}{n}=4^n \Rightarrow \sum_{k=0}^{n}2^{k}\binom{2n-k}{n}=4^n
\]</span> 利用数学归纳法，令 <span class="math display">\[
\begin{aligned}
    S_n&amp;=\sum_{k=0}^{n}2^{k}\binom{2n-k}{n}\\
    &amp;=\sum_{k=0}^{n}2^{k}\binom{2n-k}{n-k} \\
    &amp;=\sum_{k=0}^{n}2^{n-k}\binom{n+k}{n}
\end{aligned}
\]</span> 于是 <span class="math display">\[
\begin{aligned}
    S_{n+1} &amp;= \sum_{k=0}^{n+1}2^{n+1-k}\binom{n+1+k}{n+1} \\
    &amp;= \sum_{k=0}^{n+1}2^{n+1-k}\left[\binom{n+k}{n+1} + \binom{n+k}{n}\right] \\
    &amp;= \binom{2n+1}{n} + 2\sum_{k=0}^{n}2^{n-k}\binom{n+k}{n} + \sum_{k=0}^{n+1}2^{n+1-k}\binom{n+k}{n+1}\\
    &amp;= \binom{2n+1}{n} + 2S_n + \binom{2n+1}{n+1} + \sum_{k=1}^{n}2^{n+1-k}\binom{n+k}{n+1} \\
    &amp;= \binom{2n+2}{n+1} + 2\cdot4^n + \sum_{k=0}^{n-1}2^{n-k}\binom{n+1+k}{n+1} \\
    &amp;= \binom{2n+2}{n+1} + 2\cdot4^n + \frac{1}{2}\left[\sum_{k=0}^{n+1}2^{n+1-k}\binom{n+1+k}{n+1}-2\binom{2n+1}{n+1}-\binom{2n+2}{n+1}\right] \\
    &amp;= 2\cdot4^n + \frac{1}{2}S_{n+1} \\
    \Rightarrow S_{n+1}&amp;=4^{n+1}
\end{aligned}
\]</span></p>
<p>结合数学归纳法，得证。</p>
<p><strong>引理2：</strong> <span class="math display">\[
\sum_{p=m}^{2m}p2^{-p}\binom{p}{m} = (2m+1)-\frac{m+1}{2^{2m+1}}\binom{2m+2}{m+1}
\]</span> <strong>证明：</strong>源于<a target="_blank" rel="noopener" href="https://math.stackexchange.com/questions/3508530/help-in-summing-sum-k-m-2m-k-cdot-2-k-k-choose-m/3508683#3508683">这个帖子</a>。 <span class="math display">\[
\begin{aligned}
\sum_{p=m}^{2m}p2^{-p}\binom{p}{m} &amp;= \sum_{p=m}^{2m}(p+1)2^{-p}\binom{p}{m} -\sum_{p=m}^{2m}2^{-p}\binom{p}{m} \\
&amp;= \sum_{p=m}^{2m}(m+1)2^{-p}\binom{p+1}{m+1} - 1\\
&amp;= (m+1) \left[2\sum_{p+1=m+1}^{2m+2}2^{-(p+1)}\binom{p+1}{m+1}-2^{-2m-1}\binom{2m+2}{m+1}\right] - 1 \\
&amp;= (m+1)\left[2-\frac{1}{2^{2m+1}}\binom{2m+2}{m+1}\right] - 1\\
&amp;= (2m+1)-\frac{m+1}{2^{2m+1}}\binom{2m+2}{m+1}
\end{aligned}
\]</span> 得证。</p>
<p><strong>原式证明：</strong>结合引理1和2，令<span class="math inline">\(m=n-1,p=2n-k-1\)</span>： <span class="math display">\[
\begin{aligned}
    \sum_{k=1}^nk2^k\binom{2n-k-1}{n-1}&amp;=\sum_{p=m}^{2m}(2m+1-p)2^{2m+1-p}\binom{p}{m} \\
    &amp;=2^{2m+1}\sum_{p=m}^{2m}(2m+1-p)2^{-p}\binom{p}{m} \\
    &amp;= 2^{2m+1}\left[(2m+1)-(2m+1)+\frac{m+1}{2^{2m+1}}\binom{2m+2}{m+1}\right] \\
    &amp;= (m+1)\binom{2m+2}{m+1}\\
    &amp;= n\binom{2n}{n}
\end{aligned}
\]</span> 整个证明神乎其技，学不来学不来，感觉自己实在是太菜了。</p>
<h1 id="生成函数证明">生成函数证明</h1>
<p>帖子里有，看起来非常短，我对于生成函数还不熟练，积极学习中~TODO: 看懂了整理上来。</p>
<h1 id="组合证明">组合证明</h1>
<p>帖子里有，看起来非常不短，似乎用了很多non-trivial的论证方法，试图理解中~TODO: 看懂了整理上来。</p>
<h1 id="超几何证明">超几何证明</h1>
<p>这个证明是我在翻《基础数学》看到超几何函数那一节的时候想的，是这四个证明中唯一一个我原创的证明（悲）。用到了超几何函数，蒟蒻高中生感觉非常炫酷.jpg</p>
<p>首先把等式左边改成无限求和： <span class="math display">\[
\begin{aligned}
\sum_{k=1}^{n}k2^k\binom{2n-d-1}{n-1} &amp;= \sum_{k=1}^{n}k2^k\binom{2n-k-1}{n-k} \\
&amp;= \sum_{k=1}^{\infty}k2^k\binom{2n-k-1}{n-k} \\
&amp;= \sum_{k=0}^{\infty}(k+1)2^{k+1}\binom{2n-k-2}{n-k-1}
\end{aligned}
\]</span> 若令<span class="math inline">\(t_k=(k+1)2^{k+1}\binom{2n-k-2}{n-k-1}\)</span>，则观察到： <span class="math display">\[
\begin{aligned}
\frac{t_{k+1}}{t_k} &amp;= \frac{(k+2)2^{k+2}\binom{2n-k-3}{n-k-2}}{(k+1)2^{k+1}\binom{2n-k-2}{n-k-1}} \\
&amp;= \frac{2(k+2)[k+(1-n)]}{(k+1)[k+(2-2n)]} \\
\end{aligned}
\]</span> 是一个关于<span class="math inline">\(k\)</span>的有理式，因此引入高斯超几何函数： <span class="math display">\[
\begin{aligned}
\mathrm{LHS} &amp;=t_0\cdot {}_2F_1(2,1-n;2-2n;2)\\
&amp;=2\binom{2n-2}{n-1} {}_2F_1(2,1-n;2-2n;2)
\end{aligned}
\]</span> 考虑化简超几何项，利用如下Kummer二次变换（他1836年论文的Eq.54）： <span class="math display">\[
{}_2F_1(a,b;2b;z)=\frac{1}{(1-z)^{a/2}}{}_2F_1\left(\frac{1}{2}a,b-\frac{1}{2}a;b+\frac{1}{2};\frac{z^2}{4z-4}\right)
\]</span> 则得到： <span class="math display">\[
{}_2F_1(2,1-n;2-2n;2)=-{}_2F_1(1,-n;\frac{3}{2}-n;1)
\]</span> 因为都是实参数且<span class="math inline">\(1-n&lt;\frac{3}{2}-n\)</span>，因此运用高斯定理： <span class="math display">\[
\begin{aligned}
{}_2F_1(1,-n;\frac{3}{2}-n;1) &amp;= \frac{\Gamma\left(\frac{3}{2}-n\right)\Gamma\left(\frac{1}{2}\right)}{\Gamma\left(\frac{1}{2}-n\right)\Gamma\left(\frac{3}{2}\right)} \\
&amp;= 2\left(\frac{1}{2}-n\right) \\
&amp;= 1-2n
\end{aligned}
\]</span> 一路代回去： <span class="math display">\[
\begin{aligned}
\mathrm{LHS} &amp;= 2\binom{2n-2}{n-1} {}_2F_1(2,1-n;2-2n;2) \\
&amp;= 2(2n-1)\binom{2n-2}{n-1} \\
&amp;= 2n\binom{2n-1}{n-1} \\
&amp;= n\binom{2n}{n} = \mathrm{RHS}
\end{aligned}
\]</span> 证毕。</p>
<p>整个证明过程颇有一种高射炮打蚊子的既视感。超几何函数各种公式一大堆还千奇百怪，套就完事了，然而无论是Kummer的二次变换还是高斯定理我都不知道怎么证（悲）。 我已经把Ahlfors的Complex Analysis存起来了，决定有空看看（不知道会不会有这方面的内容）。</p>
<p>嘛，在初等证明存在的情况下，用这种严重超纲的做法只能给人一种装逼的错觉<del>虽然我感觉有点开心？</del>，别人看你搞不好都跟关爱智障一样。MSE上果然大佬太多，向大佬低头.jpg。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/01/22/JuliaPlots/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/22/JuliaPlots/" class="post-title-link" itemprop="url">让Plots.jl支持中文标题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-01-22 17:36:08 / 修改时间：20:25:19" itemprop="dateCreated datePublished" datetime="2020-01-22T17:36:08+08:00">2020-01-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Julia Plots啥都好，就是原生对于Unicode的支持还不完善（可见用Julia的国人似乎不多）。这篇文章简要汇总一下几个不同的backend对于中文的workaround。</p>
<h1 id="gr-backend">GR Backend</h1>
<p>GR在支持Unicode字符上进展感觉其实不积极。具体可以看<a target="_blank" rel="noopener" href="https://github.com/jheinen/GR.jl/issues/143">这个issue</a>，修了一年还是没有比较好的成果（作者说是一个extensive patch...估计一开始在架构里写死了），只修到了支持Latin-1的地步，目前提供的临时解决方案是：</p>
<pre class="line-numbers"><code class="language-julia">ENV[&quot;GKS_ENCODING&quot;]=&quot;utf-8&quot;
using Plots</code></pre>
<p>在Windows上实测对于png格式的图片还是不行，但是对于SVG是可以的（但是因为计算布局的时候字符串长度算的是有问题的，所以legend的框会偏小）。</p>
<h1 id="pyplot-backend">PyPlot Backend</h1>
<p>PyPlot背后调用的是matplotlib，因此PyPlot默认对于中文的支持不利主要也来自于matplotlib对中文的支持问题。对于后者网上改<code>rcParams</code>的解决方案已经比较普及了。在Julia里面，我们只需要把<code>rcParams</code>暴露出来改就行了：</p>
<pre class="line-numbers"><code class="language-julia">using Plots
pyplot()
rcParams = Plots.PyCall.PyDict(Plots.PyPlot.matplotlib.&quot;rcParams&quot;)
rcParams[&quot;font.sans-serif&quot;] = [&quot;Sarasa UI SC&quot;]
rcParams[&quot;axes.unicode_minus&quot;] = false</code></pre>
<p>其中的<code>"Sarasa UI SC"</code>可以替换成电脑上安装的中文字体。这样中文标题就一点问题也没有了，但是似乎在Juno里面PyPlot画出来的图不会自动缩放，令强迫症稍微感到一丝不适。</p>
<h1 id="plotlyjs-backend">PlotlyJS Backend</h1>
<p>原生支持。</p>
<h1 id="inspectdr-backend">InspectDR Backend</h1>
<p>原生支持。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/01/14/WebAssembly/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/14/WebAssembly/" class="post-title-link" itemprop="url">WebAssembly初体验</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-01-14 13:16:58 / 修改时间：21:40:13" itemprop="dateCreated datePublished" datetime="2020-01-14T13:16:58+08:00">2020-01-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我在之前用JavaScript实现了PageDewarp的核心算法。但是众所周知，JavaScript作为一门解释性语言并不适合运算密集型的任务，导致算法运行一次要30秒钟……这个效率虽然不能算特别差，我还是不满意的。所以又花了两天学习了WebAssembly把瓶颈算法用C重写了，现在在手机端一次也只需要1秒左右，效果自然是极好的。但是WebAssembly毕竟还是新科技，和现有的一些框架融合的确实不算好，在应用的过程中踩了非常多的坑，尤其是对于我这种1个月前还是Web萌新的人更是新坑老坑一起踩到怀疑人生（悲）。</p>
<h1 id="webassembly-emscripten">WebAssembly &amp; Emscripten</h1>
<p>什么是WebAssembly？</p>
<p>WebAssembly是一种通过将静态的系统编程语言（比如说C，C++，Rust）AOT编译成一种基于栈虚拟机架构的字节码，然后在浏览器端再次实时JIT执行，来逼近这些语言native performance的技术。</p>
<p>(<em>吐槽：</em>我最初看到WebAssembly的时候有一种莫名的，很强烈的Java Applet的既视感。)</p>
<p>和CLR类似，WebAssembly只是字节码的标准，至于将特定语言编译成字节码的实现则是那些语言自己的事情。在目前的生态下，C和C++有名为Emscripten的基于LLVM的编译器，Rust则有它们自己的一套toolchain，两者都处于勉强凑活的水平。</p>
<p>就我个人而言我其实觉得Rust在这方面做得最好，官方维护，官方文档。wasm_bindgen也给自定义数据结构类型提供了很好的支持，非常适合大项目开发。但是我只是实现一个小算法，Rust的那一套太重了，有一种boilerplate会比真正代码多的预感，所以我最终选择了C（至于为什么不是C++，那是因为name mangling已经破坏了我对它FFI能力产生了非常深的心理阴影）。</p>
<p>前面说了，C对接WebAssembly的工具链是Emscripten。现在Emscripten的生态已经相对比较成熟了，跟着官方的<a target="_blank" rel="noopener" href="https://emscripten.org/docs/getting_started/downloads.html">Getting Started</a>走基本上就没有问题。写C的时候就按照正常的写法（我感觉Emscripten对于libc里面的大多数常用函数都做了适配）写就可以了。算法的代码很短：</p>
<pre class="line-numbers"><code class="language-c">#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;emscripten.h&gt;

typedef struct v3 &#123;
    float x, y, z;
&#125; v3;
v3 add(v3 a, v3 b) &#123;
    return (v3) &#123; .x = a.x + b.x, .y = a.y + b.y, .z = a.z + b.z &#125;;
&#125;
v3 mul(v3 a, float k) &#123;
    return (v3) &#123; .x = a.x * k, .y = a.y * k, .z = a.z * k &#125;;
&#125;
v3 a2v(float *a) &#123;
    return (v3) &#123; .x = a[0], .y = a[1], .z = a[2] &#125;;
&#125;
EMSCRIPTEN_KEEPALIVE
unsigned char *dewarp(
        unsigned char *src, int srcWidth, int srcHeight,
        int dstWidth, int dstHeight,
        float *cpX, float *cpY,
        float *upperLeft, float *baseVec, float *normalVec, 
        float *vertical, float d
        ) &#123;
    v3 ul = a2v(upperLeft);
    v3 bv = a2v(baseVec);
    v3 nv = a2v(normalVec);
    v3 vt = a2v(vertical);
    unsigned char *dst = malloc(4 * dstWidth * dstHeight);
    for (int x = 0; x &lt; dstWidth; x++) &#123;
        v3 top = add(ul, add(mul(bv, cpX[x]), mul(nv, cpY[x])));
        for (int y = 0; y &lt; dstHeight; y++) &#123;
            v3 c = add(top, mul(vt, (float)y / dstHeight));
            float sx = c.x / (1 + c.z / d); 
            float sy = c.y / (1 + c.z / d); 
            sx = (sx + 0.5f) * srcWidth;
            sy = sy * srcWidth + 0.5f * srcHeight;
            int di = (y * dstWidth + x) * 4;
            int si = ((int)round(sy) * srcWidth + (int)round(sx)) * 4;
            dst[di] = src[si];
            dst[di + 1] = src[si + 1];
            dst[di + 2] = src[si + 2];
            dst[di + 3] = src[si + 3];
        &#125;
    &#125;
    return dst;
&#125;</code></pre>
<p>注意函数前面加的<code>EMSCRIPTEN_KEEPALIVE</code>宏，这个宏一方面导出了函数，另一方面防止LLVM过于智能把这段函数当成dead code消除掉或者内联掉。如果不用这个宏，就需要在编译选项里加上<code>-s EXPORTED_FUNCTIONS="['_dewarp']"</code>。注意<strong>Emscripten在导出函数名称的时候都在前面加上了<code>_</code></strong>，直接引用的时候不能漏掉。</p>
<p>另外一个要注意的点是程序内部是无法直接访问JavaScript里面的变量的，我用的是Vue，那就更不用说了。所有要用到的context都需要在参数里面传进来。而目前来说，Emscripten对于自定义结构体之类的支持很少，传参基本上只支持primitive types和指针。除此以外，在指针方面吧，Emscripten并没有自动帮我们做好数组的转换，这一部分需要自行编写，一维的还容易一点，高维的写起来就更难受了。可以参考这个<a target="_blank" rel="noopener" href="https://github.com/Planeshifter/emscripten-examples">repo</a>。</p>
<pre class="line-numbers"><code class="language-javascript">function copyToHeap(typedArray) &#123;
  let size = typedArray.length * typedArray.BYTES_PER_ELEMENT;
  let offset = Module._malloc(size);
  Module.HEAPU8.set(new Uint8Array(typedArray.buffer), offset);
  return offset;
&#125;

Module[&quot;dewarp&quot;] = function(src, srcWidth, srcHeight, dstWidth, dstHeight, cpX, cpY, upperLeft, baseVec, normalVec, vertical, d) &#123;
  let pSrc = copyToHeap(src);
  let pCpX = copyToHeap(cpX), pCpY = copyToHeap(cpY);
  let pUL = copyToHeap(upperLeft), pBV = copyToHeap(baseVec);
  let pNV = copyToHeap(normalVec), pVertical = copyToHeap(vertical);
  let pDst = Module._dewarp(pSrc, srcWidth, srcHeight, dstWidth, dstHeight, pCpX, pCpY, pUL, pBV, pNV, pVertical, d);
  let ret = new Uint8ClampedArray(4 * dstWidth * dstHeight);
  ret.set(new Uint8ClampedArray(Module.HEAPU8.buffer, pDst, 4 * dstWidth * dstHeight));
  Module._free(pSrc); Module._free(pDst);
  Module._free(pCpX); Module._free(pCpY);
  Module._free(pUL); Module._free(pBV);
  Module._free(pNV); Module._free(pVertical);
  return ret;
&#125;;</code></pre>
<p>WebAssembly内部是简单的线性内存空间，可以使用<code>Module.HEAPU8</code>来获取一个<code>U8</code>的View。调用的时候直接<code>Module._dewarp</code>，依然注意要在C函数名前面加<code>_</code>。官方还提供了了<code>ccall</code>的调用方式，会自动对字符串做转码，在这里并不需要。在调用时指针一律当做整数处理。在返回时直接把返回数组在内存中的数据复制一份就行了。之后记得全部<code>free</code>掉就行了。</p>
<p>编译的指令是：</p>
<pre class="line-numbers shell"><code class="language-none">emcc -O3 dewarp.c -o dewarp.js --post-js dewarp_post.js \
    -s ENVIRONMENT=&quot;web&quot; \
    -s MODULARIZE=1 \
    -s ALLOW_MEMORY_GROWTH=1</code></pre>
<p>选项的意义如下：</p>
<ul>
<li><code>-O3</code>：优化级别，和一般的C编译器类似。<code>-O3</code>是最激进的优化之一。除了在字节码上优化还会minify生成的接口js。</li>
<li><code>-o dewarp.js</code>：生成的接口文件名。</li>
<li><code>--post-js dewarp_post.js</code>：把<code>dewarp_post.js</code>（也就是上面<code>copyToHeap</code>所在的文件）附到生成的<code>dewarp.js</code>后。类似地还有<code>--pre-js</code>。</li>
<li><code>-s ENVIRONMENT="web"</code>：默认Emscripten在编译接口文件的时候会同时加入node和浏览器环境下不同的加载方案。我们这边只需要浏览器环境，加上这个选项有助于减少生成的接口js大小。何况在使用webpack的情况下不开这个webpack会傻乎乎地把<code>fs</code>加到dependencies里面然后报错，这个时候要不这里加选项要不webpack那里额外配置二选一。</li>
<li><code>-s MODULARIZE=1</code>：在写Emscripten的js端的文件的时候<code>Module</code>是一个关键的变量。在默认情况下Emscripten把它定义为全局变量。这会造成命名污染。如果加上这个选项，编译出来的代码就相当于是在一个大的<code>function</code>里面。这个函数接受一个预先加了点东西的<code>Module</code>对象，加上自己的私货（还有我们在<code>dewarp_post.js</code>里面定义的helper函数）之后返回完成的<code>Module</code>。确保不会产生命名污染的问题。同时Emscripten会自动把这个大函数设成<code>module.exports</code>。</li>
<li><code>-s ALLOW_MEMORY_GROWTH=1</code>：默认的内存空间是固定的，这个选项允许内存空间的扩张。图像处理算法占的内存比较大，不加这个选项会爆内存。</li>
</ul>
<p>另外还有两个常用的选项：</p>
<ul>
<li><code>-s EXPORTED_FUNCTIONS="['_foo', ...]"</code>：指定要导出的函数，这里的名称要加下划线。等号右边是js列表的写法。如果在C源码要导出的函数前加上<code>EMSCRIPTEN_KEEPALIVE</code>的话这里就不需要再指明了。</li>
<li><code>-s EXTRA_EXPORTED_RUNTIME_METHODS="['ccall', ...]"</code>：默认Emscripten不会把很多API导出，因为这有助于减小接口文件的大小，但是如果要用<code>ccall</code>和<code>cwrap</code>之类的API的话就要在这里指明。</li>
</ul>
<p>（自己一开始<code>-s</code>开头的选项一个都不知道要加，然后疯狂出问题，就暴毙了）</p>
<p>编译完之后会生成两个文件，一个是接口的js文件，一个是wasm文件，里面存放的就是字节码了。</p>
<h1 id="javascript端的磨合">Javascript端的磨合</h1>
<p>Emscripten上的教程在这里说得非常轻巧：只要<code>&lt;script/&gt;</code>引入，然后接口js会自动加载wasm文件，然后调用方法就行了。这样做是没错，但是忽略了一点：大家现在都在用webpack之类的打包器，这类打包器面对WebAssembly需要特殊的配置才能确保其顺利运行。</p>
<p>我之前一直避免自己动webpack配置这种东西，因为我觉得Vue CLI帮我安顿得挺好的自己一搞搞不好怎么挂的都不知道。刚开始配置我这个萌新就真马上跌进坑里了：网上教程里面写的都是<code>webpack.config.js</code>，然后我一直试都没有效果，纳闷了很久，才发觉因为我用的是Vue CLI，所以配置都在<code>vue.config.js</code>里面：</p>
<pre class="line-numbers"><code class="language-javascript">module.exports = &#123;
  ...
  configureWebpack: &#123;
    // 原来webpack.config.js的内容
  &#125;
&#125;;</code></pre>
<p><del>这种坑有经验的开发者都不会进去吧？还是我太菜了</del></p>
<p>同时注意如果开启ESLint的话，注意一定要在<code>.eslintignore</code>文件里面加上接口js，一方面自动生成的js不需要lint，另一方面由于上下文不足lint下来会有很多误报。</p>
<p>在webpack的配置上，对于两种文件分别采取如下策略：</p>
<ul>
<li>wasm文件就是普通文件，应该使用<code>file-loader</code>。</li>
<li>js文件由于采用<code>-s MODULARIZE=1</code>编译开关，会把一个函数挂载到<code>module.exports</code>上，这个时候就要用<code>exports-loader</code>加载。</li>
</ul>
<p>我这个萌新一开始对于loader的概念很困惑。因为我一开始觉得webpack一个打包的东西有哪里需要load呢？在那里用这些loader呢？后来意识到loader机制的意思是把</p>
<pre class="line-numbers"><code class="language-javascript">import foo from &quot;bar&quot;</code></pre>
<p>转变成</p>
<pre class="line-numbers"><code class="language-javascript">var foo = some_loader(&quot;bar&quot;);</code></pre>
<p>这件事情其实是挺有意思的。静态语言写多了就觉得模块导入语句应该有固定的语义才对，结果到JavaScript这里发现<code>import</code>其实纯粹是类似语法糖的元素，语义不固定=_=。</p>
<p>倒腾一圈下来我项目当中的webpack配置如下：</p>
<pre class="line-numbers"><code class="language-javascript">&#123;
  module: &#123;
    rules: [
      &#123;
        test: /dewarp\.js$/,
        loader: &quot;exports-loader&quot;
      &#125;,
      &#123;
        test: /dewarp\.wasm$/,
        type: &quot;javascript/auto&quot;,
        loader: &quot;file-loader&quot;,
      &#125;
    ]
  &#125;,
&#125;</code></pre>
<p>还没完，在javascript代码里面这样写：</p>
<pre class="line-numbers"><code class="language-javascript">// 指定用exports-loader，所以wasmInterface现在就是Emscripten导出的那个返回Module的大函数
import wasmInterface from &quot;./wasm/dewarp.js&quot;
// 指定用file-loader，所以wasmBytecode现在就是指向wasm文件的路径
import wasmBytecode from &quot;./wasm/dewarp.wasm&quot;

let wasmModule = wasmInterface(&#123;
  // Emscripten导出的函数可以接受一个已经塞了东西的对象作为Module的基础
  // 可以在里面定义Emscripten文档里面写的一些特殊函数，比如说这里的locateFile
  // 如果定义了，在加载字节码的时候就会调用这个函数获取path的真实有效值，因为webpack
  // 调整了文件位置关系，而Emscripten生成接口脚本时写入的是生成时的文件位置，因此我们
  // 就必须在这个函数里告诉它真实的文件位置，不然会404翻车
  locateFile(path) &#123;
    return path.endsWith(&quot;.wasm&quot;) ? wasmBytecode : path;
  &#125;
&#125;); // 创建对象之后自动加载
wasmModule.onRuntimeInitialized = () =&gt; &#123;
  // 文件加载完毕
&#125;;</code></pre>
<p>在这么一番操作之后，我才终于可以在原来的地方写上</p>
<pre class="line-numbers"><code class="language-javascript">wasmModule.dewarp(...) // 调用dewarp_post.js里面的helper函数，间接调用C函数</code></pre>
<p>整个过程挺折腾的，但事实也确实证明这么折腾一番是值得的，性能提升三十倍，非常愉悦。</p>
<h1 id="结论">结论</h1>
<p>总体下来我觉得WebAssembly现在技术上已经趋于成熟了，像我第一次积累了经验之后以后再用WebAssembly不踩那些坑的话体验是相当不错的。当然对于Emscripten来说在调用时的转化上目前还不是那么智能，还有很多要改进的地方（这也可能和JavaScript太放飞自我的设计有关？），使用Rust的开发我还没有试过，看官方文档上Game of Life的demo觉得非常有意思（我觉得Rust真的是绝对的后起之秀，各种方面的）。</p>
<p>更有意思的是，这还不是优化的终点。我听说WebAssembly还有一个SIMD的提案，这似乎又可以让性能提升若干个台阶（当然我不知道目前的JIT VM能不能根据字节码进行自动向量化）。还真的就是啥native上的技术都往web端搬，浏览器也是啥活现在都要揽=_=，估计过几年就真成一个小的操作系统了（ChromeOS: Hold my chrome :）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/01/10/Dewarp3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/10/Dewarp3/" class="post-title-link" itemprop="url">卷曲页面复原 3 ——完工</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-01-10 16:07:43 / 修改时间：20:14:31" itemprop="dateCreated datePublished" datetime="2020-01-10T16:07:43+08:00">2020-01-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="进展">进展！</h1>
<p>自己写的网页终于功能全部完成啦！</p>
<p>现在已经把成品网页放到博客上来了，上面几个链接最右边那个PageDewarp就是，戳进去就行了。</p>
<p>放几张成品：</p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/lhyM24"><img src="https://s2.ax1x.com/2020/01/10/lhyM24.jpg" alt="lhyM24.jpg" /></a></p>
<p><a target="_blank" rel="noopener" href="https://imgchr.com/i/lhyKGF"><img src="https://s2.ax1x.com/2020/01/10/lhyKGF.png" alt="lhyKGF.png" /></a></p>
<p>效果还是相当不错的。如果有二值化就更好了。</p>
<h1 id="卷曲复原">卷曲复原</h1>
<p>在确定了曲面的各个参数之后，整个纸面的曲面就有了，剩下的就是把卷曲复原，输出结果。</p>
<p>卷曲复原的过程是一个图像上<strong>坐标映射</strong>的过程。我们遍历结果图像上的每一个坐标，唯一地确立其在输入图像上的源坐标，把源坐标的像素复制进来（或许再使用一些采样的技巧），拼成最终的结果，就成了。</p>
<p>更具体一点，如果输出图像是<span class="math inline">\(w\times h\)</span>，我们就需要把页面曲面水平分成<span class="math inline">\(w\)</span>等分，垂直分成<span class="math inline">\(h\)</span>等分，形成一个网格。结果图像上的<span class="math inline">\((i, j)\)</span>像素就是网格中<span class="math inline">\((i,j)\)</span>对应点的三维坐标在原始图像上投影点对应的像素。</p>
<p>垂直等分是简单的，因为在最早的假设里面我就假设页面的垂直边沿是直线。</p>
<p>但是水平边沿是一条曲线，或者更精确的说，可以被近似看为一条分段三次样条曲线。怎么等分这样一个曲线呢？</p>
<p>这种事情用数学解决是最理想的，只要能够解析地计算出任意区间曲线的长度，配合二分这个问题就解决了。但是三次函数曲线长度的积分是非初等的且无比复杂的，所以数学方法行不通。</p>
<figure>
<img src="https://s2.ax1x.com/2020/01/10/lh4vlV.png" alt="lh4vlV.png" /><figcaption aria-hidden="true">lh4vlV.png</figcaption>
</figure>
<p>（Well，好像Mathematica告诉我算还是可以算的……）</p>
<p>于是只能使用不那么优雅的数值方法解决了。飞快地写了一个Simpson Integration，效果看起来还不错，嘛反正精度不够缩小步长就可以了，和后面的计算比这个又不是瓶颈。</p>
<pre class="line-numbers"><code class="language-javascript">// spline: 两端为(0, 0)和(1, 0)的分段样条曲线
// res: 等分的数量
const step = 0.0001;
let len = 0, t = [];
for (let i = 0; i &lt;= this.nodeCount; i++) &#123;
    let [a, b, c, d] = spline[i]; // a + bx + cx^2 + dx^3
    let xLeft = i === 0 ? 0 : this.splineNodes[i - 1][0];
    let xRight = i === this.nodeCount ? 1 : this.splineNodes[i][0];
    let f = x =&gt; Math.hypot(1, ((3 * d * x + 2 * c) * x + b));
    for (let x = xLeft; x &lt; xRight; x += step) &#123;
        let h = Math.min(xRight - x, step);
        len += (f(x) + 4 * f(x + h / 2) + f(x + h)) * h / 6;
        t.push([x, len, ((d * x + c) * x + b) * x + a]);
    &#125;
&#125;
let ret = [], p = 0;
for (let i = 1; i &lt;= res; i++) &#123;
    let l = i / res * len;
    while (p + 1 &lt; t.length &amp;&amp; t[p + 1][1] &lt;= l) p++;
    let lt = t[p], rt = p + 1 === t.length ? [1, len, 0] : t[p + 1];
    ret.push(l - lt[1] &lt;= rt[1] - l ? [lt[0], lt[2]] : [rt[0], rt[2]]);
&#125;
// ret 就是曲线上的点了</code></pre>
<p>anyway，反正积的函数也没有那么畸形，也没那么着急优化，代码写得乱一点也就凑活着过去了<del>（疯狂为自己的懒找借口）</del></p>
<p>求出曲线一连串等分点之后就可以做复原了：</p>
<pre class="line-numbers"><code class="language-javascript">// vadd, multiply: 向量和，数乘
// criticalPoints: 曲线等分点
for (let x = 0; x &lt; resultWidth; x++) &#123; // 遍历结果的每一列像素
    const top = vadd(this.upperLeft3D,
        multiply(this.baseVec, criticalPoints[x][0]), multiply(this.normalVec, criticalPoints[x][1])); 
    for (let y = 0; y &lt; resultHeight; y++) &#123; 
        let coord = multiply(this.toCanvasCoord(this.project(
            vadd(top, multiply(vertical, y / resultHeight)))), width / this.canvasWidth); // (x, y)对应的图像的原坐标
        let di = (y * resultWidth + x) * 4;
        let si = (Math.round(coord[1]) * width + Math.round(coord[0])) * 4;
        // R, G, B, alpha四通道
        imageDataResult.data[di] = imageDataOriginal.data[si];
        imageDataResult.data[di + 1] = imageDataOriginal.data[si + 1];
        imageDataResult.data[di + 2] = imageDataOriginal.data[si + 2];
        imageDataResult.data[di + 3] = imageDataOriginal.data[si + 3];
    &#125;
&#125;</code></pre>
<p>大概是OI写惯了觉得<span class="math inline">\(10^3\times 10^3\)</span>级别的运算没啥，直觉告诉我这一段代码跑得会很快。然而现实是残酷的，这段代码要跑三十秒左右，也不知道是哪里出了问题，V8的JIT都拯救不了。</p>
<p>目前只能先用这么慢的代码将就着了，回头有空用WebAssembly试图优化一下吧。接下来应该都是工程问题了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/01/09/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E5%BC%80%E5%B9%B3%E6%96%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/09/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E5%BC%80%E5%B9%B3%E6%96%B9/" class="post-title-link" itemprop="url">运用牛顿迭代法开平方根 —— 通项与分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-09 13:59:41" itemprop="dateCreated datePublished" datetime="2020-01-09T13:59:41+08:00">2020-01-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-01-10 14:57:08" itemprop="dateModified" datetime="2020-01-10T14:57:08+08:00">2020-01-10</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>前几天我在知乎上看到了一道数列题： <span class="math display">\[
a_n=\begin{cases}
2, &amp; n=1\\
\frac{a_{n-1}^2+1}{2a_{n-1}}, &amp; n\ge2
\end{cases} \quad (n\in{\mathbb{N^{\ast}}})
\]</span> 这一道题基于的背景显然是运用牛顿迭代求解平方根。牛顿迭代法的原理无论是从其直观意义亦或是从微分的角度都是很容易理解的，但是其分析就不然了。我记得自己三年以前试着分析过一次，但是因为当时自己太菜所以最后啥都没分析出来（悲）。</p>
<h1 id="通项">通项</h1>
<p>对于计算<span class="math inline">\(\sqrt k\)</span>的牛顿迭代法，其递推式如下（基于求取<span class="math inline">\(x^2=k\)</span>的零点） <span class="math display">\[
x_{n+1} = x_n - \frac{x_n^2-k}{2x_n} = \frac{x_n^2+k}{2x_n}
\]</span> 或者根据巴比伦人当时的更直观的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method">写法</a>： <span class="math display">\[
x_{n+1} = \frac{1}{2}\left(x_n + \frac{k}{x_n}\right)
\]</span> 递推式的式子很简单，但是求解的方法并不trivial，在等式两边同时加上以及减去<span class="math inline">\(\sqrt{k}\)</span>： <span class="math display">\[
\begin{aligned}
x_{n+1} - \sqrt k &amp;= \frac{\left(x_n-\sqrt k\right)^2}{2x_n} \\
x_{n+1} + \sqrt k &amp;= \frac{\left(x_n+\sqrt k\right)^2}{2x_n} \\
\end{aligned}
\]</span> 上下两式相除（很显然，除非<span class="math inline">\(x_1=-\sqrt {2}\)</span>分母不可能为<span class="math inline">\(0\)</span>） <span class="math display">\[
\frac{x_{n+1} - \sqrt k}{x_{n+1} + \sqrt k} = \left(\frac{x_{n} - \sqrt k}{x_{n} + \sqrt k}\right)^2
\]</span> 那么非常显然地，可以得出 <span class="math display">\[
\frac{x_{n} - \sqrt k}{x_{n} + \sqrt k} = \left(\frac{x_1 - \sqrt k}{x_1 + \sqrt k}\right)^{2^{n-1}}
\]</span> 基于上式求解<span class="math inline">\(x_n\)</span> <span class="math display">\[
x_n=\sqrt k \cdot \frac{1+\left(\frac{x_1 - \sqrt k}{x_1 + \sqrt k}\right)^{2^{n-1}}}{1-\left(\frac{x_1 - \sqrt k}{x_1 + \sqrt k}\right)^{2^{n-1}}}
\]</span> 这个递推式的通项就求出来了。最初的两步是我觉得是很难想到的，非常妙。</p>
<h1 id="收敛性">收敛性</h1>
<p>基于这一通项，牛顿迭代法的收敛性也就显然取决于<span class="math inline">\(\left|\frac{x_1 - \sqrt k}{x_1 + \sqrt k}\right|\)</span>，比如说当 <span class="math display">\[
\left|\frac{x_1 - \sqrt k}{x_1 + \sqrt k}\right| &lt;1 \Rightarrow x_1 &gt; 0
\]</span> <span class="math inline">\(\{x_n\}\)</span>迭代收敛至<span class="math inline">\(\sqrt k\)</span>，当<span class="math inline">\(x_1&lt;0\)</span>时收敛至<span class="math inline">\(-\sqrt k\)</span>，这和直觉是相符的。</p>
<h1 id="收敛速率">收敛速率</h1>
<p>不妨令<span class="math inline">\(\alpha=\frac{x_1 - \sqrt k}{x_1 + \sqrt k}\)</span>，在<span class="math inline">\(|\alpha| &lt; 1\)</span>时，牛顿迭代法的误差就可以写作： <span class="math display">\[
x_n-\sqrt k =\sqrt k \cdot \frac{2\alpha^{2^{n-1}}}{1-\alpha^{2^{n-1}}}
\]</span> 相邻项误差之比为： <span class="math display">\[
\frac{\left|x_{n+1}-\sqrt k\right|}{\left|x_n - \sqrt k\right|} =\left|\frac{\alpha^{2^n}(1-\alpha^{2^{n-1}})}{\alpha^{2^{n-1}}(1-\alpha^{2^{n}})}\right| = \frac{\alpha^{2^{n-1}} - \alpha^{2^n}}{1-\alpha^{2^{n}}}
\]</span> 考虑极限情况： <span class="math display">\[
\begin{aligned}
\lim_{n\to \infty}\frac{\left|x_{n+1}-\sqrt k\right|}{\left|x_n - \sqrt k\right|} &amp;= \lim_{n\to \infty}\frac{\alpha^{2^{n-1}} - \alpha^{2^n}}{1-\alpha^{2^{n}}} \\
&amp;= \frac{\lim_{n\to \infty}\alpha^{2^{n-1}}-\lim_{n\to \infty}\alpha^{2^{n}}}{1-\lim_{n\to \infty}\alpha^{2^{n}}} \\
&amp;= 0
\end{aligned}
\]</span> 这说明牛顿迭代法的收敛速率是<strong>超线性</strong>的。</p>
<p>当然，有更强的结论： <span class="math display">\[
\begin{aligned}
\lim_{n\to \infty}\frac{\left|x_{n+1}-\sqrt k\right|}{\left|x_n - \sqrt k\right|^2} &amp;= \lim_{n\to \infty}\frac{\left(1-\alpha^{2^{n-1}}\right)^2}{1-\alpha^{2^{n}}} \\
&amp;= 1
\end{aligned}
\]</span> 也就是说牛顿迭代法的收敛速率是<strong>平方级</strong>（quadratic）的，也就是说，<strong>每迭代一次，结果的有效位数就会翻倍</strong>。</p>
<p>而与此相对地，二分法的收敛速率显然是线性的，这也就是为什么牛顿迭代法在实践中比二分不知道高到哪里去了。</p>
<h1 id="更快速收敛的迭代法">更快速收敛的迭代法？</h1>
<p>根据以上论证，不难观察发现，牛顿迭代法的收敛速率之所以是平方级的，是因为<span class="math inline">\(\alpha^{2^n}\)</span>当中的<span class="math inline">\(2\)</span>的作用。那如果把<span class="math inline">\(2\)</span>换成<span class="math inline">\(3\)</span>呢？</p>
<p>也就是说，如果我们构造<span class="math inline">\(x_n\)</span>，使得 <span class="math display">\[
\frac{x_{n+1} - \sqrt k}{x_{n+1} + \sqrt k} = \left(\frac{x_{n} - \sqrt k}{x_{n} + \sqrt k}\right)^3
\]</span> 也就是 <span class="math display">\[
x_{n+1} = \frac{x_n\left(x_n^2+3k\right)}{3x_n^2+k}
\]</span> 那收敛速度不就是三次方了吗？看起来很不错的样子！但是实用吗？</p>
<p>在硬件层面，计算一次牛顿迭代所需要的基本操作是（不计各类访存）:</p>
<ol type="1">
<li>计算<span class="math inline">\(x_n^2\)</span>——一次乘法</li>
<li>计算<span class="math inline">\(x_n^2+k\)</span>——一次加法</li>
<li>计算<span class="math inline">\(2x_n\)</span>——一次乘法</li>
<li>计算<span class="math inline">\(x_{n+1}\)</span>——一次除法</li>
</ol>
<p>即总共两次乘法，一次除法，一次加法，其中<span class="math inline">\(2x_n\)</span>的乘法还可以转化为一次加法，对硬件是非常友好的。</p>
<p>而相对地，计算一次上面的三次方收敛的迭代所需要的基本操作是：</p>
<ol type="1">
<li>计算<span class="math inline">\(x_n^2\)</span>——一次乘法</li>
<li>计算<span class="math inline">\(x_n^2+3k\)</span>——一次加法（如果我们预先算出了<span class="math inline">\(3k\)</span>）</li>
<li>计算<span class="math inline">\(x_n(x_n^2+3k)\)</span>——一次乘法</li>
<li>计算<span class="math inline">\(3x_n^2\)</span>——一次乘法（如果我们缓存了<span class="math inline">\(x_n^2\)</span>）</li>
<li>计算<span class="math inline">\(3x_n^2+k\)</span>——一次加法</li>
<li>计算<span class="math inline">\(x_{n+1}\)</span>——一次除法</li>
</ol>
<p>即总共三次乘法，一次除法，两次加法。看起来比牛顿法没有多多少，但是考虑到访存等，估计在硬件上并不划算。当然，在渐进意义上讲，如果一次迭代所需要的时间比一次牛顿迭代所需要时间的<span class="math inline">\(\log_23\)</span>倍要少，那么这个算法还是“实用”的。</p>
<p>类似地对于指数的底数是<span class="math inline">\(4,5,6,7,8\)</span>的情况，我们还有如下的递推式： <span class="math display">\[
\begin{aligned}
x_{n+1} &amp;= \frac{x_n^4+6kx_n^2+k^2}{4x_n\left(x_n^2+k\right)}\\
x_{n+1} &amp;= \frac{x_n\left(x_n^4+10kx_n^2+5k^2\right)}{5x_n^4+10kx_n^2+k^2}\\
x_{n+1} &amp;= \frac{\left(x_n^2+k\right)\left(x_n^4+14kx_n^2+k^2\right)}{2x_n\left(3x_n^2+k\right)\left(x_n^2+3k\right)}\\
x_{n+1} &amp;= \frac{x_n \left(x_n^6+21 k x_n^4+35 k^2 x_n^2+7 k^3\right)}{7 x_n^6+35 k x_n^4+21
   k^2 x_n^2+k^3} \\
x_{n+1} &amp;= \frac{x_n^8+28 k x_n^6+70 k^2 x_n^4+28 k^3 x_n^2+k^4}{8 x_n
   \left(x_n^2+k\right) \left(x_n^4+6 k x_n^2+k^2\right)}   
\end{aligned}
\]</span> 上面的式子一个比一个收敛得快。</p>
<p>比如说用最后一个八次方收敛的，初值为<span class="math inline">\(1\)</span>计算<span class="math inline">\(\sqrt 2\)</span>。</p>
<p>第一次迭代：前<span class="math inline">\(5\)</span>位相同。</p>
<p>第二次迭代：前<span class="math inline">\(48\)</span>位相同。</p>
<p>第三次迭代：前<span class="math inline">\(391\)</span>位相同。</p>
<p>第四次迭代：前<span class="math inline">\(3135\)</span>位相同。</p>
<p>每迭代一次正确位数翻八倍！</p>
<p><del>啊！我刚刚注意到最后的八次方收敛算法就是把三步牛顿迭代缩成一步化简了而已，自己实在被自己蠢到了</del></p>
<p><del>但是不管怎么样三次方，五次方的收敛算法还是比较non-trivial的？</del></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2019/12/28/Dewarp2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/28/Dewarp2/" class="post-title-link" itemprop="url">卷曲页面复原 2 ——曲线拟合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-28 21:06:33" itemprop="dateCreated datePublished" datetime="2019-12-28T21:06:33+08:00">2019-12-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-01-09 11:10:00" itemprop="dateModified" datetime="2020-01-09T11:10:00+08:00">2020-01-09</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在前几天用扫描全能王的时候发现它似乎有自动拍书功能的（悲），似乎还可以自动识别，连标定都不要了。官方看到这个小博客的可能性微存？</p>
<p>但是那个是付费的会员功能！而且不管怎么样自己写一遍总归是有收获的。</p>
<h1 id="进展">进展！</h1>
<p>过去的一周一直在和各种工程问题作斗争。目前的进展如下：</p>
<figure>
<img src="https://raw.githubusercontent.com/alan20210202/images/master/2020/01/01-12-00-22-Snipaste_2020-01-01_12-00-03.jpg" alt="Snipaste_2020-01-01_12-00-03.jpg" /><figcaption aria-hidden="true">Snipaste_2020-01-01_12-00-03.jpg</figcaption>
</figure>
<p>让这些探究只停留在Jupyter Notebook上我觉得太可惜了，加上我觉得自己经常会用，所以我准备撸一个App传到博客上去。</p>
<p>然后某人悲催地发现自己Web开发的技艺约等于0。</p>
<p>花了一个小时速成Vue和Vuetify，花了一个小时复习了一遍Node和JS，花了一个小时重装了Webstorm，Vue CLI开一个SPA直接开搞。</p>
<p>在Stack Overflow和Google和MDN里面转悠了五天之后自己终于写出了还算像样的雏形。现在标定功能已经写完了！</p>
<p>上图当中的黄框表示页面平面，绿框悬浮在黄框上面营造出一种透视立体的感觉（其实是调试完不想删掉了），上下两条蓝色的曲线表示书页的弯曲曲线。所有红色的点都是可以拖动的，拖动时还会在边角显示两倍放大后的特写便于精准定位，就像这样</p>
<figure>
<img src="https://raw.githubusercontent.com/alan20210202/images/master/2020/01/01-12-13-24-2020-01-01-12-12-46-image.png" alt="2020-01-01-12-12-46-image.png" /><figcaption aria-hidden="true">2020-01-01-12-12-46-image.png</figcaption>
</figure>
<p>功能上其实比上一篇文章没有多出多少（虽然在工程方面取得了巨大的突破）除了——曲线，这一条曲线其实没有那么简单。</p>
<h1 id="反向投影">反向投影</h1>
<p>从上图可以看到，图中的曲线形状是由中间五个节点决定的，但是基于的是节点的三维坐标而不是所看到的二维坐标。这当中就牵涉到一个反向投影的问题——知道一个点在二维平面上投影点的坐标，如何在一定的约束条件下求取其三维坐标呢？</p>
<p><img src="https://raw.githubusercontent.com/alan20210202/images/master/2019/12/26-18-45-20-Points1.png" /></p>
<p>这个时候前一篇文章所做的页面平面重建的结果就变得重要了起来。这五个关键点都在书页的下边缘上，在数学上，五个小红点都在<em>平面<span class="math inline">\(ABCD\)</span>底边<span class="math inline">\(AD\)</span>所在的，且垂直于平面<span class="math inline">\(ABCD\)</span>的平面</em>上。首先我们要确定这个平面，不妨称之为平面<span class="math inline">\(P\)</span>。</p>
<p>平面的方程式<span class="math inline">\(Ax+By+Cz=D\)</span>，<span class="math inline">\((A,B,C)\)</span>就是这个平面的法向量，我们已经知道了两个<span class="math inline">\(P\)</span>上的点（点<span class="math inline">\(A\)</span>和点<span class="math inline">\(D\)</span>），如果我们知道了平面的法向量，那么把<span class="math inline">\(A\)</span>点代入，方程当中的<span class="math inline">\(D\)</span>就出来了，平面就确定了。</p>
<p>在理想情况下，法向量就是<span class="math inline">\(\vec{AB}\)</span>，因为理想情况下<span class="math inline">\(\vec{AD}\perp\vec{AB}\)</span>。</p>
<p>但是现实比较残酷，由于计算的一点点小误差，算出来的<span class="math inline">\(\vec{AD}\)</span>并不总是垂直于<span class="math inline">\(\vec{AD}\)</span>，比如说夹角是<span class="math inline">\(89.94^{\circ}\)</span>。这个<span class="math inline">\(\vec{AB}\)</span>就不是法向量了，这是很坑的。我一开始偷懒把<span class="math inline">\(\vec{AB}\)</span>当法向量写到程序里面去，结果调试的时候一直有小误差，心态都快崩了。</p>
<p>然后我才意识到果然不能偷懒，正确的法向量就是<span class="math inline">\(\vec{AD}\times(\vec{AD}\times\vec{AB})\)</span>。</p>
<p>然后对于在平面<span class="math inline">\(P\)</span>上的任意一个点<span class="math inline">\(Q(x, y,z)\)</span>，已知其投影是<span class="math inline">\(Q^{\ast}(x^{\ast},y^{\ast})\)</span>。根据方程</p>
<p><span class="math display">\[
\begin{cases}
    Ax+By+Cz=D\\
    x=x^{\ast}(1+z/d)\\
    y=y^{\ast}(1+z/d)
\end{cases}
\]</span></p>
<p>就能把这个点的坐标算出来了。</p>
<p>之后还需要再做一步，把<span class="math inline">\(\vec{AQ}\)</span>分解：</p>
<p><span class="math display">\[
\vec{AQ}=a\vec{AD}+b\frac{\vec{AD}\times\vec{AB}}{\left|\vec{AD}\times\vec{AB}\right|}\quad a\in[0,1] 
\]</span></p>
<p>之后得到的<span class="math inline">\((a,b)\)</span>才是一个相对归一化了的坐标。使用这个坐标进行插值的话，<span class="math inline">\(A,B,C,D\)</span>四个点小范围内的运动都不会改变曲线的形状，这相当于增加了我们算法的鲁棒性。</p>
<h1 id="插值">插值</h1>
<p>使用什么曲线插值比较好呢？</p>
<p>如果在计算机的背景下最先想到的肯定是贝塞尔曲线，但是贝塞尔曲线不经过它控制点，这似乎在界面上就不是那么直观。</p>
<p>如果采用高阶多项式的插值呢？那么Runge现象又会非常严重，可以预见效果会很差。</p>
<p>于是乎我采用的是三次样条插值。对于三次样条插值：</p>
<ol type="1">
<li><p>假设有<span class="math inline">\(n\)</span>个节点，那么就有<span class="math inline">\(n-1\)</span>个区间，对应<span class="math inline">\(n-1\)</span>条曲线，<span class="math inline">\(4(n-1)\)</span>个参数。</p></li>
<li><p>对于一条三次曲线，其两个端点的值是确定的，那么就有<span class="math inline">\(2(n-1)\)</span>个约束条件。</p></li>
<li><p>中间的<span class="math inline">\(n-2\)</span>个节点上相邻的三次曲线必须一阶导连续且二阶导连续，那么就是<span class="math inline">\(2(n-2)\)</span>个约束条件。</p></li>
<li><p>为了能够在大多数情况下求出所有参数的准确值，还需要<span class="math inline">\(2\)</span>个约束条件。</p></li>
</ol>
<p>似乎最常见的边界条件被称为<strong>自然边界条件</strong>。也就是样条曲线两端的二阶导为<span class="math inline">\(0\)</span>。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Spline_%28mathematics%29#Algorithm_for_computing_natural_cubic_splines">Wiki</a>上介绍的算法也是针对这种边界条件设计的，但是在我们这个情境下自然边界似乎不适用，因为书页的一侧总是向下凹向书脊，书脊起了固定作用。我一开始照抄Wiki上的算法结果曲线对不上翻车了。</p>
<p>这个情景应该用的似乎是<strong>夹持边界条件</strong>。也就是人为地给出曲线两端的一阶导。也就是我的界面右侧出现"Left Slope"和"Right Slope"两个slider的原因。这个边界条件试下来似乎和实际吻合得还是相当不错的。问题主要出现在算法这里，我虽然从矩阵的形式推断一定存在像Wiki上处理自然边界条件一样显式线性的算法，但是自己还是懒得去推了直接用mathjs的<code>lusolve</code>函数（Well 我相信mathjs这种大库的消元一定有优化……），速度还是非常令人满意的，但是代码可读性就是一个比较大的问题了：</p>
<pre class="line-numbers"><code class="language-javascript">let n = nodes.length - 1; // nodes.length knots, so nodes.length - 1 ranges and piecewise curves

let A = zeros(4 * n, 4 * n); // 4 parameters for each curve
let b = zeros(4 * n);
for (let i = 0; i &lt; n; i++) &#123;
    // Equation 4i and 4i + 1 ensures continuity of the spline
    b.set([4 * i], nodes[i][1]);
    for (let j = 0; j &lt; 4; j++)
        A.set([4 * i, 4 * i + j], pow(nodes[i][0], j));
    b.set([4 * i + 1], nodes[i + 1][1]);
    for (let j = 0; j &lt; 4; j++)
        A.set([4 * i + 1, 4 * i + j], pow(nodes[i + 1][0], j));
    if (i &lt; n - 1) &#123;
        // Equation 4i + 2 and 4i + 3 ensures continuity of both the 1st and 2nd derivative
        A.set([4 * i + 2, 4 * i + 1], 1);
        A.set([4 * i + 2, 4 * i + 2], 2 * nodes[i + 1][0]);
        A.set([4 * i + 2, 4 * i + 3], 3 * pow(nodes[i + 1][0], 2));
        A.set([4 * i + 2, 4 * i + 5], -1);
        A.set([4 * i + 2, 4 * i + 6], -2 * nodes[i + 1][0]);
        A.set([4 * i + 2, 4 * i + 7], -3 * pow(nodes[i + 1][0], 2));
        A.set([4 * i + 3, 4 * i + 2], 2);
        A.set([4 * i + 3, 4 * i + 3], 6 * nodes[i + 1][0]);
        A.set([4 * i + 3, 4 * i + 6], -2);
        A.set([4 * i + 3, 4 * i + 7], -6 * nodes[i + 1][0]);
    &#125;
&#125;
// Equation 4n - 2 and 4n - 1 set constraint on slope on both ends
A.set([4 * n - 2, 1], 1);
A.set([4 * n - 2, 2], 2 * nodes[0][0]);
A.set([4 * n - 2, 3], 3 * pow(nodes[0][0], 2));
b.set([4 * n - 2], this.leftSlope);
A.set([4 * n - 1, 4 * n - 3], 1);
A.set([4 * n - 1, 4 * n - 2], 2 * nodes[n][0]);
A.set([4 * n - 1, 4 * n - 1], 3 * pow(nodes[n][0], 2));
b.set([4 * n - 1], this.rightSlope);
let sln = lusolve(A, b);</code></pre>
<p>虽然加了注释但是代码只能用悲剧来形容了（悲）。</p>
<p>全怪mathjs的API，我个人认为如果用Julia来写的的话一定没有那么多事情（确信）。</p>
<p>最后的效果倒确实是极好的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2019/12/24/Dewarp1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/24/Dewarp1/" class="post-title-link" itemprop="url">卷曲页面复原 1 ——平面重建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-24 20:48:37" itemprop="dateCreated datePublished" datetime="2019-12-24T20:48:37+08:00">2019-12-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2019-12-26 20:51:30" itemprop="dateModified" datetime="2019-12-26T20:51:30+08:00">2019-12-26</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题">问题</h1>
<p>自从Office Lens，扫描全能王等App问世以来，人们越来越习惯使用手机代替扫描仪的功能来拍摄文档，而这些App对于一般的<em>平面</em>文档也确实起到了很好的效果。但是对于比较厚重的书本，由于页面向书籍弯折，拍摄到的页面往往是弯曲的，不仅影响美观也影响阅读体验。这些App也均没有针对这一情形进行特殊的优化。</p>
<p>例如：</p>
<figure>
<img src="/Original.jpg" alt="Dewarp" /><figcaption aria-hidden="true">Dewarp</figcaption>
</figure>
<p>如何在算法层面解决这个问题呢？</p>
<h1 id="先前研究">先前研究</h1>
<p>这个问题的英文似乎是Page Dewarping。以这个为关键词Google了一番，确实有一些相关的研究，但是几乎都是通过判断字的走向以及表格中直线的走向判断来判断纸的弯曲方向的。</p>
<p>除此以外，据我所知是有专门扫书的扫描仪的。原理是通过打一束激光，通过平直激光束在页面上的投影判断纸的弯曲方向。</p>
<p>但是我的手机没有激光发射器。我也不想识别文字方向，因为这大概率在实现上是一项艰苦的体力劳动。</p>
<p>能不能通过判断<strong>纸的边缘</strong>来计算纸的弯曲情况呢？</p>
<p>事情要一步一步来。</p>
<p>这一篇文章，我们就先探究如何<strong>从一副二维的图像重建纸面几个关键定点的三维坐标</strong>。</p>
<h1 id="数学基础透视投影">数学基础：透视投影</h1>
<p><strong>真的无论什么时候都是近大远小的吗？</strong></p>
<p>众所周知，将三维空间当中的物体转变为二维空间中的像的过程被称作<strong>投影</strong>。</p>
<p>拍照显然就是一个投影的过程，因此在开始解决问题之前，我们先要确定投影的方式。</p>
<p>我们的眼睛，包括摄像头，获取到的画面之所以有着近大远小的特征，是因为无论是我们的眼睛，还是相机，采用的投影都是<strong>透视投影</strong>的缘故。透视投影的示意图如下：</p>
<figure>
<img src="https://raw.githubusercontent.com/alan20210202/images/master/2019/12/24-21-45-11-Projection.png" alt="Projection.png" /><figcaption aria-hidden="true">Projection.png</figcaption>
</figure>
<p>如图所示，透视投影需要定义一个<strong>视点</strong>，即我们的眼睛或者相机感光元件所在的位置。然后所有远处物体反射到达视点的光线与一特定平面的交点，就是这一点所对应的投影点。</p>
<p>透视投影虽然是最符合直觉，也是最自然的投影方式，但是这并不意味着这就是唯一的投影方式。另一个较为常见的投影被称作<strong>正交投影</strong>。可以想象为透视投影中视点在无限远处的情形。（在正交投影当中，远近等大。也正是因为这个原因，正交投影广泛地被CAD软件所采用）因此，在对问题下手之前确定投影的类型是十分重要的。</p>
<p>OK，回到透视投影。之前的文字只给出了透视投影的定性叙述，这对于算法来说显然是不够的。透视投影可以在数学上可以如下定义：</p>
<p>假设投影平面是平面<span class="math inline">\(z=0\)</span>，投影点是<span class="math inline">\((0,0,-d)\)</span>。</p>
<p>那么，对于三维空间中的点<span class="math inline">\((x,y,z)\)</span>，透视投影将其唯一投影到二维平面中的<span class="math inline">\((x^{\ast},y^{\ast})\)</span>。其中</p>
<p><span class="math display">\[
\begin{aligned}
    x^{\ast}&amp;=\frac{x}{1+z/d} \\
    y^{\ast}&amp;=\frac{y}{1+z/d}    
\end{aligned}
\]</span></p>
<p>在现实当中，投影平面的大小是有限的，如果投影平面的大小是<span class="math inline">\(w\times h\)</span>（且以<span class="math inline">\(z\)</span>轴为中心），那么<span class="math inline">\(\theta_w=2\arctan\frac{w}{2d}\)</span>被称作水平方向上的<strong>视场</strong>（FoV），垂直方向上的视场定义类似。对于一个相同的摄像头，其视场一般可以看做一个常数（不同的焦距可能会导致些许变化）。以像素为单位，我的手机画幅是<span class="math inline">\(3024\times 4032\)</span>，<span class="math inline">\(d\approx 3800\)</span>。那么水平视场大概就在<span class="math inline">\(45^{\circ}\)</span>左右。</p>
<p>在清楚透视投影的定义之后，这一篇文章的任务就变成了：</p>
<p><strong>寻找满足一定约束条件的若干顶点的三维坐标，使其作为书页的边缘，其透视投影点恰对应图片上的点。</strong></p>
<h1 id="假设">假设</h1>
<p>为了适当简化问题，在此做出以下的假设：</p>
<ol type="1">
<li><p>纸页竖直的两边<strong>等长</strong>。</p></li>
<li><p>纸页竖直的两边<strong>平行</strong>。（<strong>注：</strong> 实际情况并不总是如此，但是让纸满足这个条件比把书压平总是容易得多了）</p></li>
<li><p>用户已经人工以某种形式标记出了图上一些关键点的坐标。即暂时不考虑自动检测书页（这也是一个大坑）。</p></li>
</ol>
<h1 id="明确问题">明确问题</h1>
<p>如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/alan20210202/images/master/2019/12/26-18-45-20-Points1.png" /></p>
<p>我们已经手动标记出页面四角<span class="math inline">\(A,B,C,D\)</span>的投影点<span class="math inline">\(A^{\ast}(x_1,y_1),B^{\ast}(x_2,y_2),C^{\ast}(x_3,y_3),D^{\ast}(x_4,y_4)\)</span>。在这篇文章当中我们的目标是反推出<span class="math inline">\(A,B,C,D\)</span>以及平面。</p>
<p>假设<span class="math inline">\(O\)</span>是坐标原点，以后会一直用<span class="math inline">\(\vec{OP}\)</span>表示点<span class="math inline">\(P\)</span>的坐标向量。</p>
<h1 id="解决问题">解决问题</h1>
<h2 id="算法直觉乱搞流">算法直觉乱搞流</h2>
<p>第一想法：啊？四个三维点？那就是12个参数咯？上启发式算法乱搞一波模拟退火遗传粒子群似乎就可以解决？<del>当场否决</del></p>
<p>然后我们注意到<strong>投影点为定点的三维点的轨迹一定是一条过视点<span class="math inline">\(P\)</span>的直线。</strong> 所以其实只有4个参数——启发式算法成功可能性微存？</p>
<p>启发式优化算法毕竟不靠谱，我们还是一步一步来，比如说我们假设已经确定了<span class="math inline">\(A\)</span>的<span class="math inline">\(z\)</span>坐标<span class="math inline">\(z_1\)</span>（显然<span class="math inline">\(A\)</span>的其他坐标也因此确定）。怎么确定我们暂且不管，反正最后大不了枚举。</p>
<p>然后呢？似乎还是没有头绪？</p>
<p>那我们继续假设已经确定了<span class="math inline">\(B\)</span>的<span class="math inline">\(z\)</span>坐标<span class="math inline">\(z_2\)</span>。怎么确定我们一样暂且不管。</p>
<p>现在我们已经可以算出<span class="math inline">\(\vec{BA}\)</span>。显然<span class="math inline">\(\vec{CD}=\vec{BA}\)</span>，因此接下来只要我们知道<span class="math inline">\(C\)</span>的坐标，<span class="math inline">\(D\)</span>的坐标随之确定。我们可以通过计算<span class="math inline">\(D\)</span>投影点<span class="math inline">\({D^{\ast}}&#39;\)</span>和实际<span class="math inline">\(D^{\ast}\)</span>的距离，得到我们解的误差<span class="math inline">\(E\)</span>，即</p>
<p><span class="math display">\[
E={D^{\ast}}&#39;D^{\ast}
\]</span></p>
<p>那么怎么算出<span class="math inline">\(C\)</span>的坐标呢？</p>
<p>这个时候直觉是一个好东西。我断定：<strong>误差<span class="math inline">\(E\)</span>关于<span class="math inline">\(C\)</span>的<span class="math inline">\(z\)</span>坐标<span class="math inline">\(z_3\)</span>单峰。</strong></p>
<p>为什么？因为<span class="math inline">\(C\)</span>的轨迹不是过<span class="math inline">\(P\)</span>的直线吗，因此<span class="math inline">\(D\)</span>经过<span class="math inline">\(C\)</span>平移<span class="math inline">\(\vec{CD}=\vec{AB}\)</span>的轨迹也是一条直线。<strong>直线的投影还是直线。</strong> 因此，当<span class="math inline">\(z_3\)</span>增加，<span class="math inline">\(C\)</span>在直线上向后移动，<span class="math inline">\(D\)</span>也在直线上向后移动，其投影点<span class="math inline">\({D^{\ast}}&#39;\)</span>也在投影平面的直线上也一定沿某一特定方向移动。而二维平面内以个沿直线固定方向移动的点和直线外一定点<span class="math inline">\(D^{\ast}\)</span>的距离显然是单峰的。证毕。</p>
<p>既然是单峰的，那么<span class="math inline">\(C\)</span>的坐标就可以直接三分查找了呢，不用枚举nice。</p>
<p>那么<span class="math inline">\(B\)</span>的坐标呢？</p>
<p>直觉还是一个好东西。我再次断定：<strong>在<span class="math inline">\(C\)</span>最优的情况下，误差<span class="math inline">\(E\)</span>关于<span class="math inline">\(B\)</span>的<span class="math inline">\(z\)</span>坐标<span class="math inline">\(z_2\)</span>单峰。</strong></p>
<p>为什么？之前不是得到<span class="math inline">\(D\)</span>的轨迹也是直线吗？当<span class="math inline">\(B\)</span>前后移动时，<span class="math inline">\(\vec{BA}\)</span>也在变化。随着<span class="math inline">\(\vec{BA}\)</span>的变化，经过<span class="math inline">\(C\)</span>平移<span class="math inline">\(\vec{BA}\)</span>得到的<span class="math inline">\(D\)</span>的轨迹直线也在沿着某一方向平移（这个方向就是直线<span class="math inline">\(BP\)</span>的方向）。那么<span class="math inline">\({D^{\ast}}&#39;\)</span>在投影平面上的轨迹直线也在沿着某一方向平移。而二维平面内沿着一个特定方向移动的直线到一定点的<span class="math inline">\(D^{\ast}\)</span>的距离显然是单峰的。证毕。</p>
<p>哦豁，那么<span class="math inline">\(B\)</span>的坐标也好三分了咯，又一次避免了枚举，nice。</p>
<p>为了三分的快一点，可以把三分的定比分点设成<span class="math inline">\(\frac{3-\sqrt 5}{2}\)</span>，这样可以减少一半的计算次数（当然这就属于比较细节的优化了）。</p>
<p>接下来只剩下<span class="math inline">\(A\)</span>了，<span class="math inline">\(A\)</span>需要枚举吗？</p>
<p>需要，也不需要。</p>
<p>直觉上来说<span class="math inline">\(A,B,C,D\)</span>的坐标应当存在某种线性的关系，如下所示：</p>
<figure>
<img src="https://raw.githubusercontent.com/alan20210202/images/master/2019/12/24-21-45-38-Linear.png" alt="Linear.png" /><figcaption aria-hidden="true">Linear.png</figcaption>
</figure>
<p>即无论<span class="math inline">\(z_1\)</span>是多少，平面<span class="math inline">\(ABCD\)</span>的总是不会发生变化的，因此我们只要随便选取一个<span class="math inline">\(A\)</span>的坐标，通过二重三分把<span class="math inline">\(B,C,D\)</span>算出来就行了。</p>
<p>看着不错，计算量也不高。但是……似乎依赖直觉的地方还是太多了。</p>
<p>之前论证单调性的过程的insight似乎暗示这问题的解析解应该不难？于是……</p>
<h2 id="数学">数学</h2>
<p>设</p>
<p><span class="math display">\[
\vec{OA}=\begin{pmatrix}
\lambda_1x_1\\
\lambda_1y_1\\
(\lambda_1-1)d
\end{pmatrix},
\vec{OB}=\begin{pmatrix}
\lambda_2x_2\\
\lambda_2y_2\\
(\lambda_2-1)d
\end{pmatrix},
\vec{OC}=\begin{pmatrix}
\lambda_3x_3\\
\lambda_3y_3\\
(\lambda_3-1)d
\end{pmatrix}
\]</span></p>
<p>则有：</p>
<p><span class="math display">\[
\vec{BA}=\begin{pmatrix}
\lambda_1x_1-\lambda_2x_2\\
\lambda_1y_1-\lambda_2y_2\\
(\lambda_1-\lambda_2)d
\end{pmatrix}\Rightarrow\vec{OD}=\vec{OC}+\vec{BA}=\begin{pmatrix}
\lambda_3x_3-\lambda_2x_2+\lambda_1x_1\\
\lambda_3y_3-\lambda_2y_2+\lambda_1y_1\\
(\lambda_3-\lambda_2+\lambda_1-1)d
\end{pmatrix}
\]</span></p>
<p>那么其二维投影：</p>
<p><span class="math display">\[
\vec{OD^*}=\begin{pmatrix}
\frac{\lambda_3x_3-\lambda_2x_2+\lambda_1x_1}{\lambda_3-\lambda_2+\lambda_1}\\
\frac{\lambda_3y_3-\lambda_2y_2+\lambda_1y_1}{\lambda_3-\lambda_2+\lambda_1}
\end{pmatrix}=\begin{pmatrix}
x_4\\
y_4
\end{pmatrix}
\]</span></p>
<p>然后，就可以列方程：</p>
<p><span class="math display">\[
\begin{cases}
\lambda_3x_3-\lambda_2x_2+\lambda_1x_1=(\lambda_3-\lambda_2+\lambda_1)x_4\\
\lambda_3y_3-\lambda_2y_2+\lambda_1y_1=(\lambda_3-\lambda_2+\lambda_1)y_4
\end{cases}
\]</span></p>
<p>整理一下：</p>
<p><span class="math display">\[
\begin{cases}
(x_2-x_4)\lambda_2-(x_3-x_4)\lambda_3=(x_1-x_4)\lambda_1\\
(y_2-y_4)\lambda_2-(y_3-y_4)\lambda_3=(y_1-y_4)\lambda_1
\end{cases}
\]</span></p>
<p>也就是：</p>
<p><span class="math display">\[
\begin{pmatrix}
\vec{OB}-\vec{OD} &amp;\vec{OD}-\vec{OC}
\end{pmatrix}
\begin{pmatrix}
\lambda_2\\
\lambda_3
\end{pmatrix}=
(\vec{OA}-\vec{OD})\lambda_1
\]</span></p>
<p>最后只要解一下这个二元线性方程就可以了。</p>
<p>看来这个问题其实没有我想象的那样复杂啊。一开始直觉告诉我这东西解析解算起来很麻烦甚至不存在解析解，所以先从算法角度分析了一波。第二天开始想几个直觉结论的证明的时候才意识到似乎解析解不难算，后来发现正是如此。</p>
<h1 id="结果">结果</h1>
<p>最后的结果如下所示，加了法向量组成长方体证明确实这个建模没有问题。</p>
<figure>
<img src="https://raw.githubusercontent.com/alan20210202/images/master/2019/12/26-20-20-02-Marked.jpg" alt="Marked.jpg" /><figcaption aria-hidden="true">Marked.jpg</figcaption>
</figure>
<p>下一篇文章大概会写如何基于这些信息计算纸面弯曲的参数方程吧……</p>
<p>但是手动标点这种东西四个点一个一个画图上查然后输入还可以忍受，标定横向边缘好几个点实在是懒啊……或许会先写一个标点的工具吧……</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2019/12/21/LU/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/21/LU/" class="post-title-link" itemprop="url">LU分解笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2019-12-21 14:04:53 / 修改时间：14:19:14" itemprop="dateCreated datePublished" datetime="2019-12-21T14:04:53+08:00">2019-12-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="矩阵向量相乘的意义">矩阵向量相乘的意义</h1>
<p>这部分和LU分解没有多大关系，但是GS的书里一直强调这种理解，想必是极有用的。</p>
<p>当矩阵左乘一个列向量，其结果等同于矩阵每一列以列向量为权的线性组合，例如 <span class="math display">\[
\begin{pmatrix}
    1&amp;2&amp;3\\
    4&amp;5&amp;6\\
    7&amp;8&amp;9\\
\end{pmatrix}
\begin{pmatrix}
1\\
2\\
3
\end{pmatrix}
=
1\begin{pmatrix}
1\\4\\7
\end{pmatrix}
+2\begin{pmatrix}
2\\5\\8
\end{pmatrix}
+3\begin{pmatrix}
3\\6\\9
\end{pmatrix}
\]</span> 类似地，当矩阵右乘一个行向量，其结果等于矩阵每一行以行向量为权的线性组合，例如 <span class="math display">\[
\begin{pmatrix}
1&amp;2&amp;3
\end{pmatrix}
\begin{pmatrix}
    1&amp;2&amp;3\\
    4&amp;5&amp;6\\
    7&amp;8&amp;9\\
\end{pmatrix}
=\begin{matrix}
1\begin{pmatrix}
1&amp;2&amp;3
\end{pmatrix}\\
+\\
2\begin{pmatrix}
4&amp;5&amp;6
\end{pmatrix}\\+\\
3\begin{pmatrix}
7&amp;8&amp;9
\end{pmatrix}
\end{matrix}
\]</span> 多列，多行的情况也可以以此类推。</p>
<h1 id="初等行变换的矩阵表示">初等行变换的矩阵表示</h1>
<p>注意到初等行变换可以使用矩阵进行表示，例如在一个<span class="math inline">\(3\times 3\)</span>的矩阵当中把第<span class="math inline">\(1\)</span>行的<span class="math inline">\(3\)</span>倍加到第二行就可以表示为： <span class="math display">\[
\begin{pmatrix}
1&amp;0&amp;0 \\
3&amp;1&amp;0 \\
0&amp;0&amp;1
\end{pmatrix}
\begin{pmatrix}
1&amp;2&amp;3 \\
4&amp;5&amp;6 \\
7&amp;8&amp;9
\end{pmatrix}
=\begin{pmatrix}
1&amp;2&amp;3 \\
7&amp;11&amp;15 \\
7&amp;8&amp;9
\end{pmatrix}
\]</span> <strong>注意行变换的矩阵是左乘的，右乘就是列变换了！</strong></p>
<p>具体来说，如果你把第<span class="math inline">\(i\)</span>行的<span class="math inline">\(k\)</span>倍加到第<span class="math inline">\(j\)</span>行上，那么这个变换对应的矩阵就是在以单位矩阵为基础上<span class="math inline">\(a_{j,i}=k\)</span>。</p>
<p>初等行变换的矩阵常用符号<span class="math inline">\(E\)</span>表示。</p>
<p>由于初等行变换的意义，很容易就可以看出其逆矩阵就是把对应的元素取反，加上的我们就减回去： <span class="math display">\[
E=\begin{pmatrix}
1&amp;0&amp;0 \\
3&amp;1&amp;0 \\
0&amp;0&amp;1
\end{pmatrix}\Rightarrow 
E^{-1}=\begin{pmatrix}
1&amp;0&amp;0 \\
-3&amp;1&amp;0 \\
0&amp;0&amp;1
\end{pmatrix}
\]</span></p>
<h1 id="矩阵的lu分解">矩阵的LU分解</h1>
<p>在学习初等行变换的矩阵表示之后再回头考虑我们对着<span class="math inline">\(n\times n\)</span>矩阵<span class="math inline">\(A\)</span>做消元得到上三角阵<span class="math inline">\(U\)</span>的过程，我们就会发现，<strong>在消元过程不涉及交换两行的时候，</strong>消元过程可以表示为： <span class="math display">\[
E_{n,n-1}\cdots E_{31}E_{21}A=U
\]</span> 其中<span class="math inline">\(E_{21}\)</span>表示我们把<span class="math inline">\(a_{21}\)</span>消为<span class="math inline">\(0\)</span>所运用的行变换。</p>
<p>注意到在消元的时候我们是按照<span class="math inline">\(E_{21}, E_{31},\cdots\)</span>这个顺序消过来的，但是因为行变换是左乘，因此上式当中从左到右序号是反的。</p>
如果<span class="math inline">\(A\)</span>确实可以顺顺利利地消成<span class="math inline">\(U\)</span>，那说明<span class="math inline">\(E_{n,n-1}\cdots E_{31}E_{21}\)</span>是可逆的，即： $$
<span class="math display">\[\begin{aligned}
A&amp;=(E_{n,n-1}\cdots E_{31}E_{21})^{-1}U\\ 
&amp;=E_{21}^{-1}E_{31}^{-1}\cdots E_{n,n-1}^{-1}U

\end{aligned}\]</span>
<p><span class="math display">\[
不妨令$L=E_{21}^{-1}E_{31}^{-1}\cdots E_{n,n-1}^{-1}$，则矩阵$A$可以写作：
\]</span> A=LU $$ 这就被称为矩阵<span class="math inline">\(A\)</span>的<span class="math inline">\(LU\)</span>分解。</p>
<p>其中<span class="math inline">\(U\)</span>是上三角阵无疑，而<span class="math inline">\(L\)</span>，其字母暗示我们这是一个<strong>下三角阵</strong>。</p>
<p>不仅如此，比如说对于<span class="math inline">\(3\)</span>阶方阵消元共三步： <span class="math display">\[
E_{21}^{-1} = \begin{pmatrix}
1&amp;0&amp;0\\
a&amp;1&amp;0\\
0&amp;0&amp;1
\end{pmatrix}
,
E_{31}^{-1} = \begin{pmatrix}
1&amp;0&amp;0\\
0&amp;1&amp;0\\
b&amp;0&amp;1
\end{pmatrix}
,
E_{32}^{-1} = \begin{pmatrix}
1&amp;0&amp;0\\
0&amp;1&amp;0\\
0&amp;c&amp;1
\end{pmatrix}
\]</span> 计算<span class="math inline">\(L\)</span>可得 <span class="math display">\[
L=\begin{pmatrix}
1&amp;0&amp;0\\
a&amp;1&amp;0\\
0&amp;0&amp;1
\end{pmatrix}\begin{pmatrix}
1&amp;0&amp;0\\
0&amp;1&amp;0\\
b&amp;0&amp;1
\end{pmatrix}\begin{pmatrix}
1&amp;0&amp;0\\
0&amp;1&amp;0\\
0&amp;c&amp;1
\end{pmatrix}=\begin{pmatrix}
1&amp;0&amp;0\\
a&amp;1&amp;0\\
b&amp;c&amp;1
\end{pmatrix}
\]</span> <span class="math inline">\(L\)</span>在形式上就是把<strong>所有行变换矩阵“拼起来“</strong>！矩阵乘法平常都会把矩阵里面的数字形式破坏掉，这次为什么那么奇妙呢？</p>
<p><strong>从消元的角度，可以这么理解：</strong></p>
<p>我们能够把两个行变换矩阵“拼”起来，当且仅当一个变换的结果不会改变另一个变换的源。</p>
<p>什么意思？如果<span class="math inline">\(E_1\)</span>把第<span class="math inline">\(2\)</span>行的<span class="math inline">\(3\)</span>倍加到第<span class="math inline">\(2\)</span>行，<span class="math inline">\(E_2\)</span>把第<span class="math inline">\(1\)</span>行的<span class="math inline">\(2\)</span>倍加到第<span class="math inline">\(2\)</span>行。</p>
<p>如果我们先做<span class="math inline">\(E_1\)</span>再做<span class="math inline">\(E_2\)</span>即<span class="math inline">\(E_2E_1\)</span>，那么这个时候我们是可以直接拼起来的。因为先做的<span class="math inline">\(E_1\)</span>没有改变<span class="math inline">\(E_2\)</span>所依赖的第<span class="math inline">\(2\)</span>行。但是先做<span class="math inline">\(E_2\)</span>再做<span class="math inline">\(E_1\)</span>即<span class="math inline">\(E_1E_2\)</span>就不能直接拼起来，因为先做的<span class="math inline">\(E_2\)</span>把<span class="math inline">\(E_1\)</span>所依赖的第<span class="math inline">\(2\)</span>行改掉了。</p>
<p>然后我们发现在<span class="math inline">\(LU\)</span>分解里面我们是先改第<span class="math inline">\(n\)</span>行，再改第<span class="math inline">\(n-1\)</span>行这样从下到上地变换上去的。改变第<span class="math inline">\(n\)</span>行的变换只会依赖于前<span class="math inline">\(n-1\)</span>行，因此出不了问题。</p>
<p><strong>从纯计算的角度，可以这么解释：</strong></p>
<p>考虑矩阵乘法<span class="math inline">\(L=EL&#39;\)</span>，其中<span class="math inline">\(E\)</span>是一个行变换矩阵且假设其中<span class="math inline">\(E_{ik}=a\)</span>，<span class="math inline">\(L&#39;\)</span>是下三角阵。</p>
则考虑<span class="math inline">\(L\)</span>第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列的值<span class="math inline">\(L_{ij}\)</span>（除了第<span class="math inline">\(i\)</span>行，结果的其他行显然等于<span class="math inline">\(L&#39;\)</span>），必然是<span class="math inline">\(E\)</span>的行向量与<span class="math inline">\(L&#39;\)</span>列向量之点乘： $$ L_{ij}=
<span class="math display">\[\begin{pmatrix}
0 \\
\vdots \\
a\\
\vdots \\
\color{red}1\\
\vdots\\
0
\end{pmatrix}
\cdot
\begin{pmatrix}
0 \\
\vdots \\

\color{blue}1 \\
\vdots \\
b \\
c \\
\vdots \\
\end{pmatrix}\]</span>
<p>$$</p>
<p>由于三角阵主对角线上都是<span class="math inline">\(1\)</span>，在上式中左边向量里面的<span class="math inline">\(\color{red}1\)</span>就是从上往下数第<span class="math inline">\(i\)</span>个，右边向量里面的<span class="math inline">\(\color{blue}1\)</span>就是从上往下数第<span class="math inline">\(j\)</span>个。因为是下三角阵<span class="math inline">\(\color{red}1\)</span>的下面都是<span class="math inline">\(0\)</span>，<span class="math inline">\(\color{blue}1\)</span>的上面也都是<span class="math inline">\(0\)</span>。接下来讨论<span class="math inline">\(\color{red}1\)</span>和<span class="math inline">\(\color{blue} 1\)</span>的位置关系。</p>
<ul>
<li><span class="math inline">\(i&lt;j\)</span>时，<span class="math inline">\(\color{red}1\)</span>在<span class="math inline">\(\color{blue}1\)</span>的上面。右侧<span class="math inline">\(\color{blue} 1\)</span>下面非零的元素对着左边的都是<span class="math inline">\(0\)</span>，左侧<span class="math inline">\(\color{red}1\)</span>上面的非零<span class="math inline">\(a\)</span>对到右边也是<span class="math inline">\(0\)</span>，因此<span class="math inline">\(L_{ij}=0\)</span>。</li>
<li><span class="math inline">\(i=j\)</span>时，<span class="math inline">\(\color{red} 1\)</span>正对着<span class="math inline">\(\color{blue}1\)</span>，因此<span class="math inline">\(L_{ij}=1\times 1=1\)</span>。</li>
<li><span class="math inline">\(i&gt;j\)</span>时，<span class="math inline">\(\color{red} 1\)</span>在<span class="math inline">\(\color{blue}1\)</span>的下面。<span class="math inline">\(a\)</span>是左侧从上往下数第<span class="math inline">\(k\)</span>个。
<ul>
<li><span class="math inline">\(j&gt;k\)</span>时，<span class="math inline">\(\color{blue}1\)</span>在<span class="math inline">\(a\)</span>下面，<span class="math inline">\(a\)</span>对着<span class="math inline">\(0\)</span>。<span class="math inline">\(L_{ij}=L&#39;_{ij}\)</span>。</li>
<li><span class="math inline">\(j=k\)</span>时，<span class="math inline">\(a\)</span>对着<span class="math inline">\(\color{blue}1\)</span>，<span class="math inline">\(\color{red}1\)</span>对着<span class="math inline">\(L&#39;_{ij}，\)</span><span class="math inline">\(L_{ij}=a+L&#39;_{ij}\)</span>。</li>
<li><span class="math inline">\(j&lt;k\)</span>时，<span class="math inline">\(a\)</span>对着<span class="math inline">\(L&#39;_{kj}\)</span>，<span class="math inline">\(\color{red}1\)</span>对着<span class="math inline">\(L&#39;_{ij}\)</span>。<span class="math inline">\(L_{ij}=aL&#39;_{kj}+L&#39;_{ij}\)</span>。</li>
</ul></li>
</ul>
<p>显然，当我们向左边一个一个行变换矩阵乘过来的时候，<span class="math inline">\(L&#39;_{ij}=0\)</span>，且<span class="math inline">\(L&#39;_{kj}=0\quad \forall j&lt;k\)</span>。于是乎 <span class="math display">\[
L_{ij} = \begin{cases}
0, &amp; i&lt;j\\
1, &amp; i=j\\
L&#39;_{ij}, &amp;k&lt;j&lt;i \\
a, &amp; j=k\\
0, &amp; j&lt;k\\
\end{cases}
\]</span> 这就是把<span class="math inline">\(a\)</span>直接放到<span class="math inline">\(L&#39;\)</span>的对应位置里面。结合数学归纳法，可以导出<span class="math inline">\(LU\)</span>分解的结果确实就是几个行变换矩阵“拼起来”。</p>
<h1 id="矩阵的ldu分解">矩阵的LDU分解</h1>
<p>注意到在<span class="math inline">\(A=LU\)</span>当中，我们虽然保证了<span class="math inline">\(L\)</span>的主对角线是上<span class="math inline">\(1\)</span>，但是<span class="math inline">\(U\)</span>的主对角线上就未必了。</p>
<p>假设<span class="math inline">\(U\)</span>的主对角线上的数是<span class="math inline">\(d_1,d_2,\cdots,d_n\)</span>，那么不妨令： <span class="math display">\[
U=DU&#39;
\]</span> 其中 <span class="math display">\[
D=\begin{pmatrix}
d_1&amp;0&amp;\cdots&amp;0\\
0&amp;d_2&amp;\cdots&amp;0\\
\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
0&amp;0&amp;\cdots&amp;d_n\\
\end{pmatrix}
\]</span> 而<span class="math inline">\(U&#39;\)</span>是<span class="math inline">\(U\)</span>每一行分别除以<span class="math inline">\(d_1,d_2,\cdots,d_n\)</span>的结果。</p>
<p>这样一来分解就变成了 <span class="math display">\[
A=LDU&#39;
\]</span></p>
<p>这种分解就被称作矩阵<span class="math inline">\(A\)</span>的<span class="math inline">\(LDU\)</span>分解。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2019/12/16/Nginx%20Proxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/16/Nginx%20Proxy/" class="post-title-link" itemprop="url">Nginx带子路径的反向代理配置文件的正确写法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2019-12-16 22:10:03 / 修改时间：22:09:49" itemprop="dateCreated datePublished" datetime="2019-12-16T22:10:03+08:00">2019-12-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近折腾服务器把Aria2、H5AI、Jellyfin、Jupyter等集合到一个端口访问（因为开端口映射实在是一件麻烦事），于是需要经常用到Nginx的反向代理。之前的配置文件的效果一直都不是最完美，瑕疵体现在redirect之后就会忽略到子路径导致404。在网上多方搜索之后我终于找到了一个总体靠谱的写法（感觉Nginx的流行度还是比不上Apache），记下来留自己备用。</p>
<pre class="line-numbers"><code class="language-nginx">location /SUB_PATH &#123;
    return 302 $scheme://$host:$port/SUB_PATH/;
&#125;
location /SUB_PATH/ &#123;
    proxy_pass xxxxx;
    proxy_pass_request_headers on;
    proxy_redirect ~^/(.*) $scheme://$host:$port/SUB_PATH/$1;        
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $http_host;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $http_connection;
    # proxy_buffering off; 
&#125;</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chengyuan Ma</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js" integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha512-br8H6OngKoLht57WKRU5jz3Vr0vF+Tw4G6yhNN2F3dSDheq4JiaasROPJB1wy7PxPk7kV/+5AIbmoZLxxx7Zow==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-bash.min.js" integrity="sha512-JvRd44DHaJAv/o3wxi/dxhz2TO/jwwX8V5/LTr3gj6QMQ6qNNGXk/psoingLDuc5yZmccOq7XhpVaelIZE4tsQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-c.min.js" integrity="sha512-T6Lco61aWqCKSznWkd38lf159pD0+EwZ9UCEv6ARAvaWFiy/UHtYgOmlasT8lq5Ck17ZNHzbe5eHUablTGRXxw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cmake.min.js" integrity="sha512-M99z3be36IUB5pA3DWoJvjSYaZA9BiUqf1jXzVcjntASBZFNI53oDRzdJqGzH5voybcAx5Sg8F5QyryE6afD3g==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cpp.min.js" integrity="sha512-hxZJ6OUEpUl9/o4C1gMGvrAbeqDaldBiZbs08c/V8NcU7YImBFlqJAc7Uzjf3bh2W8Wx26/dVDyPk9cUMQY0Mw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-go.min.js" integrity="sha512-SgF1uayJ2/8TV+MhLasqygnm++vYRXswmrR2ZAmUCL4pXtf+6KzUgXPpn10Y6xca658sxOQEOsoP3MChfhke5A==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-java.min.js" integrity="sha512-PWHY6Vao4E9K4LsGBYCY0ttDeiWZwuUozTbJvSy9UFHRz2J4Bl7rcWML3wEnJTVuCJhSwGne/8My5gTo/gnbpg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-json.min.js" integrity="sha512-IC7rV8RslChgByOdUFC6ePqOGn+OwJhnKC3S5AezM8DAiOdGhJMwgsIvBChsa2yuxxoPbH2+W/kjNUM1cc+jUQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-kotlin.min.js" integrity="sha512-aTozTdtORp/xxS/dhRRDfmv/p1eyEMTje96MplkSOqdbKGGvOYIlogoGdtsh/BD91vaqKoAw9M7O/DodqqudIQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-julia.min.js" integrity="sha512-eTGeKQdDzC2rPAUVfM2Fa36s9B9wp138NEhzZqJpRSdJQ66BwLUot25r2YQveCRU5uYNVfX3gckDkl4byfBIWw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-latex.min.js" integrity="sha512-6D3l3Fy8g/hr6AeK2g1rcVZHyFjCqiqgUrwy0mBZTGFd8UwVcUDhzQeIIv3eYeXDecGPTtBOS9ctyRzJyUgypQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-rust.min.js" integrity="sha512-kgT7r2HlCEO4b+Rp3nJvm+/EMBwGMvv1WMdWkb3eNgnS91llMli8Y3T1CgnD8Hifqx50Q3XLUQXDd7PzKQQtUA==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-python.min.js" integrity="sha512-wK9tQmDrstGtZqTKcyVf3h457QGMlNriKs+fHmEkiCizrq0LVovfT3v1smeT1DlQetHhdRkkX1JSuZg5LoNHJg==" crossorigin="anonymous"></script>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



</body>
</html>
