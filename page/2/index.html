<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"alan20210202.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="不务正业高中生一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="Chengyuan Ma&#39;s Blog">
<meta property="og:url" content="https://alan20210202.github.io/page/2/index.html">
<meta property="og:site_name" content="Chengyuan Ma&#39;s Blog">
<meta property="og:description" content="不务正业高中生一枚">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chengyuan Ma">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://alan20210202.github.io/page/2/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.css" integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbggqjHJeyzx88I3rfwjS38WJag/ihH7lzuGlGHpDBymLirZQ==" crossorigin="anonymous" />
<title>Chengyuan Ma's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-65HSG5NCY6"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-65HSG5NCY6');
      }
    </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Chengyuan Ma's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-pagedewarp"><a href="/dewarp/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>PageDewarp</a></li>
        <li class="menu-item menu-item-english"><a href="/english/" rel="section"><i class="fa fa-globe-americas fa-fw"></i>English</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chengyuan Ma"
      src="/avatar.png">
  <p class="site-author-name" itemprop="name">Chengyuan Ma</p>
  <div class="site-description" itemprop="description">不务正业高中生一枚</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">94</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://kalasearch.cn/" title="https:&#x2F;&#x2F;kalasearch.cn&#x2F;" rel="noopener" target="_blank">卡拉搜索</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/03/15/Polya/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/15/Polya/" class="post-title-link" itemprop="url">Polya计数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-15 05:28:20" itemprop="dateCreated datePublished" datetime="2021-03-15T05:28:20-04:00">2021-03-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="引入">引入</h1>
<p>给定一串<span class="math inline">\(n\)</span>个珠子组成的环链，每个珠子可以被染成黑白两色，求<strong>本质不同</strong>的染色方案的个数？</p>
<h1 id="群置换和置换群">群，置换和置换群</h1>
<h2 id="群的不严谨定义">群的不严谨定义</h2>
<p>如果我们对于一个集合<span class="math inline">\(G\)</span>定义一种运算<span class="math inline">\(\cdot\)</span> ，该运算满足以下性质：</p>
<ol type="1">
<li>封闭性：<span class="math inline">\(\forall a, b \in G, a \cdot b \in G\)</span></li>
<li>结合律：<span class="math inline">\(\forall a, b, c \in G, (a \cdot b) \cdot c = a \cdot (b \cdot c)\)</span></li>
<li>单位元：<span class="math inline">\(\exists e \in G, \forall a \in G, e \cdot a = a\)</span></li>
<li>逆元：<span class="math inline">\(\forall a \in G, \exists a^{-1} \in G, a \cdot a^{-1} = e\)</span></li>
</ol>
<p>则称<span class="math inline">\((G, \cdot)\)</span>一起构成了一个<strong>群</strong>。</p>
<h2 id="置换的概念">置换的概念</h2>
<p>我们抽象并拓展“变换”这个概念，定义集合<span class="math inline">\(G \to G\)</span>的一个双射为一个<strong>置换</strong>，举个例子： <span class="math display">\[
\left(\begin{matrix}
1 &amp;2 &amp;3 &amp;4 \\
2 &amp;3 &amp;4 &amp;1
\end{matrix}\right)
\]</span> 这个置换表示将将集合中的<span class="math inline">\(1\)</span>变成<span class="math inline">\(2\)</span>，<span class="math inline">\(2\)</span>变成<span class="math inline">\(3\)</span>，<span class="math inline">\(3\)</span>变成<span class="math inline">\(4\)</span>，<span class="math inline">\(4\)</span>变成<span class="math inline">\(1\)</span>。</p>
<h2 id="置换群">置换群</h2>
<p>稍微想一想可知，置换是可以成群的，称为置换群，对于这个置换群我们定义的运算就是<strong>置换的复合</strong>，对于这个运算我们考察其是否满足群的性质：</p>
<ol type="1">
<li>封闭性：大部分情况下应该是成立的</li>
<li>结合律：显然</li>
<li>单位元：<span class="math inline">\(\left(\begin{matrix} 1 &amp;2 &amp;3 &amp;\cdots \\ 1 &amp;2 &amp;3 &amp; \cdots \end{matrix}\right)\)</span></li>
<li>逆元：置换是集合到集合的<strong>双射</strong>，显然</li>
</ol>
<p>置换群的引入允许我们使用群论来处理一开始的问题，说抽象了我们刚才的问题就是：<strong>求一个序列的集合<span class="math inline">\(X\)</span>，在一个置换群<span class="math inline">\(G\)</span>作用下本质不同的元素个数</strong>。</p>
<h1 id="burnside引理">Burnside引理</h1>
<p>序列集合<span class="math inline">\(X\)</span>在置换群<span class="math inline">\(G\)</span>的作用下不同的序列数等于<strong>不动点的平均数</strong>： <span class="math display">\[
|X \setminus G| = \frac{1}{|G|} \sum_{g \in G} |X^g|
\]</span> 其中<span class="math inline">\(X^g = \{ x \in X | g(x) = x\}\)</span>表示在置换<span class="math inline">\(g\)</span>作用下不动点的集合，何为不动点呢？</p>
<p>例如对于置换<span class="math inline">\(\left(\begin{matrix} 1 &amp;2 &amp;3 &amp;4 \\ 3 &amp;4 &amp;1 &amp; 2 \end{matrix}\right)\)</span>而言，序列<span class="math inline">\((1, 2, 1, 2)\)</span>就是它的一个不动点，因为它在置换后还是原来的样子。</p>
<p>我们接下来考察对于给定置换如何数出不动点的数目，从例子入手，比如说我们要求的是置换,<span class="math inline">\(\left(\begin{matrix} 1 &amp;2 &amp;3 &amp;4 \\ 4 &amp;3 &amp;2 &amp; 1 \end{matrix}\right)\)</span>的不动点数目，我们挨个考虑这样的序列拥有什么样的性质：</p>
<ol type="1">
<li>第一位与第四位相同</li>
<li>第二位与第三位相同</li>
<li>第三位与第二位相同</li>
<li>第四位与第一位相同</li>
</ol>
<p>显然我们最后得到了一个集合<span class="math inline">\(\{ \{1, 4\}, \{2, 3\} \}\)</span>，其中的每一个集合中的元素必须相等，考虑染色问题，对于每一组“相等”，我们可以把它整个染成两种颜色，因此这个置换共有<span class="math inline">\(2^2 = 4\)</span>个不动点。</p>
<p>由于等号的传递性，如果我们逐位查看一个置换，把上下的两位并入同一个“相等集合”，那么最后我们一定会得到若干个这样的相等集合，每个“相等集合”都可以被独立地染成不同的颜色，由乘法定理，我们就得到了——</p>
<h1 id="polya定理">Polya定理</h1>
<p><span class="math display">\[
|X \backslash G| = \frac{1}{|G|} \sum_{g \in G} m^{c(g)}
\]</span></p>
<p>其中<span class="math inline">\(m\)</span>是颜色个数，<span class="math inline">\(c(g)\)</span>是置换<span class="math inline">\(g\)</span>形成的“循环数”，一个“循环”是指某一位经过不断地置换之后最后回到自身。可以看到Polya定理其实就是我们上面的推论，不需要更多解释。</p>
<h1 id="循环同构序列计数">循环同构序列计数</h1>
<p>终于进入了我们的正题，循环同构序列计数，到这一步我们终于可以解答一开始的问题了：</p>
<p>Polya定理的精髓就在于求出一个置换的循环数，而朴素的枚举显然是不够的，我们考察所谓“循环同构”背后依赖的哪些置换，比如说对于一个长度为<span class="math inline">\(4\)</span>的序列，以下置换后它与自身是循环同构的： <span class="math display">\[
\left(\begin{matrix} 
    1 &amp;2 &amp;3 &amp;4 \\ 
    2 &amp;3 &amp;4 &amp;1 
\end{matrix}\right),
\left(\begin{matrix} 
    1 &amp;2 &amp;3 &amp;4 \\ 
    3 &amp;4 &amp;1 &amp;2 
\end{matrix}\right),
\left(\begin{matrix} 
    1 &amp;2 &amp;3 &amp;4 \\ 
    4 &amp;1 &amp;2 &amp;3 
\end{matrix}\right),
\left(\begin{matrix} 
    1 &amp;2 &amp;3 &amp;4 \\ 
    1 &amp;2 &amp;3 &amp;4 
\end{matrix}\right)
\]</span> 我们发现一个循环同构的置换就是把它的<em>后面全部移到前面来，前面几位补到后面去</em>。</p>
<p>为了接下来的推导方便我们让位数起始于<span class="math inline">\(0\)</span>。</p>
<p>那么，对于一个偏移了<span class="math inline">\(k\)</span>的置换，第<span class="math inline">\(a\)</span>位被置换之后就到了<span class="math inline">\((a + k) \bmod n\)</span>的位置，其中<span class="math inline">\(n\)</span>为序列长度，而对于一个长度为<span class="math inline">\(l\)</span>的完整循环来说，它必须满足：</p>
<p><span class="math display">\[
\begin{aligned}
a + kl &amp;\equiv a &amp;\pmod{n} \\
kl &amp;\equiv 0 &amp;\pmod{n}
\end{aligned}
\]</span> 显然当<span class="math inline">\(kl = \operatorname{lcm}(k, n)\)</span>的时候<span class="math inline">\(l\)</span>有最小值<span class="math inline">\(\frac{\operatorname{lcm}(k, n)}{k}\)</span>。由于每一位都偏移了<span class="math inline">\(k\)</span>位，因此置换中每个循环的长度都是相等的，而因为每个循环都cover了<span class="math inline">\(l\)</span>个元素，因此循环的个数为： <span class="math display">\[
\begin{aligned}
\frac{n}{l} &amp;= \frac{n}{\frac{\operatorname{lcm}(k, n)}{k}} \\
&amp;= \frac{kn}{\operatorname{lcm}(k, n)} \\
&amp;= \gcd(k, n)
\end{aligned}
\]</span> 这个发现让我们免于枚举每个循环置换，相反，我们枚举<span class="math inline">\(\gcd(k, n)\)</span>的每一个取值<span class="math inline">\(d\)</span>，即<span class="math inline">\(n\)</span>的因数，统计出<span class="math inline">\(\gcd(k, n) = d\)</span>的所有<span class="math inline">\(k\)</span>的个数，依Polya定理统一累加到答案上。</p>
<p>那怎么统计呢？枚举？</p>
<p>我们发现<span class="math inline">\(\gcd(k, n) = d\)</span>等价于<span class="math inline">\(\gcd({k \over d}, {n \over d}) = 1\)</span>，即小于<span class="math inline">\(n \over d\)</span>的与<span class="math inline">\(n \over d\)</span>互质的数个数，这显然等于<span class="math inline">\(\varphi({n \over d})\)</span>。</p>
<p>因此最后的答案就是：</p>
<p><span class="math display">\[
\sum_{d|n} \varphi\left(\frac{n}{d}\right)m^d
\]</span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/02/02/KCP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/02/KCP/" class="post-title-link" itemprop="url">Rust实现带BBR的高效魔改KCP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-02 08:21:02" itemprop="dateCreated datePublished" datetime="2021-02-02T08:21:02-05:00">2021-02-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>完整的代码<a target="_blank" rel="noopener" href="https://github.com/alan20210202/ekho/blob/e2c24b4504/src/kcp.rs">在此</a>。</p>
<h1 id="背景">背景</h1>
<p>最近我在用Rust写一个ICMP隧道，因为ICMP包本身是不可靠的，于是需要在ICMP之上写一个可靠协议。一个完整的TCP协议栈显然过于臃肿了（何况也并没有现成的无IO的轮子），所以我就看上了skywind3000大佬的<a target="_blank" rel="noopener" href="https://github.com/skywind3000/kcp">KCP协议</a>——轻量、简洁、代码连我这种网路萌新都看得懂，实在是再好不过了。</p>
<p>一开始是我直接使用原版的C实现+FFI封装，在不开流控的情况下效果不错，但可惜原版的拥塞控制用的是最朴素的TCP Tahoe（作者也表明出于简洁性考虑不准备在标准实现当中使用复杂的流控算法），其在国际网络环境下的表现实在差强人意。想改进，但自己对于自己C的编程水平实在是不抱信心。既然Rust也是性能一流的系统编程语言，我最终还是决定用Rust再写了一个实现。本实现具有以下特点：</p>
<ul>
<li>相较于C实现进行了架构上的些许调整。</li>
<li>在C实现的基础之上，使用链表+滚动数组优化大窗口下的发送性能。</li>
<li>在C实现的基础之上，使用小根堆优化RTO计时器的效率，提升重传性能。</li>
<li>将著名的BBR拥塞控制算法进行一定修改后试验性地运用到KCP中。</li>
</ul>
<h1 id="依赖的包">依赖的包</h1>
<p>为了使编写更加简便，我们的实现依赖以下Rust crates：</p>
<ul>
<li><code>bytes</code>——简便的字节处理（代替原来C实现当中的<code>encode_xxx</code>/<code>decode_xxx</code>）。</li>
<li><code>num_enum</code>——简化Rust枚举与字节的互相转换。</li>
<li><code>derivative</code>——简化一些trait的实现。</li>
<li><code>thiserror</code>——简化错误类型的定义。</li>
<li><code>rand</code>——用于BBR随机相位初始化。</li>
</ul>
<h1 id="架构上的调整">架构上的调整</h1>
<h2 id="常量与配置">常量与配置</h2>
<p>相对于C实现，本实现大幅减少了常量的数量。最后仅剩的常量有五：</p>
<pre class="line-numbers"><code class="language-rust">/// KCP包头大小
const OVERHEAD: u32 = 24;
/// 最大分段
const MAX_FRAGMENTS: u16 = 128;
/// KCP段类型
#[derive(Debug, Clone, Copy, TryFromPrimitive, IntoPrimitive)]
#[repr(u8)]
enum Command &#123;
    Push = 81,
    Ack = 82,
    AskWnd = 83,
    TellWnd = 84,
&#125;
/// BBR各阶段的增益
const BBR_GAIN_CYCLE: [usize; 8] = [5, 3, 4, 4, 4, 4, 4, 4];
/// BDP增益的分母，见后文
const BDP_GAIN_DEN: usize = 1024;</code></pre>
<p>常量少了，变量自然就多了，原来C实现的常量在本实现中成为可配置项：</p>
<pre class="line-numbers"><code class="language-rust">/// 大部分配置的意思如字面
#[derive(Clone, Debug, Deserialize, Derivative)]
#[derivative(Default)]
pub struct Config &#123;
    #[derivative(Default(value = &quot;536&quot;))]
    pub mtu: u32,
    #[derivative(Default(value = &quot;200&quot;))]
    pub rto_default: u32,
    #[derivative(Default(value = &quot;100&quot;))]
    pub rto_min: u32,
    #[derivative(Default(value = &quot;6000&quot;))]
    pub rto_max: u32,
    #[derivative(Default(value = &quot;7000&quot;))]
    pub probe_min: u32,
    #[derivative(Default(value = &quot;120000&quot;))]
    pub probe_max: u32,
    #[derivative(Default(value = &quot;1024&quot;))]
    pub send_wnd: u16,
    #[derivative(Default(value = &quot;1024&quot;))]
    pub recv_wnd: u16,
    #[derivative(Default(value = &quot;40&quot;))]
    pub interval: u32,
    /// 若一个包重传dead_link_thres次后依然失败，则视作底层链路失效。
    #[derivative(Default(value = &quot;20&quot;))]
    pub dead_link_thres: u32,
    /// nodelay模式下, rto_min = 0且rto在重传失败后不指数增长。
    #[derivative(Default(value = &quot;false&quot;))]
    pub nodelay: bool,
    /// stream模式下, 多个数据包可以被合并在同一段内从而减少开销。
    #[derivative(Default(value = &quot;false&quot;))]
    pub stream: bool,
    /// 如果指定，则一个包在fast_resend_thres个在其之后的包ACK之后会直接重传
    #[derivative(Default(value = &quot;None&quot;))]
    pub fast_resend_thres: Option&lt;u32&gt;,
    /// 快速重传的次数上限
    #[derivative(Default(value = &quot;None&quot;))]
    pub fast_resend_limit: Option&lt;u32&gt;,
    /// 是否启用BBR控制算法
    #[derivative(Default(value = &quot;false&quot;))]
    pub bbr: bool,
    /// BBR中RTprop（往返时间）滑动窗口的时间长度（单位：毫秒）
    #[derivative(Default(value = &quot;10000&quot;))]
    pub rt_prop_wnd: u32,
    /// BBR中BtlBw（瓶颈带宽）滑动串口的长度（单位：RTT）
    #[derivative(Default(value = &quot;10&quot;))]
    pub btl_bw_wnd: u32,
    /// BBR中一次RTT/RTprop探测的时间（单位：RTT），减少该值可以减轻RTT探测对于流量的影响。
    #[derivative(Default(value = &quot;200&quot;))]
    pub probe_rtt_time: u32,
    /// BDP增益，见后文
    #[derivative(Default(value = &quot;1024&quot;))]
    pub bdp_gain: usize,
&#125;

impl Config &#123;
    pub fn mss(&amp;self) -&gt; usize &#123;
        (self.mtu - OVERHEAD) as usize
    &#125;
&#125;

impl ControlBlock &#123;
    pub fn new(conv: u32, config: Config) -&gt; ControlBlock &#123;
        ...
    &#125;
&#125;</code></pre>
<h2 id="异常类型">异常类型</h2>
<p>KCP原本的C实现仅使用负数表达异常值，虽简介但其含义并不明晰，在本实现中我们对于异常进行了清晰定义：</p>
<pre class="line-numbers"><code class="language-rust">#[derive(Debug, Error)]
pub enum Error &#123;
    #[error(&quot;packet to be sent too large to be fragmented&quot;)]
    OversizePacket,
    #[error(&quot;incomplete KCP packet&quot;)]
    IncompletePacket,
    #[error(&quot;invalid KCP command: &#123;0&#125;&quot;)]
    InvalidCommand(u8),
    #[error(&quot;empty queue (try again later)&quot;)]
    NotAvailable,
    #[error(&quot;wrong conv. (expected &#123;expected&#125;, found &#123;found&#125;)&quot;)]
    WrongConv &#123; expected: u32, found: u32 &#125;,
&#125;

pub type Result&lt;T&gt; = std::result::Result&lt;T, Error&gt;;</code></pre>
<p>以上异常类型还有更精确的空间，但是目前应该已经堪堪够用了。</p>
<h2 id="发包方式">发包方式</h2>
<p>在原来的C实现在发包时直接调用callback，其优点是简洁，但其缺点在于callback的运行时间不定以及异常处理不明对运行产生的影响。<del>何况在Rust当中安全存储callback需要和borrow checker拼命。</del>在本实现中，我们将flush出去的包暂存在一个队列中，然后通过外部不断poll的方式拉出去。一方面，主动poll的方式和底层收到包时的push呼应；另一方面，这有助于分离底层发包和KCP逻辑本身，是“<a target="_blank" rel="noopener" href="https://sans-io.readthedocs.io/">无IO/Sans IO</a>”理念的一种体现。缺点是缓存队列可能会膨胀得厉害。当中tradeoff见仁见智。</p>
<pre class="line-numbers"><code class="language-rust">impl ControlBlock &#123;
    ...
    /// 底层收包push
    pub fn input(&amp;mut self, mut data: &amp;[u8]) -&gt; Result&lt;usize&gt; &#123; ... &#125;
    /// 底层发包poll
    pub fn output(&amp;mut self) -&gt; Option&lt;Vec&lt;u8&gt;&gt; &#123; ... &#125;
&#125;</code></pre>
<h2 id="去除check和update">去除<code>check</code>和<code>update</code></h2>
<p>这是一个比较大胆的改动，未必适合所有情形。去除的原因是在数据结构的优化下计算重传、更新发送窗口的开销大幅度减小，已经可以在每一次调用<code>input</code>和<code>send</code>的时候进行一次，没有必要去不断<code>check</code>再<code>update</code>。上层只需要按照固定的时间间隔调用<code>flush</code>就行了。我进行这样的设计是为了简化上层的代码，而且我的应用情形恰好是高流量的反正都要一直<code>flush</code>，也无所谓。</p>
<p><code>flush</code>的代码也其实很简单：</p>
<pre class="line-numbers"><code class="language-rust">pub fn flush(&amp;mut self) &#123;
    self.sync_now(); // 更新now
    self.flush_probe(); // 更新窗口探测
    self.flush_push(); // 计算重传以及更新发送窗口
    self.flush_ack(); // 发ACK
    if !self.buffer.is_empty() &#123;
        let mut new_buf = Vec::with_capacity(self.config.mtu as usize);
        std::mem::swap(&amp;mut self.buffer, &amp;mut new_buf);
        self.output.push_back(new_buf);
    &#125;
&#125;</code></pre>
<p>既然<code>sync_now</code>、<code>flush_push</code>在<code>input</code>和<code>send</code>当中都可以廉价地调用，那为什么还需要不断<code>check</code>再<code>update</code>呢？直接调用<code>flush</code>了事。</p>
<p>如果要参考有<code>check</code>和<code>update</code>的实现，可以参照<a target="_blank" rel="noopener" href="https://github.com/alan20210202/ekho/blob/caaeb5f55d/src/kcp.rs">早些时候的commit</a>。</p>
<h1 id="窗口数据结构的改进">窗口数据结构的改进</h1>
<p>KCP原版的实现中发送/接收的队列/窗口全部使用队列作为数据结构，这固然使得代码变简单了，但也一定程度上降低了性能：在队列中查找KCP段最差需要线性时间，这在某些情形下未必是最优的。在本实现中，我们优化数据结构，以最优的复杂度实现发送/接受窗口需要的若干操作：</p>
<ul>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>以分段的序号为键查找分段。</li>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>插入分段。</li>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>以分段的序号为键查找分段。</li>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>以分段的序号为键删除分段。</li>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>查询/弹出最早插入的分段（在发送窗口中，最早插入的分段自然是序号最小的分段）。</li>
<li><span class="math inline">\(\mathcal{O}(k)\)</span>遍历以插入顺序为序，某分段的所有<span class="math inline">\(k\)</span>个前驱（在发送窗口中，分段插入顺序即序号顺序，因此该操作可直接用于快速重传的计算）。</li>
<li><span class="math inline">\(\mathcal{O}(1)\)</span>查询大小。</li>
</ul>
<p>考虑到任何时刻窗口内分段序号之差不会大于窗口大小这一常数，符合上述要求的数据结构就可以用链表+滚动数组高效实现。代码不长，百行左右：</p>
<pre class="line-numbers"><code class="language-rust">struct Element&lt;T&gt; &#123;
    /// 前驱下标
    prev: usize,
    /// 后继下标
    next: usize,
    data: T,
&#125;

pub struct Window&lt;T&gt; &#123;
    size: usize,
    entry: Vec&lt;Option&lt;Element&lt;T&gt;&gt;&gt;,
    end: Option&lt;usize&gt;,
    len: usize,
&#125;

impl&lt;T&gt; Window&lt;T&gt; &#123;
    pub fn with_size(size: usize) -&gt; Self &#123;
        Self &#123;
            size,
            entry: (0..size).map(|_| None).collect(),
            end: None,
            len: 0,
        &#125;
    &#125;

    pub fn is_empty(&amp;self) -&gt; bool &#123;
        self.end.is_none()
    &#125;

    pub fn get_mut(&amp;mut self, index: usize) -&gt; Option&lt;&amp;mut T&gt; &#123;
        match self.entry[index % self.size].as_mut() &#123;
            Some(elem) =&gt; Some(&amp;mut elem.data),
            None =&gt; None,
        &#125;
    &#125;

    pub fn push(&amp;mut self, index: usize, data: T) &#123;
        let index = index % self.size;
        if self.entry[index].is_some() &#123;
            return;
        &#125;
        self.entry[index] = Some(match self.end &#123;
            Some(prev) =&gt; &#123;
                let prev_elem = self.entry[prev].as_mut().unwrap();
                let next = prev_elem.next;
                prev_elem.next = index;
                self.entry[next].as_mut().unwrap().prev = index;
                Element &#123; prev, next, data &#125;
            &#125;
            None =&gt; Element &#123; prev: index, next: index, data &#125;,
        &#125;);
        self.end = Some(index);
        self.len += 1;
    &#125;

    pub fn remove(&amp;mut self, index: usize) -&gt; Option&lt;T&gt; &#123;
        let index = index % self.size;
        let elem = self.entry[index].take()?;
        let (prev, next) = (elem.prev, elem.next);
        self.entry[index] = None;
        self.len -= 1;
        if index == self.end.unwrap() &#123;
            if prev == index &#123;
                self.end = None;
                return Some(elem.data);
            &#125; else &#123;
                self.end = Some(prev);
            &#125;
        &#125;
        self.entry[prev].as_mut().unwrap().next = next;
        self.entry[next].as_mut().unwrap().prev = prev;
        Some(elem.data)
    &#125;

    pub fn front(&amp;self) -&gt; Option&lt;&amp;T&gt; &#123;
        self.end.map(|end| &#123;
            let head = self.entry[end].as_ref().unwrap().next;
            &amp;self.entry[head].as_ref().unwrap().data
        &#125;)
    &#125;

    pub fn pop_unchecked(&amp;mut self) -&gt; T &#123;
        let end = self.end.unwrap();
        let head = self.entry[end].as_ref().unwrap().next;
        self.remove(head).unwrap()
    &#125;

    pub fn len(&amp;self) -&gt; usize &#123;
        self.len
    &#125;

    pub fn for_preceding(&amp;mut self, index: usize, mut action: impl FnMut(&amp;mut T)) &#123;
        let mut index = index % self.size;
        index = match self.entry[index].as_ref() &#123;
            Some(elem) =&gt; elem.prev,
            None =&gt; return,
        &#125;;
        while index != self.end.unwrap() &#123;
            let elem = self.entry[index].as_mut().unwrap();
            action(&amp;mut elem.data);
            index = elem.prev;
        &#125;
    &#125;
&#125;</code></pre>
<p>因为滚动数组是连续空间，在内存布局上相较于链表对于缓存更加友好，所以速度应该还可以再快一点。唯一的不足是<code>unwrap</code>有点多看着心惊肉跳，并且用指针可能会比用下标快一丁点，但是用Rust写数据结构大约就是这个尿性。</p>
<p>有这个打底，窗口大小开到8192实测是一点问题都没有的，更大的没试过。</p>
<p>但KCP的设计本质上是不适合大流量的，因为快速重传无论如何优化数据结构最坏的线性复杂度就在那里无法消除，除非可以限制快速重传向后看的范围，但后者又削弱了快速重传的意义与效用。</p>
<h1 id="重传计时器的改进">重传计时器的改进</h1>
<p>原版的KCP实现在<code>check</code>的时候需要遍历发送窗口来确定最近的重传时间，在<code>flush</code>的时候又要遍历才能重传，这在窗口较大的时候显然是比较吃性能的。原作者记得在issues里的讨论中提过可以用时间轮进行优化。诚然，时间轮是最好的方案，但是实现起来较为复杂。因此，本实现使用借助Rust的标准库实现起来相对简单的小根堆进行优化：</p>
<pre class="line-numbers"><code class="language-rust">use std::cmp::Reverse;
use std::collections::BinaryHeap;

pub struct Timer(BinaryHeap&lt;Reverse&lt;u64&gt;&gt;);

impl Timer &#123;
    pub fn with_capacity(capacity: usize) -&gt; Self &#123;
        Self(BinaryHeap::with_capacity(capacity))
    &#125;

    pub fn schedule(&amp;mut self, ts: u32, sn: u32) &#123;
        self.0.push(Reverse(((ts as u64) &lt;&lt; 32) | sn as u64));
    &#125;

    /// 获取截止到now发生的 一个 事件，应该重复调用
    pub fn event(&amp;mut self, now: u32) -&gt; Option&lt;(u32, u32)&gt; &#123;
        let key = (now as u64 + 1) &lt;&lt; 32;
        match self.0.peek() &#123;
            Some(&amp;Reverse(val)) if val &lt; key =&gt; &#123;
                let sn = val &amp; (u32::max_value() as u64);
                let ts = val &gt;&gt; 32;
                self.0.pop();
                Some((ts as u32, sn as u32))
            &#125;
            _ =&gt; None,
        &#125;
    &#125;
&#125;</code></pre>
<p>计时器只需要存时间和分段序号即可。调用的代码如下：</p>
<pre class="line-numbers"><code class="language-rust">fn flush_push(&amp;mut self) &#123;
    // ... 省去流控以及把队列里的分段加入发送窗口的部分
    let mut send_buf = std::mem::take(&amp;mut self.send_buf);
    while let Some((ts, sn)) = self.timer.event(self.now) &#123;
        if sn &lt; self.send_una || sn &gt;= self.send_nxt &#123;
            continue; // 分段被ACK于是不在发送窗口里了，自然跳过
        &#125;
        if let Some(seg) = send_buf.get_mut(sn as usize) &#123;
            if ts == seg.ts &#123;
                seg.ts = self.prepare_send(seg); // 更新RTO并计算下一次重传的时间
                seg.ts_last_send = ts;
                self.dead_link |= seg.sends &gt;= self.config.dead_link_thres;
                self.flush_segment(Command::Push, seg.frg, seg.sn, ts, seg.payload.len());
                self.buffer.extend_from_slice(&amp;seg.payload);
                self.timer.schedule(seg.ts, seg.sn); // 安排下一次重传
            &#125;
        &#125;
    &#125;
    self.send_buf = send_buf;
&#125;</code></pre>
<p>由于查看小根堆堆顶是<span class="math inline">\(\mathcal{O}(1)\)</span>的，因此在没有重传的时候<code>flush_push</code>的开销确实很小。足以在<code>input</code>和<code>send</code>时都调用一次。真的要重传时，更新小根堆的时间复杂度也是对数级别的，这就给去除<code>check</code>和<code>update</code>提供了基础。</p>
<h1 id="bbr">BBR</h1>
<p>最后的改进是用BBR取代了KCP原版实现中朴素的基于丢包的流控算法。</p>
<p>我试图参照<a target="_blank" rel="noopener" href="https://research.google/pubs/pub45646/">原论文</a>实现BBR，但因为计时精度的问题packet pacing是做不到了。实现的部分有</p>
<ul>
<li>基于单调队列的滑动窗口BtlBw max-filter。</li>
<li>基于单调队列的滑动窗口RTprop min-filter。</li>
<li>BBR状态机。</li>
<li>基于以上三者计算inflight limit进行流控。</li>
</ul>
<p>和BBR有分歧的一点在于在ProbeRTT状态采用BDP的一半作为拥塞窗口而不是原文的4个包。</p>
<p>此外，本实现只对只传输一次的分段计算BBR的各项参数，如RTT，带宽，更新各个filter等。原因是实际上大部分的分段都在看到包头的UNA之后就被ACK掉了而不是被单独的ACK包ACK的。ACK包带有分段的序号与时间戳，所以可以清楚知道ACK的是哪一次传输，但被UNA ACK掉的就不清楚，唯一的例外是分段只被传输了一次。如果对于多次传输的包仍然直接计算BBR，那么万一ACK恰好在重传之后到达，那么误算出的RTT就非常小，导致RTprop非常小，进而BDP非常小，整个BBR就堵住了。诚然，可以把每一次传输的时间戳都存起来，然后在被UNA时选择最接近<code>now - srtt</code>的传输，但这就增加了代码的复杂度。考虑到丢包的毕竟是少数，如此未必会有特别大的优势（实现这个的代码在这个<a target="_blank" rel="noopener" href="https://github.com/alan20210202/ekho/blob/01b1d72b7e/src/kcp.rs">commit</a>，也可作为参考）。</p>
<p>实测效果还行。一个比较重要的问题是在间歇性<code>flush</code>的情况下对于带宽的计算并不准确甚至有低估的倾向，往往导致BDP过于保守，即使ProbeBW状态有一个1.25x的激进phase也解决不了问题。我想到的一个解决方案是将拥塞窗口不是简单的设置为BDP，而是乘上一个增益，也就是配置里面的<code>bdp_gain</code>。为了避免浮点数运算，<code>bdp_gain</code>使用1024为基数。一般来说设置成1280就差不多了——其实就是主动创造轻微的拥塞来确保占有带宽。这对于其他的TCP连接固然有些不公平的，是否采用见仁见智。</p>
<h1 id="真背景">真·背景</h1>
<p>其实一开始，只是为了编译的时候能够不带着<code>unsafe</code>和C编译器而选择把原版实现移植到Rust，当时代码大部分几乎一模一样。</p>
<p>后来引入BBR魔改了一回。</p>
<p>为了代码更Rust魔改了一回。</p>
<p>再后来做配置分离魔改了一回。</p>
<p>再后来数据结构优化又魔改了一回。</p>
<p>来来回回地改，到最后除了架子还和原版实现相似，内部的代码已经大变样了。</p>
<p>但是在ICMP隧道上试验下来仍然不是最令人满意，CPU占用仍然不少，带宽仍然不能跑满，goodput仍然不高。</p>
<p>我不知道是我应用层以及底层的代码写的有问题，还是KCP本身就不是很适合高流量大窗口的应用场景。</p>
<p>或许二者兼有之？</p>
<p>前两天突然想起了QUIC，找了一下，Cloudflare有一个优秀的QUIC实现，是Rust的，而且是Sans IO的。大概QUIC才是最适合我的应用情形的吧。我准备这几天试验一下。</p>
<p>或许之后就转QUIC了呢？（笑）</p>
<p>那我魔改的KCP就放在这吃灰？</p>
<p>于是乎，就有了这篇文章。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/12/18/DDNS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/18/DDNS/" class="post-title-link" itemprop="url">自己写一个DDNS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-18 06:51:54" itemprop="dateCreated datePublished" datetime="2020-12-18T06:51:54-05:00">2020-12-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>前几天借着Github的学生优惠在name.com上嫖了一个域名，这个域名是带SSL的，而恰巧家里的主机因为443端口被封的缘故无法通过Let's Encrypt获得证书，所以把这个域名给家里的主机升级HTTPS再合适不过了。</p>
<p>唯一的问题是name.com只提供静态DNS服务，而服务器放在家里自然是动态IP的。虽然IP不是经常换但是如果换了IP没有及时更新记录就会出问题，何况手动更新记录也有点烦。有两个方案：</p>
<ol type="1">
<li>我目前使用的是花生壳的DDNS，这个的记录是动态更新的。我可以在新域名下面新建一条CNAME记录指向动态域名。这样的好处是省事，坏处是可能会增加DNS解析的时间，我目前还不清楚HTTPS要不要求CNAME指向的域名也有证书，如果要求的话这个方法就更不行了。</li>
<li>name.com作为一家比较大的域名商有自己的API以及<a target="_blank" rel="noopener" href="https://www.name.com/api-docs">完备的文档</a>，可以自己写一个定时更新脚本来实现类似DDNS的功能。</li>
</ol>
<p>经过考虑之后我选择后者。自己写的脚本如下：</p>
<pre class="line-numbers"><code class="language-bash">#!/bin/sh

domain=&#39;&lt;DOMAIN&gt;&#39;
credential=&#39;&lt;ACCESS TOKEN&gt;&#39;
ttl=300
interval=10

echo &#39;Querying type A record ID...&#39;
rec_id=$(curl -su $credential &quot;https://api.name.com/v4/domains/$&#123;domain&#125;/records&quot; | jq &#39;.records|map(select(.type==&quot;A&quot;))|.[0].id&#39;)
echo &#39;Found type A record ID:&#39; $rec_id

while true; do
    res_ip=$(host $domain | grep -ohP &#39;\b(?:\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1,3&#125;\b&#39;)
    real_ip=$(curl -s myip.ipip.net | grep -ohP &#39;\b(?:\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1,3&#125;\b&#39;)
    echo &#39;Resolution IP:&#39; $res_ip &#39;Real IP:&#39; $real_ip
    if [[ $real_ip != $res_ip ]]; then
        echo &quot;Resolution mismatch! Updating record...&quot;  
        req_data=&quot;&#123;\&quot;type\&quot;:\&quot;A\&quot;,\&quot;fqdn\&quot;:\&quot;$&#123;domain&#125;.\&quot;,\&quot;answer\&quot;:\&quot;$&#123;real_ip&#125;\&quot;,\&quot;ttl\&quot;:$&#123;ttl&#125;&#125;&quot;
        echo &quot;Request data:&quot; $(echo $req_data | jq &#39;.&#39;)
        req_res=$(curl -m 30 -su $credential &quot;https://api.name.com/v4/domains/$&#123;domain&#125;/records/$&#123;rec_id&#125;&quot; \
            -X PUT -H &#39;Content-Type: application/json&#39; --data $req_data | jq &#39;.&#39;)
        echo &quot;Request result:&quot; $req_res 
        sleep $ttl
    fi
    sleep $interval
done</code></pre>
<p>其实很简单，主要分为一下几个部分：</p>
<ol type="1">
<li>记录id的获取。name.com对每一个记录都分配了一个id以便于API操作，这个id在网站管理面板上是不可见的，因此需要在运行时查询，命令为<code>curl -su $credential "https://api.name.com/v4/domains/$&#123;domain&#125;/records"</code>。查询之后需要解析JSON，这里我使用的是<code>jq</code>这个第三方JSON parser。</li>
<li>当前DNS解析的IP。这个使用<code>host</code>结合<code>grep</code>提取IP字符串即可。</li>
<li>获取本机真实IP。这个接口就多了，我这里用的是<code>myip.ipip.net</code>的接口。据我所知还有接口是直接返回IP字符串的，还可以后处理的功夫。</li>
<li>如果解析IP和真实IP不符，那就调用API更新记录。注意在更新完之后最好等待TTL的时间以避免更新生效前多次更新。</li>
</ol>
<p>写完这个脚本再写一个配套的systemd service file，然后<code>systemctl</code>挂在后台运行就好了。运行到现在效果非常好。如果有name.com的域名同时也有类似需求的或许可以参考一下。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/11/25/Minecraft%20ILP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/25/Minecraft%20ILP/" class="post-title-link" itemprop="url">Designing Computational Redstone Circuits Automatically in Minecraft with Integer Programming: Preliminary Thoughts and Tests</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-25 04:05:54" itemprop="dateCreated datePublished" datetime="2020-11-25T04:05:54-05:00">2020-11-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>UNFINISHED ARTICLE -- WORK IN PROGRESS</strong></p>
<p><strong>UNFINISHED ARTICLE -- WORK IN PROGRESS</strong></p>
<p><strong>UNFINISHED ARTICLE -- WORK IN PROGRESS</strong></p>
<p>This was a project I worked on two months ago, but it wasn't until now that I have the time to write it down and share it on my blog.</p>
<h1 id="intro">Intro</h1>
<p>Redstone has been a core element in the game Minecraft for quite some years. It is presumably the most untrivial one as well: while anyone could master nearly all Minecraft mechanics through experiences, it takes not only experience but also ingenuity to design a good redstone circuit. Few of us are bold enough to claim "I master redstone", even after playing Minecraft for a decade.</p>
<p>So here comes the question: <strong>Can the design of redstone circuits, the core of Minecraft automations, be automated?</strong> and <strong>If so, how?</strong> (appreciate how meta this is :)</p>
<p>Theoretically, the answer is "yes...but". Minecraft has a finite world, and each position has a finite number of possible blockstates. We can write a program to enumerate all possible placements of blocks until we find some placement corresponding to the desired redstone circuit. However, this needs exponential time and we may need to wait for a century before it could give us, for instance, a decent piston door. Moreover, if a circuit involves manipulation of entities (which could have infinite many states), then we are easily screwed.</p>
<p>Well, perhaps it is difficult to let a program design any redstone circuit. But there is indeed a subset of redstone circuits whose design can very likely be automated -- <strong>computational redstone circuits</strong>, aka. logic gates, calculators, CPUs etc. Why? Because software that design their real world electronic counterparts are readily available -- they are called "EDA".</p>
<p>As a high school student I, of course, know little about the inner workings of real-world EDA applications (and there doesn't seem to be a lot of resources out there). I am convinced that this problem is NPC (further articulated below), so designing an efficient polytime combinatorial algorithm doesn't seem plausible. That said, what about reducing this problem to some other NPC problems which we can solve relatively quickly with optimized algorithms / heuristics -- say, ILP? This is what I am trying to do here.</p>
<h1 id="formulating-the-problem">Formulating the problem</h1>
<p>"Designing computational redstone circuit automatically" is a vague idea, so it is necessary that we know what this truly means.</p>
<h2 id="whats-the-input">What's the input?</h2>
<p>The input should describe the intended functionality of a circuit. Recall how we usually describe a circuit: we draw a <strong>circuit diagram</strong>. I here characterize a redstone circuit diagram by the assumptions and constraints below:</p>
<ol type="1">
<li>A circuit contains two parts: <strong>wires and components</strong>.</li>
<li>Components are the <strong>primitives</strong> of a circuit. E.g. A torch or a wire junction.</li>
<li>A component has <strong>interfaces</strong>, either <strong>in or out</strong>, as where the component receives signals from and sends signals to.</li>
<li>A wire connects <strong>an</strong> out-interface from a component ("source") to <strong>an</strong> in-interface of another component ("target").</li>
<li>Wires are <strong>directed</strong>.</li>
<li>Components are <strong>independent</strong>. i.e. they do not interfere with other components in any way other than being connected by wires from interfaces.</li>
</ol>
<p>A circuit diagram can be represented in a directed graph, with components as vertices and wires as edges. Source/target interfaces as extra information stored on edges.</p>
<h2 id="whats-the-output">What's the output?</h2>
<p>We want our program to tell us how the circuit we described in the input can be built in the Minecraft world. Therefore, we could define the the output to be a set of position - blockstate pairs, (which, in implementation, can be stored in a schematic file).</p>
<p>However, we don't want to jump straight from a circuit diagram to a detailed Minecraft schematic because that means taking interference between components, quasi connectivity, update order -- basically everything that makes redstone engineering complex -- into consideration in the first place.</p>
<p>Instead, we could first build our circuit in an <strong>ideal world</strong>, in which we forget about all those factors above, and then convert the ideal placement into an actual Minecraft schematic.</p>
<p>What's an idea world?</p>
<ol type="1">
<li>A circuit consists of multiple ideal blocks.</li>
<li>A component fully occupies a set of ideal blocks, some of which are its interfaces. How many and which blocks a certain type of component occupies depend on its size in Minecraft and how we plan to convert the ideal placement to a real schematic.</li>
<li>A wire is a chain of blocks, where any adjacent two share a face. The first block is always the source interface and the last is always the target interface.</li>
<li><strong>Exclusiveness: </strong>All components and all wires (ignoring their first and last block) mustn't overlap.</li>
<li><strong>Mutual Independence: </strong>Unless both blocks are occupied by the same component / wire, anything in two adjacent cells do not interfere with each other.</li>
<li>Wire junctions are special components and are exceptions to rule 2 and 3. A wire junction always have three interfaces (1 in &amp; 2 outs, or 2 ins &amp; 1 out). Multiple junctions can overlap and they can overlap with an interface of some component.</li>
<li>There are times when we want to fix the location of some components in the input. These components are usually just placeholders that mark the position of IO. (We don't want to produce a circuit with an unreachable input/output in the center of everything else, right?)</li>
</ol>
<h2 id="the-objective">The Objective</h2>
<ol type="1">
<li>The circuit represented by the output must have the same functionality as described by the input circuit diagram.</li>
<li>The delay of the circuit should be minimized.</li>
</ol>
<h2 id="example-the-and-gate">Example: the AND gate</h2>
<p>Let's see how we design a simple AND gate.</p>
<p>Suppose the only primitive components we have are NOT gate (torch), wire junction, and IO placeholder. The circuit diagram of AND gate is:</p>
<p><img src="/2020/11/25/Minecraft%20ILP/ANDCD.svg" class=""></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/08/20/NOI%202020/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/20/NOI%202020/" class="post-title-link" itemprop="url">蒟蒻的NOI 2020退役记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-20 04:18:18" itemprop="dateCreated datePublished" datetime="2020-08-20T04:18:18-04:00">2020-08-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="day--1">Day -1</h1>
<p>在中午太阳晒得最狠的时候到了学校。宿舍爬楼累死人，也不知道为啥学校楼要建那么高。幸好宿舍里的空调给力，好评。</p>
<p>宿舍的环境还行。个人觉得比当年WC2018的要好。</p>
<p>信号出奇地差，必须在直接靠窗的地方才有4G，不然连2G也别想收到，听宿管和小卖部阿姨说当初就是设计成这个样子的。差评。</p>
<p>插座很多好评。</p>
<p>但是还是没有桌子，无论用什么姿势看电脑都贼难受。同寝室的jtl带了一个床上架的桌子，看了直呼内行。床板贼硬，差评。</p>
<p>伙食还可以，豆浆我觉得挺好喝的，就是湖南菜多多少少带点辣个人不是很能接受，而且菜很细碎的样子。</p>
<p>睡前随随便便背了点笔试题。</p>
<h1 id="day-0">Day 0</h1>
<p>早上迷迷糊糊地去参加了开幕式。听到dzd说有剩饭扣1分大惊。其他就没啥印象了=_=。</p>
<p>结束后拱火mr押题，mr说看到才艺表演一个跳舞的转来转去暗示会考平衡树，一本正经胡说八道.jpg。</p>
<p>感觉周围大佬都贼多，互相之间也都认识，我一个蒟蒻在当中不知所措。自己看来对于在竞赛圈内的信息闭塞的可以。</p>
<p>中午又背了一会笔试题，然后下午就去试机了。笔试没有想象中的难，但是确实是有超纲的，纠结了很久。幸好最后还是满分飘过了。唯一值得吐槽的或许是CCF十年不变的远古测评系统。</p>
<p>随后在试机场上敲了一波LCT和FFT。看到jtl在写MTT有想敲三模数的冲动但是最后的合并调了好一会才勉强调出来，于是就很慌。</p>
<p>晚上寝室里大家都在欢快地打板子。对面两个人都在打带花树，然后惊奇地发现带花树的代码似乎也没有想象中那么长。三个人讨论了一下觉得似乎有概率考分块的样子，但是笑一笑也就过去了。我自己把各种字符串的算法全部过了一遍。</p>
<h1 id="day-1">Day 1</h1>
<p>看到T1愣了好一会，愣是没有第一时间看出DP。不知道为什么当时满脑子都是Tarjan和缩点然后沿着这个方向陷入了死胡同。于是先敲了一个DFS，觉得自己要完蛋。</p>
<p>看了T2又愣了一会，先敲了个暴力，然后觉得<span class="math inline">\(m\)</span>比较小的情况可以动态维护链并+容斥解决。先放着。</p>
<p>看到T3深切地感受到这或许是个数据结构毒瘤？先敲了一个二维树状数组的暴力。当时脑子大概是坏掉了不是枚举矩形直接算而是枚举点算贡献。总之暴力复杂度似乎<span class="math inline">\(\mathcal O(nm\log^2 n)\)</span>非常差。然后认真思考了一下部分分，发现可以莫队。于是基于二维树状数组写了一个<span class="math inline">\(\mathcal O\left(n\sqrt m \log^2 n\right)\)</span>的算法。然后觉得<span class="math inline">\(\mathcal O(\log ^2n)\)</span>的二维数点不妥，改成了<span class="math inline">\(\mathcal O(\log n)\)</span>的可持久化线段树，于是暴力和莫队的复杂度都少了一个<span class="math inline">\(\log\)</span>。再一看发现莫队我可以用树状数组干嘛要二维数点，于是莫队的常数又降下来一点。瞄了一眼后面觉得应该可以用<span class="math inline">\(\mathcal O(n^{7/4})\)</span>的四维莫队，可惜当初没认真学高维莫队不知道块大小咋算了，于是作罢。最后敲了一个莫队和暴力的对拍放着。</p>
<p>回到T2开始敲树剖和容斥，写了一个<span class="math inline">\(\mathcal O\left(m2^m\log^2n\right)\)</span>的算法。和暴力结合在一起觉得至少能拿<span class="math inline">\(32\)</span>分，常数小一点也可以冲冲<span class="math inline">\(40\)</span>样子。</p>
<p>然后回到T1，突然发现这不就一个裸的DP吗，直骂自己前面傻逼。于是花5分钟敲完朴素DP，然后再花10分钟敲完环的部分分。</p>
<p>然后发现边权至多为<span class="math inline">\(5\)</span>，意识到正解显然是用max-plus algebra下的矩阵快速幂进行优化，于是开始敲。此时离考试结束还有60分钟，心中贼慌。等到敲完离考试结束还有30分钟，心态爆炸，然后死活调不出来。只能把这个正解例程写在程序里作为最后之选。离交卷还有5分钟的时候不改了。检查其他两题的程序无误后就开始坐着怀疑自己前三个小时脑子到底在想什么……</p>
<p>出考场觉得自己已经成为了时代的眼泪（笑）。</p>
<p>下午三点去查分。听jtl说这次CCF准时出分没有咕简直是奇迹。结果就是<span class="math inline">\(50+32+40=122\)</span>。和预想的完全一致。这个时候就很后悔。如果当初早点看出矩阵快速幂把T1的正解调出来就好了。这个分觉得铁牌已经在向我招手。</p>
<p>晚上讲题。T1的确是快速幂正解。T2的正解是线段树合并维护树形DP这个之前也在寝室里有了大概的想法，但是一看这个DP的状态设计果然神仙。出题人怒斥了我们打<span class="math inline">\(32\)</span>分树剖暴力的，说是什么数据结构学傻了……然后说写个虚树不就<span class="math inline">\(40\)</span>了吗。我下面听着就很无语：我也想打虚树，但是我不会啊…… T3的出题人原来就是各种OJ上人们一直吐槽的lxl。这个题目的内部名称似乎叫“第十三分块”？正解似乎是先建一个树套树然后再分治再分块……讲到一半就lost了，内心大骂出题人毒瘤。</p>
<p>回寝室后所有人都是颓废的状态，gyc在打Splay的板子。剩下我们两个人开始摸鱼。</p>
<h1 id="day-2">Day 2</h1>
<p>T1一看给人一种网络流的既视感，然后发现图建不出来。退而求其次试图写出线性规划进行代数化建图，发现线性规划必须使用Big M的办法才能建出来，而且直观一看integrity gap大的离谱是不可能建图的。因为是求可行解也不知道目标函数咋写，所以也不能从对偶下手，只能作罢。敲了一个非常粗暴的DFS暴力枚举每道菜用哪两个原材料分别用多少，发现这个DFS在最坏情况下跑得巨慢无比——难不成我暴力骗分都不成？</p>
<p>这个时候有了一个乱搞的intuition，就是枚举原料的排列然后按照排列来确定所用的原料。然后发现过不了样例，于是作罢。</p>
<p>之后稍微改进了一点暴力，只枚举每道菜用哪两个原材料，最后时候用多少最后用网络流来判。这下终于拿到了<span class="math inline">\(15\)</span>分的暴力。顺便基于这个敲了一个随机化，但是似乎表现也不佳的样子。</p>
<p>T2题面长度属实劝退。读完题面之后觉得似乎不是很可做。看了样例之后有了一点暴力的想法，写了一个复杂度为<span class="math inline">\(\mathcal O\left(2^{2^{h_{\text{max}}-1}}\right)\)</span>的算法。简单来说就是把输入的树补成最大树高然后枚举能否扩张成最大树高下的所有可能的二叉树形态。觉得除了<span class="math inline">\(12\)</span>分纯暴力还可以拿<span class="math inline">\(h_{\text{max}}=4\)</span>的分？之后就不会了。</p>
<p>T3一看给我整懵了。可真就暴力不会写呗。直觉上似乎可以写Dijkstra然后在转移的时候排除掉当前路径下的割边。但是很快意识到Dijkstra的本质是DP而这个转移方案是有后效性的。事实上也是如此，样例都没有过。然后试验性地写了一个不可行的判定方法：求出最短路，如果把最短路去掉之后全图不连通，则不可行——也不知道这样对不对。</p>
<p>5个小时就在三个题目的来回懵逼当中度过。</p>
<p>这次CCF出分直接咕了将近两个小时。我们很明智地从一开始就待在寝室里，那些下去等分的就苦逼了。分数出来是<span class="math inline">\(15+12+5=32\)</span>、也差不多是我预想的这个水平，T2树高为<span class="math inline">\(4\)</span>的点我还是超时了，大概还是没有判同构去重的原因？</p>
<p>下午去听讲题。T1正解的思路源于<span class="math inline">\(m=n-1\)</span>的思考，其他的情况都是向<span class="math inline">\(m=n-1\)</span>情况的规约，感觉是非常巧妙的。T2的最优算法居然是线性的？有点听蒙了。听到T3讲解的时候才意识到T3当中的图叫做弦图，而正解源于对于弦图性质的思考，最后用过两次类Dijkstra来解决，感觉是非常非常神奇，不明觉厉，自愧不如。</p>
<p>讲的时候就出榜了，一看果然Cu，心情复杂，但是一开始也没有期望，所以也没有太沮丧。感觉心态真正崩盘的大概是jtl，人家Cu第一……差一分就Ag了。但是看榜还是有<span class="math inline">\(500\)</span>分以上的，觉得这些人真的很厉害。我或许不比他们笨，但是他们确实历练的比我这种多多了。我这种常年边缘划水的OIer果然不能和这些人比。</p>
<h1 id="day-3">Day 3</h1>
<p>看着手中的铜牌，意识到自己划水的OI之路至少到此为止暂时地画上了句号，颇有些不真实感。</p>
<p>我一直在想，如果D1T1的正解我调出来了，我就是Ag了，会不会好一点呢？但是这终究也只是一个幻想而已罢了。一是比赛不能重来，二是我似乎也不知道缓存矩阵乘方的套路所以真写快速幂有可能复杂度还是会炸的样子。</p>
<p>一如既往，自己复习的算法完美地和考试算法错开了。没有LCT，没有FFT，没有字符串。我深切意识到OI果然还是靠平时积累的，这种比赛临时抱佛脚很大概率是不靠谱的。</p>
<p>还是要谢谢NOI最后给了我一个意识到自己有多菜的机会。还有那么多我没有学的啊~</p>
<p>大概在没有竞赛压力之后我还是会对这些算法认真地研究一番的吧。觉得自己的心态是一个很奇妙的东西。在被父母逼着学竞赛的时候总觉得这些算法很烦，但是意识到自己远离竞赛之后，反而又觉得它们有趣起来了。</p>
<p>网上看过很多这样的游记，一般到最后作者不是Au就是进队了，这种好事终究不会发生在我身上。</p>
<p>唉。这就退役了。</p>
<p>写于Day 3从长沙回上海的火车上。自己的思路一如既往地混乱。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/08/12/AlipayParanoia/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/12/AlipayParanoia/" class="post-title-link" itemprop="url">论支付宝对Xposed框架的被害妄想症</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-12 10:30:28" itemprop="dateCreated datePublished" datetime="2020-08-12T10:30:28-04:00">2020-08-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近真的是被支付宝的操作恶心到了。</p>
<p>跑到医院门口，要出示健康码了。打开支付宝选择随申码，登录授权时要刷脸，然后告诉我手机不支持刷脸？场面一度非常尴尬。</p>
<p>“您的手机不支持刷脸”。为什么不支持？缺少硬件？缺少驱动？含糊其辞，搞得我一开始真以为XDA上下下来的ROM不贴合我国国情少预装了一套刷脸的库。</p>
<p>查了好久才意识到原来是支付宝检测到Magisk和Xposed的缘故。</p>
<p>好啊，这可以理解嘛，人脸验证和支付都是安全性极高的，关键步骤被hook是会出大事的。</p>
<p>于是停用了Riru和EdXposed的模块。但是还是不支持。</p>
<p>三清之后重装，又支持了。</p>
<p>然后我遵循网友的经验，安装Magisk，然后开启随机包名重装和Magisk Hide。没有出问题。</p>
<p>然后再安装EdXposed，即时模块打开，黑名单打开把支付宝加进去，然后开启强制SafetyNet检验。</p>
<p>然后支付宝安全检查之后就又告诉我不支持了。</p>
<p>唉，我啥模块都没装呢，拉黑之后就算装了也hook不到你支付宝紧张啥？</p>
<p>网上逛了一圈，有不少遇到这个问题的，大家都没有好的解决办法，有的说双开，有的说双手机，有的说回退到play上的19年9月份的75版本。最后一条亲测确实有效，但是一直停留在老版本也不是个事啊。</p>
<p>也看了CSDN上一些关于阿里系应用反hook机制的研究，大概是18年左右写的。当时的机制是通过反射检测有没有<code>XposedHelper</code>这个类，有这个类之后检测缓存里面有没有alipay等关键词。这个机制非常巧妙，而且我觉得强度也足够了。</p>
<p>但是现在似乎已经不是这个机制了。通过有些解决方案当中关闭读取应用列表权限这一项我隐约可以猜出这支付宝大概是直接读取手机安装的所有应用，然后发现带Xposed就是不安全？</p>
<p>这也太过了吧，我个人甚至觉得有些流氓之嫌。</p>
<blockquote>
<p>看到Xposed，立刻想到自己被hook，立刻想到这hook一定会让用户亏钱，立刻想到自己要赔钱，然后就紧张的要命。支付宝的想像惟在这一层能够如此跃进。<del>——鲁迅</del></p>
</blockquote>
<p>这个逻辑链有两处是有待商榷的。</p>
<p>为什么所有Xposed插件一定要来hook你？我手机一般就装两模块，一个修改界面的locale让不够本地化的地方本地化，一个修改图标让系统更美观。这两个模块都不用hook进支付宝，而且还都是我自己一行一行写出来的。我脑子坏掉了去搞支付宝自己坑自己？</p>
<p>为什么觉得因为用户因为hook造成的损失一定要支付宝负责？还真就社会责任心爆棚呗。服务条款里面加一行“由于用户使用第三方软件自行修改系统框架进而影响本应用的正常运行，导致财产损失的，责任自负，支付宝概不负责”有那么困难吗？Xposed必须是用户自己装的，模块一定是用户自己下载并且启用的，考虑到使用Xposed基本上都是安卓的发烧友，翻车了自己负责这条道理大家都认，也没有人来说是支付宝的不对。</p>
<p>退一步，如果我真的要搞尽一切代价搞支付宝，支付宝检测有没有被hook的代码可不可能被hook呢？我能不能不用Xposed而用一些更底层的框架例如Riru来搞呢？支付宝作为一个正常权限的应用软件，面对因用户主动选择破坏承载其运行的，本来安全的安卓系统框架，而导致的可能来自底层的，高权限的修改与破坏一定是无能为力的。支付宝完全没有必要对一个受害者主动引发，且本质上自身无能为力的损失负责。</p>
<p>进一步，今天支付宝可以读取应用看到Xposed就不让刷脸，明天如果腾讯和阿里干架，支付宝也可以读取应用列表看到有微信就不让用（3Q大战既视感）。现在看来“读取应用列表”不是安卓原生自带的权限实在是一个设计漏洞。支付宝这个行为也显然开了一个不好的先例。</p>
<p>最后，我其实一直不理解的一点是，是什么让支付宝觉得原来合理的Xposed框架检测逻辑有问题，进而换上了这套长臂管辖似的一刀切呢？</p>
<p>在不知道更多信息以前，我只能认为是支付宝自身在有些情境下不必要的责任感以及过度的被害妄想症在作祟。</p>
<p>在此，向设计这个安全检查模块的所有阿里员工以及十八代亲属致以最诚挚的问候。</p>
<p>最后的最后，讲一讲在保留Magisk和Xposed功能的情况下，可能的解决办法吧。</p>
<ol type="1">
<li>停留在老版本的支付宝。</li>
<li>让EdXposed也有和Magisk类似的随机包名重装功能。</li>
<li>让支付宝找一个更合理的办法检验自己有没有被hook。</li>
<li>让支付宝目前这套方案失效，比如说禁止支付宝调用<code>getInstalledPackages</code>来获取已经安装的应用。这个我知道在一些国产的系统里面是有类似功能的。但是目前类原生的系统还没有。虽可以通过Xposed模块来实现，但是在这个背景下毫无意义。唯一的一个方案是把系统的源码clone一份下来，然后直接改代码。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/08/07/FWHT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/07/FWHT/" class="post-title-link" itemprop="url">Fast Walsh-Hadamard Transform in Competitive Programming</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-07 04:56:28" itemprop="dateCreated datePublished" datetime="2020-08-07T04:56:28-04:00">2020-08-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>This should be the very first English post I write on my blog and I expect there to be some minor errors. This is a popular technique in the Chinese competitive programming community but there doesn't seem to be a lot of documentation about its application in the English CP community. The posts I found on Codeforces doesn't seem to be very clear to me...</p>
<h1 id="prerequisites">Prerequisites</h1>
<ul>
<li>A decent proficiency in competitive programming.</li>
<li>A basic understanding of the Cooley-Tukey FFT and its application in competitive programming.</li>
<li>A decent understanding of bitwise operations.</li>
</ul>
<h1 id="why-do-we-need-fwht">Why do we need FWHT?</h1>
<p>Recall what we would do if we are to quickly calculate the following convolution of two sequences <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, each of length <span class="math inline">\(n\)</span>: <span class="math display">\[
\{a\circledast b\}_i=\sum_{j+k=i}a_{j}b_k \Bigg/ \{a\circledast b\}_i=\sum_{j=0}^ia_{j}b_{i-j}
\]</span> We use FFT, which applies the following transformation to the input sequence: <span class="math display">\[
\mathcal{F}\{a\}_i = \sum_{j=0}^n a_j\omega_{n}^{ij}
\]</span> Since the calculation of this transformation (and its inverse) can be done in a divide-and-conquer manner in <span class="math inline">\(\mathcal O(n\log n)\)</span> and the element wise product of the transformation is equivalent to the convolution on the original series, we are able to calculate the convolution in <span class="math inline">\(\mathcal O(n\log n)\)</span>.</p>
<p>Now we try to generalize our findings to a more general case: <span class="math display">\[
\{a\circledast b\}_i=\sum_{j \star k=i}a_jb_k
\]</span> where <span class="math inline">\(\star\)</span> is some binary operation. The convolution we see at the beginning is a special case where <span class="math inline">\(\star = +\)</span>.</p>
<p>FWHT is an algorithm that borrows similar notions from FFT and is able to compute the convolution in <span class="math inline">\(\mathcal O(n \log n)\)</span> time for <span class="math inline">\(\star =\vee,\wedge,\oplus\)</span> (bitwise OR, bitwise AND, and bitwise XOR). Why do the convolutions of these bitwise operations matter? Observe that binary representation is a way of encoding sets and these three operations correspond to set union, set intersection and set symmetric difference respectively, therefore, FWHT can be used to accelerate set-based DPs.</p>
<h1 id="bitwise-or-convolution">Bitwise OR convolution</h1>
<p>Let's start with the convolution with respect to bitwise OR: <span class="math display">\[
\{a\circledast b\}_i = \sum_{j\vee k=i}a_jb_k
\]</span> We start by exploiting an interesting property of bitwise OR: <span class="math display">\[
x \vee z = z,y\vee z = z \Leftrightarrow (x\vee y)\vee z=z
\]</span> or its clearer equivalent in set-based notations: <span class="math display">\[
X\subseteq Z,Y\subseteq Z \Leftrightarrow (X\cup Y)\subseteq Z
\]</span> <strong>Claim:</strong> The following transformation can turn OR convolutions to element-wise multiplications: <span class="math display">\[
\mathcal{FWHT}\{a\}_i=\sum_{j\vee i=i} a_j
\]</span> <strong>Proof:</strong> <span class="math display">\[
\begin{aligned}
\mathcal{FWHT}\{a\}_i\cdot\mathcal{FWHT}\{b\}_i &amp;= \left(\sum_{j\vee i=i}a_j\right) \left(\sum_{k\vee i=i}b_k\right) \\
&amp;= \sum_{j\vee i=i}\sum_{k\vee i=i}a_jb_k \\
&amp;= \sum_{(j\vee k)\vee i=i} a_jb_k \\
&amp;= \sum_{l\vee i = i}\sum_{j \vee k = l} a_jb_k\\
&amp;= \mathcal{FWHT}\{a\circledast b\}_i
\end{aligned}
\]</span> Then how are we able to compute <span class="math inline">\(\mathcal{FWHT}\{a\}\)</span> quickly? A trivial implementation still takes <span class="math inline">\(\mathcal O(n^2)\)</span> time.</p>
<p>Recall what we did in FFT: we divide <span class="math inline">\(a\)</span> into two subsequences based on parity of indices, a.k.a, the last bit of indices. We did this because the root of unity has such amazing property as <span class="math inline">\(\omega_n^k=\omega_{n/2}^{k/2}\)</span>. We could do that here as well, but a limitation of dividing based on the last bit is that the order of elements changes in the process, so an efficient in-place implementation has to do a pre-shuffle to cope with that. Since OR is a bitwise operation, which bit based on which we divide doesn't really matter much. Why not simply <strong>divide based on the first, or the most significant bit</strong>, such that the order of elements is preserved in the process? Dividing based on the highest bit of indices, simply put, is to split <span class="math inline">\(a\)</span> into the first half, <span class="math inline">\(a^0\)</span>, and the second half, <span class="math inline">\(a^1\)</span>, in their natural order.</p>
<p>Here I introduce a notation, <span class="math inline">\(1|a\)</span> or <span class="math inline">\(0|a\)</span>. In the context where the length of the sequence is <span class="math inline">\(n\)</span> (and <span class="math inline">\(n\)</span> is a power of <span class="math inline">\(2\)</span>), <span class="math inline">\(1|a=\frac{n}{2}+a\)</span> where <span class="math inline">\(0\le a&lt;n/2\)</span>, and <span class="math inline">\(0|a\)</span> is just <span class="math inline">\(a\)</span>. In other words, <span class="math inline">\(1|a\)</span> has <span class="math inline">\(1\)</span> as the highest bit and <span class="math inline">\(0|a\)</span> has <span class="math inline">\(0\)</span> as the highest bit.</p>
<p>(Note using this notation, <span class="math inline">\(a^0_i = a_{0|i}\)</span> and <span class="math inline">\(a^1_i = a_{1|i}\)</span>)</p>
<p>To make our writing clearer, denote <span class="math display">\[
\begin{aligned}
\mathcal{FWHT}\{a\} &amp;= A \\
\mathcal{FWHT}\left\{a^0\right\} &amp;= A^0 \\
\mathcal{FWHT}\left\{a^1\right\} &amp;= A^1 \\
\end{aligned}
\]</span> We want to express each element of <span class="math inline">\(A\)</span> as a combination of some element in <span class="math inline">\(A^0\)</span> and <span class="math inline">\(A^1\)</span>.</p>
<p>We first look at the first half of <span class="math inline">\(A\)</span>. Using the notation I defined above, these elements can be expressed as <span class="math inline">\(A_{0|i}\)</span>. <span class="math display">\[
\begin{aligned}
A_{0|i}&amp;=\sum_{j\vee (0|i)=0|i}a_j \\
&amp;= \sum_{(0|j)\vee (0|i)=0|i}a^0_j + \sum_{(1|j)\vee (0|i)=0|i}a^1_j \\
\end{aligned}
\]</span> We know that the highest bit of <span class="math inline">\((1|j)\vee (0|i)\)</span> should always be <span class="math inline">\(1\)</span>, so the condition in the second summation is never satisfied, and we can simply throw the second term away. And <span class="math inline">\((0|j)\vee (0|i)=0|i\)</span> simplifies to <span class="math inline">\(j\vee i =i\)</span>, so we get, by definition of <span class="math inline">\(A^0\)</span>: <span class="math display">\[
A_{0|i} = A^0_i
\]</span> What about the second half, <span class="math inline">\(A_{1|i}\)</span>? <span class="math display">\[
\begin{aligned}
A_{1|i}&amp;=\sum_{j\vee (1|i)=1|i}a_j \\
&amp;= \sum_{(0|j)\vee (1|i)=1|i}a^0_j + \sum_{(1|j)\vee (1|i)=1|i}a^1_j \\
&amp;= A_i^0+A_i^1
\end{aligned}
\]</span> Together we get: <span class="math display">\[
A=\left(A^0, A^0+A^1\right)
\]</span> with the trivial recursion boundary <span class="math inline">\(A_0=a_0\)</span> when <span class="math inline">\(n=0\)</span>.</p>
<p>(here I use the tuple notation to denote concatenation, and <span class="math inline">\(+\)</span> to denote element-wise addition).</p>
<p>This is something we can write an in-place implementation for with ease:</p>
<pre class="line-numbers"><code class="language-cpp">void fwht_or(int n, int *a, int *A) &#123;
    copy(a, a + n, A);
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1)
        for (int l = 0; l &lt; n; l += s)
            for (int i = 0; i &lt; h; i++)
                A[l + h + i] += A[l + i]
&#125;</code></pre>
<p>Its time complexity is obviously <span class="math inline">\(\mathcal O(n\log n)\)</span> with a really small constant factor.</p>
<p>Its reverse transform turns out to be simple as well, suppose we know <span class="math inline">\(A\)</span> and let <span class="math display">\[
A=(A&#39;,A&#39;&#39;)
\]</span> (Assuming <span class="math inline">\(n\)</span> is a power of <span class="math inline">\(2\)</span> and <span class="math inline">\(A&#39;\)</span> and <span class="math inline">\(A&#39;&#39;\)</span> each have length <span class="math inline">\(n/2\)</span>)</p>
<p>Then we can recover <span class="math inline">\(A^0\)</span> and <span class="math inline">\(A^1\)</span>: <span class="math display">\[
\begin{cases}
    A^0=A&#39;\\
    A^1=A&#39;&#39;-A&#39;
\end{cases}
\]</span> Implementation:</p>
<pre class="line-numbers"><code class="language-cpp">void ifwht_or(int n, int *a, int *A) &#123; 
    std::copy(A, A + n, a);
    // If n is guaranteed to be a power of 2 then we don&#39;t need n_ and the min(...) in the inner loop.
    int n_ = 1; while (n_ &lt; n) n_ &lt;&lt;= 1; 
    // n_ = 1 &lt;&lt; (32 - __builtin_clz(n - 1));
    for (int s = n_, h = n_ / 2; h; s &gt;&gt;= 1, h &gt;&gt;= 1)
        for (int l = 0; l &lt; n; l += s)
            for (int i = 0; i &lt; std::min(i, n - l - h); i++)
                a[l + h + i] -= a[l + i]
&#125;</code></pre>
<p>And an amazing thing about this, which I haven't quite figured out why, is that the order of the outermost loop above can be reversed and both functions can be merged into one:</p>
<pre class="line-numbers"><code class="language-cpp">void fwht_or(int n, int *a, int *A, int dir = 1) &#123;
    std::copy(a, a + n, A);
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1)
        for (int l = 0; l &lt; n; l += s)
            for (int i = 0; i &lt; h; i++)
                A[l + h + i] += dir * A[l + i]
&#125;</code></pre>
<p>(Fast bitwise OR / set union convolution is sometimes aliased "Fast Mobius Transform" in Chinese CP community. Both are essentially the same.)</p>
<h1 id="bitwise-and-convolution">Bitwise AND convolution</h1>
<p>The bitwise AND convolution <span class="math display">\[
\{a\circledast b\}_i = \sum_{j\wedge k=i}a_jb_k
\]</span> can be accelerated in a similar way.</p>
<p>(Actually, by de Morgan's Law we can always reduce an AND convolution to an OR convolution)</p>
<p>Note that AND also has this interesting property: <span class="math display">\[
x \wedge z = z,y\wedge z = z \Leftrightarrow (x\wedge y)\wedge z=z
\]</span> or in set notations: <span class="math display">\[
Z\subseteq X,Z\subseteq Y \Leftrightarrow Z\subseteq(X\cap Y)
\]</span> Thus, we can prove in a way similar to what we did in OR convolution that the transform <span class="math display">\[
\mathcal{FWHT}\{a\}_i=\sum_{j\wedge i=i} a_j
\]</span> can turn convolutions to element-wise multiplications.</p>
<p>We still adopt the same divide-and-conquer approach and continue to use the notations <span class="math inline">\(a, a^0,a^1,A,A^0,A^1\)</span>.</p>
<p>Consider the first half of <span class="math inline">\(A\)</span>, which can be expressed as <span class="math inline">\(A_{0|i}\)</span>: <span class="math display">\[
\begin{aligned}
A_{0|i}&amp;=\sum_{j\wedge (0|i)=0|i}a_j \\
&amp;= \sum_{(0|j)\wedge (0|i)=0|i}a^0_j + \sum_{(1|j)\wedge (0|i)=0|i}a^1_j \\
\end{aligned}
\]</span> And by the properties of AND, both <span class="math inline">\((0|j)\wedge (0|i)=0|i\)</span> and <span class="math inline">\((1|j)\wedge (0|i)=0|i\)</span> simplify to <span class="math inline">\(j\wedge i=i\)</span>. So by definition we get <span class="math display">\[
A_{0|i}=A^0_i+A_i^1
\]</span> Then consider the other half of <span class="math inline">\(A\)</span>: <span class="math display">\[
\begin{aligned}
A_{1|i}&amp;=\sum_{j\wedge (1|i)=1|i}a_j \\
&amp;= \sum_{(0|j)\wedge (1|i)=1|i}a^0_j + \sum_{(1|j)\wedge (1|i)=1|i}a^1_j \\
&amp;= A_i^1
\end{aligned}
\]</span> Together we have: <span class="math display">\[
A=\left(A^0+A^1,A^1\right)
\]</span> with the trivial recursion boundary <span class="math inline">\(A_0=a_0\)</span> when <span class="math inline">\(n=0\)</span>.</p>
<p>This gives an efficient implementation very similar to <code>fwht_or</code> above:</p>
<pre class="line-numbers"><code class="language-cpp">void fwht_and(int n, int *a, int *A) &#123;
    std::copy(a, a + n, A);
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1)
        for (int l = 0; l &lt; n; l += s)
            for (int i = 0; i &lt; h; i++)
                A[l + i] += A[l + h + i]
&#125;</code></pre>
<p>The inverse transform is simple as well. Let <span class="math inline">\(A=(A&#39;, A&#39;&#39;)\)</span>, then <span class="math display">\[
\begin{cases}
A^0=A&#39;-A&#39;&#39; \\
A^1=A&#39;&#39;
\end{cases}
\]</span> The code:</p>
<pre class="line-numbers"><code class="language-cpp">void ifwht_and(int n, int *a, int *A) &#123; 
    std::copy(A, A + n, a);
    // If n is guaranteed to be a power of 2 then we don&#39;t need n_ and the min(...) in the inner loop.
    int n_ = 1; while (n_ &lt; n) n_ &lt;&lt;= 1; 
    for (int s = n_, h = n_ / 2; h; s &gt;&gt;= 1, h &gt;&gt;= 1)
        for (int l = 0; l &lt; n; l += s)
            for (int i = 0; i &lt; std::min(i, n - l - h); i++)
                a[l + i] -= a[l + h + i]
&#125;</code></pre>
<p>The order of the outermost loop can be reversed and we can also merge the functions above together.</p>
<h1 id="bitwise-xor-convolution">Bitwise XOR convolution</h1>
<p>The XOR operation does <strong>not</strong> have such nice property as <span class="math display">\[
x\oplus z=z, y\oplus z=z\Leftrightarrow (x\oplus y)\oplus z=z
\]</span> So accelerating the convolution <span class="math display">\[
\{a\circledast b\}_i = \sum_{j\oplus k=i}a_jb_k
\]</span> is not as straightforward as we did above.</p>
<p>We first introduce an auxiliary operation, define <span class="math inline">\(x \otimes y= \operatorname{popcount}(x\wedge y) \bmod 2\)</span>, where <span class="math inline">\(\operatorname{popcount}(x)\)</span> denotes the number of <span class="math inline">\(1\)</span>s in the binary representation of <span class="math inline">\(x\)</span>.</p>
<p><strong>Claim:</strong> The transformation below turns convolutions to element-wise multiplications: <span class="math display">\[
\mathcal{FWHT}\{a\}_i=\sum_{j\otimes i=0} a_j - \sum_{j\otimes i=1} a_j
\]</span> <strong>Proof: </strong> <span class="math display">\[
\begin{aligned}
\mathcal{FWHT}\{a\}_i\cdot\mathcal{FWHT}\{b\}_i &amp;= \left(\sum_{j\otimes i=0} a_j - \sum_{j\otimes i=1} a_j\right) \left(\sum_{k\otimes i=0} b_k - \sum_{k\otimes i=1} b_k\right) \\
&amp;= \sum_{j\otimes i=0}\sum_{k\otimes i=0}a_jb_k +\sum_{j\otimes i=1}\sum_{k\otimes i=1}a_jb_k \\
&amp;- \sum_{j\otimes i=1}\sum_{k\otimes i=0}a_jb_k - \sum_{j\otimes i=0}\sum_{k\otimes i=1}a_jb_k
\end{aligned}
\]</span> How to simplify those terms?</p>
<p>Observe that by the definition of XOR we have <span class="math display">\[
\operatorname{popcount}(x\oplus y) = \operatorname{popcount}(x)+\operatorname{popcount}(y)-2\operatorname{popcount}(x\wedge y)
\]</span> So if we apply modulo <span class="math inline">\(2\)</span> on both sides, <span class="math display">\[
\operatorname{popcount}(x\oplus y) \equiv \operatorname{popcount}(x)+\operatorname{popcount}(y) \pmod 2
\]</span> Plug in <span class="math inline">\(x=j\wedge i,y=k\wedge i\)</span> and we get <span class="math display">\[
\operatorname{popcount}((j\wedge i)\oplus (k\wedge i)) \equiv \operatorname{popcount}(j\wedge i)+\operatorname{popcount}(k\wedge i) \pmod 2
\]</span> We are almost there. Apply the identity below, whose proof I simply omit here, <span class="math display">\[
(j\wedge i)\oplus (k\wedge i)=(j\oplus k)\wedge i
\]</span> (This is something good about bitwise operations: if you cannot prove an identity the smart way you can always fall back on the dumb method -- making a truth table)</p>
<p>We finally get <span class="math display">\[
(j \oplus k)\otimes i \equiv j\otimes i+k\otimes i \pmod 2
\]</span> (We are actually quite familiar with this if we remove the circles outside <span class="math inline">\(+\)</span>s and <span class="math inline">\(\times\)</span>s)</p>
<p>With this conclusion we can simplify the four terms above: <span class="math display">\[
\begin{aligned}
\mathcal{FWHT}\{a\}_i\cdot\mathcal{FWHT}\{b\}_i &amp;= \cdots \\
&amp;= \sum_{(j\oplus k)\otimes i=0}a_jb_k - \sum_{(j\oplus k)\otimes i=1}a_jb_k \\
&amp;=  \mathcal{FWHT}\{a\circledast b\}_i
\end{aligned}
\]</span> which completes the proof.</p>
<p>We then explore how to compute <span class="math inline">\(\mathcal{FWHT}\{a\}\)</span> efficiently. Divide and conquer is still our friend, and dividing <span class="math inline">\(a\)</span> based on the highest bit works here so we continue to use those notations.</p>
<p>Consider the first half of <span class="math inline">\(A\)</span>... <span class="math display">\[
\begin{aligned}
A_{0|i} &amp;= \sum_{j\otimes (0|i)=0} a_j - \sum_{j\otimes (0|i)=1} a_j \\
&amp;= \sum_{(0|j)\otimes (0|i)=0} a_j^0+  \sum_{(1|j)\otimes (0|i)=0}a_j^1 -  \sum_{(0|j)\otimes (0|i)=1} a_j^0-  \sum_{(1|j)\otimes (0|i)=1}a_j^1 \\
&amp;= \sum_{j\otimes i=0} a_j^0+  \sum_{j\otimes i=0}a_j^1 -  \sum_{j\otimes i=1} a_j^0-  \sum_{j\otimes i=1}a_j^1 \\
&amp;= A_i^0
+A_i^1\end{aligned}
\]</span> and the other half: <span class="math display">\[
\begin{aligned}
A_{1|i} &amp;= \sum_{j\otimes (1|i)=0} a_j - \sum_{j\otimes (1|i)=1} a_j \\
&amp;= \sum_{(0|j)\otimes (1|i)=0} a_j^0+  \sum_{(1|j)\otimes (1|i)=0}a_j^1 -  \sum_{(0|j)\otimes (1|i)=1} a_j^0-  \sum_{(1|j)\otimes (1|i)=1}a_j^1 \\
&amp;= \sum_{j\otimes i=0} a_j^0+  \sum_{j\otimes i=1}a_j^1 -  \sum_{j\otimes i=1} a_j^0-  \sum_{j\otimes i=0}a_j^1 \\
&amp;= A_i^0 - A_i^1
\end{aligned}
\]</span> So together we get <span class="math display">\[
A=\left(A^0+A^1,A^0-A^1\right)
\]</span> and the inverse transform <span class="math display">\[
A=(A&#39;,A&#39;&#39;) \Rightarrow \begin{cases}
\displaystyle A^0=\frac{A&#39;+A&#39;&#39;}{2} \\
\displaystyle A^1=\frac{A&#39;-A&#39;&#39;}{2}
\end{cases}
\]</span> The code for both transforms are a bit longer than those for OR and AND, but not by too much:</p>
<pre class="line-numbers"><code class="language-cpp">void fwht_xor(int n, int *a, int *A) &#123;
    std::copy(a, a + n, A);
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1) &#123;
        for (int l = 0; l &lt; n; l += s) &#123;
            for (int i = 0; i &lt; h; i++) &#123;
                int t = A[l + h + i];
                A[l + h + i] = A[l + i] - t;
                A[l + i] += t;
            &#125;
        &#125;
    &#125;
&#125;
void ifwht_xor(int n, int *a, int *A) &#123;
    std::copy(A, A + n, a);
    // If n is guaranteed to be a power of 2 then we don&#39;t need n_ and the min(...) in the inner loop.
    int n_ = 1; while (n_ &lt; n) n_ &lt;&lt;= 1; 
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1) &#123;
        for (int l = 0; l &lt; n; l += s) &#123;
            for (int i = 0; i &lt; std::min(i, n - l - h); i++) &#123;
                int t = a[l + h + i];
                a[l + h + i] = (a[l + i] - t) / 2;
                a[l + i] = (a[l + i] + t) / 2;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>They can be merged as well:</p>
<pre class="line-numbers"><code class="language-cpp">void fwht_xor(int n, int *a, int *A, bool inv = false) &#123;
    std::copy(a, a + n, A);
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1) &#123;
        for (int l = 0; l &lt; n; l += s) &#123;
            for (int i = 0; i &lt; h; i++) &#123;
                int t = A[l + h + i];
                A[l + h + i] = A[l + i] - t;
                A[l + i] += t;
                if (inv) A[l + h + i] /= 2, A[l + i] /= 2;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p><strong>This code above is what Wikipedia refers to as the authentic Fast Walsh-Hadamard Transform</strong>.</p>
<h1 id="some-sidenotes">Some sidenotes</h1>
<p>Note that though FFT and FWHT shares the same idea of divide and conquer, FWHT does not require <span class="math inline">\(n\)</span> to be a power of <span class="math inline">\(2\)</span> whereas FFT does. (Well actually neither of them "require" <span class="math inline">\(n\)</span> to be a power of <span class="math inline">\(2\)</span>, but to apply FFT when <span class="math inline">\(n\)</span> is not a power of <span class="math inline">\(2\)</span> you either need to pad with <span class="math inline">\(0\)</span>s or you have to make your implementation really complicated).</p>
<p>Also, I just came to know that if we express WHT in the language of matrices and vectors, the matrix is called a Hadamard Matrix.</p>
<p>Another fact that I didn't quite understand is why the order of the inverse FWHT can be reversed.</p>
<p>For instance, when <span class="math inline">\(n=8\)</span>, after fully dividing the sequence into individual elements, we first merge <span class="math inline">\((0,1),(2,3),(4,5),(6,7)\)</span>, then we merge <span class="math inline">\((0,1,2,3),(4,5,6,7)\)</span> and finally <span class="math inline">\((0,1,2,3,4,5,6,7)\)</span>. Naturally when we do the inverse transform we have to start with <span class="math inline">\((0,1,2,3,4,5,6,7)\)</span>, recover <span class="math inline">\((0,1,2,3),(4,5,6,7)\)</span>, then recover <span class="math inline">\((0,1),(2,3),(4,5),(6,7)\)</span> and then recover the individual elements. But the popular implementation seems to suggest that the inverse transformation algorithm works in another direction as well. I am now puzzled why this is true and currently I'm just taking this for granted. Perhaps I derived the inversion in a different way than others did? If you have a simple explanation please leave a comment :)</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/07/30/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/30/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/" class="post-title-link" itemprop="url">莫比乌斯反演</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-30 04:26:48" itemprop="dateCreated datePublished" datetime="2020-07-30T04:26:48-04:00">2020-07-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>莫比乌斯反演是OI中应对数论问题的一大杀器，可以把很多以前需要脑子想的问题无脑化，把很多脑子想不通的问题机械化，非常方便。</p>
<h1 id="狄利克雷卷积">狄利克雷卷积</h1>
<p>对于函数<span class="math inline">\(f, g\)</span>，定义它们的狄利克雷卷积<span class="math inline">\(f \times g\)</span>为： <span class="math display">\[
(f \times g)(n) = \sum_{d \mid n} f(d)g\left(\frac{n}{d}\right)
\]</span></p>
<h2 id="性质">性质</h2>
<h3 id="积性">积性</h3>
<p>若<span class="math inline">\(f, g\)</span>为积性函数，那么<span class="math inline">\(f \times g\)</span>继承它们的积性。</p>
<p><strong>证明：</strong>令<span class="math inline">\(n, m\)</span>为互素正整数，则易证<span class="math inline">\(nm\)</span>的全体约数可以<em>不重不漏地</em>表示为<span class="math inline">\(\{d_nd_m \mid d_n \mid n, d_m \mid m\}\)</span>。</p>
<p>因此： <span class="math display">\[
\begin{aligned}
(f \times g)(nm) &amp;= \sum_{d | n} f(d)g\left(\frac{nm}{d}\right) \\
&amp;= \sum_{d_n\mid n} \sum_{d_m \mid m} f(d_nd_m)g\left(\frac{nm}{d_nd_m}\right)
\end{aligned}
\]</span> 由<span class="math inline">\(n, m\)</span>互素可知<span class="math inline">\(d_n, d_m\)</span>互素以及<span class="math inline">\(\frac{n}{d_n}, \frac{m}{d_m}\)</span>互素，结合<span class="math inline">\(f, g\)</span>的积性： <span class="math display">\[
\begin{aligned}
\begin{aligned}
(f \times g)(nm) &amp;= \sum_{d_n\mid n} \sum_{d_m \mid m} f(d_n)f(d_m)g\left(\frac{n}{d_n}\right)g\left(\frac{m}{d_m}\right) \\
&amp;= \sum_{d_n\mid n} f(d_n)g\left(\frac{n}{d_n}\right) \sum_{d_m \mid m} f(d_m)g\left(\frac{m}{d_m}\right) \\
&amp;= (f \times g)(n) \cdot (f \times g)(m)
\end{aligned}
\end{aligned}
\]</span> 证毕。</p>
<h3 id="交换律">交换律</h3>
<p><span class="math display">\[
f \times g = g \times f
\]</span></p>
<p><strong>证明：</strong>由于约数是成对出现的，显然。</p>
<h3 id="结合律">结合律</h3>
<p><span class="math display">\[
(f \times g) \times h = f \times (g \times h)
\]</span></p>
<p><strong>证明：</strong>我们需要稍微改变一下下标的写法，然后就非常清楚了： <span class="math display">\[
\begin{aligned}
\left[(f \times g) \times h \right](n) &amp;= \sum_{ab = n} (f \times g)(a) h(b) \\
&amp;= \sum_{ab = n} \sum_{cd = a}f(c)g(d) h(b) \\
&amp;= \sum_{bcd = n} f(c)g(d)h(b) \\
&amp;= \sum_{ce = n} f(c) \sum_{bd = e} g(d)h(b) \\
&amp;= \sum_{ce = n} f(c) (g \times h)(b) \\
&amp;= \left[f \times (g \times h)\right](n)
\end{aligned}
\]</span></p>
<p>得证。</p>
<h3 id="单位元">单位元</h3>
<p>定义 <span class="math display">\[
\varepsilon(n) = [n = 1]
\]</span> 易证<span class="math inline">\(\varepsilon\)</span>为狄利克雷卷积的单位元，<em>也是一个积性函数</em>，在之后的反演当中，我们也经常会把<span class="math inline">\(\varepsilon\)</span>作为艾弗森括号<span class="math inline">\([]\)</span>的替代品，因为它具有更优良的性质，简单来说： <span class="math display">\[
[f(x) = y] = \varepsilon\left(\frac{f(x)}{y}\right)
\]</span></p>
<h2 id="推论">推论</h2>
<p>关于狄利克雷卷积我们有两条非常重要的推论： <span class="math display">\[
\begin{aligned}
\mu \times 1 &amp;= \varepsilon \\
\varphi \times 1 &amp;= I
\end{aligned}
\]</span> 当中<span class="math inline">\(1\)</span>为值恒为<span class="math inline">\(1\)</span>的常值函数，<span class="math inline">\(I(x) = x\)</span>为恒等函数，易证这两个都是完全积性函数。</p>
<p><strong>证明：</strong>我们先证明第一条，假设<span class="math inline">\(n &gt; 1\)</span>有<span class="math inline">\(r\)</span>个素因子，从当中挑去若干个相乘组成<span class="math inline">\(n\)</span>的<strong>不含平方素因子</strong>的约数（如果约数含平方素因子则约数的<span class="math inline">\(\mu\)</span>为<span class="math inline">\(0\)</span>，可以直接忽略）则我们有： <span class="math display">\[
\begin{aligned}
(\mu \times 1)(n) &amp;= \sum_{i = 0}^r \binom{r}{i} (-1)^i \\
&amp;= \sum_{i = 0}^r \binom{r}{i} (-1)^i\cdot 1^{r - i}
\end{aligned}
\]</span> 结合二项式定理，得到<span class="math inline">\((\mu \times 1)(n) = (1-1)^r=0\)</span>，而如果<span class="math inline">\(n = 1\)</span>，手动展开得到<span class="math inline">\((\mu \times 1)(1) = \mu(1) = 1\)</span>。两种情况结合起来得到<span class="math inline">\(\mu \times 1 = \varepsilon\)</span>，第一条推论得证。</p>
<p>对于第二条推论，我们将其展开： <span class="math display">\[
\sum_{d \mid n} \varphi(i) = n
\]</span> 我们先考察<span class="math inline">\(n\)</span>为素数（或其幂次）的情况，设<span class="math inline">\(n = p^k\)</span>，则原式左边变为： <span class="math display">\[
\begin{aligned}
\sum_{i = 0}^k \varphi(p^i) &amp;= 1 +\sum_{i = 1} ^ k p^i\left(1 - {1 \over p}\right) \\
&amp;= 1 + \left(1 - {1 \over p}\right)\sum_{i = 1} ^ k p^i \\
&amp;= 1 + \frac{p - 1}{p} \cdot \frac{p^{k + 1} - p}{p - 1} \\
&amp;= 1 + p^k - 1 \\
&amp;= p^k
\end{aligned}
\]</span> 因此在<span class="math inline">\(n\)</span>为素数或其幂次时推论得证，而我们知道<span class="math inline">\(\varphi \times 1\)</span><strong>继承了积性</strong>，因此我们可以<strong>利用积性把推论推广到<span class="math inline">\(n\)</span>不为素数的情况</strong>（通过分解素因数即可），证毕。</p>
<h1 id="莫比乌斯反演">莫比乌斯反演</h1>
<p><strong>定理：</strong><span class="math inline">\(f \times 1 = g\)</span>当且仅当<span class="math inline">\(f = g \times \mu\)</span>。</p>
<p><strong>证明：</strong>本质上是狄利克雷卷积的推论的推论，先正着来一轮，两边同时乘以<span class="math inline">\(\mu\)</span>： <span class="math display">\[
\begin{aligned}
f \times 1 &amp;= g \\
\Rightarrow f \times 1 \times \mu &amp;= g \times \mu \\
\Rightarrow f \times \varepsilon &amp;= g \times \mu \\
\Rightarrow f &amp;= g \times \mu \\
\end{aligned}
\]</span> 我们再反着来一轮，两边同时乘上<span class="math inline">\(1\)</span>： <span class="math display">\[
\begin{aligned}
f &amp;= g \times \mu \\
\Rightarrow f \times 1 &amp;= g \times \mu \times 1 \\
\Rightarrow f \times 1 &amp;= g \times \varepsilon \\
\Rightarrow f \times 1 &amp;= g
\end{aligned}
\]</span> （所以说不要迷行网上那种大力出奇迹几个<span class="math inline">\(\sum\)</span>展开来回套的证明，看这个多简单）</p>
<p><strong>虽然存在这个莫比乌斯反演定理，但是我们更多的时候还是习惯逆用狄利克雷卷积的那两个推论。</strong></p>
<h2 id="示例varphin">示例：<span class="math inline">\(\varphi(n)\)</span></h2>
<p><span class="math display">\[
\begin{aligned}
\varphi(n) &amp;= \sum_{i = 1}^n [\gcd(i, n) = 1] \\
&amp;= \sum_{i = 1}^n \varepsilon(\gcd(i, n)) \\
\end{aligned}
\]</span></p>
<p>此时我们使用推论<span class="math inline">\(\varepsilon = \mu \times 1\)</span>： <span class="math display">\[
\begin{aligned}
\varphi(n) &amp;= \sum_{i = 1}^n \varepsilon(\gcd(i, n)) \\
&amp;= \sum_{i = 1}^n \sum_{d \mid \gcd(i, n)} \mu(d) \\
&amp;= \sum_{i = 1}^n \sum_{d \mid i, d \mid n} \mu(d) \\
\end{aligned}
\]</span> 接下来我们把<span class="math inline">\(d\)</span>的求和拖到前面去，本质上是从<strong>对约数求和变为对倍数算贡献</strong>： <span class="math display">\[
\begin{aligned}
\varphi(n) &amp;= \sum_{i = 1}^n \sum_{d \mid i, d \mid n} \mu(d) \\
&amp;= \sum_{d \mid n} \mu(d) \sum_{i = 1, d \mid i}^n 1 \\
&amp;= \sum_{d \mid n} \mu(d) \sum_{i = 1}^{n \over d} 1 \\
&amp;= \sum_{d \mid n} \mu(d) \frac{n}{d} \\
&amp;= \sum_{d \mid n} \mu(d) I\left(\frac{n}{d}\right) \\
&amp;= (\mu \times id)(n)
\end{aligned}
\]</span> 因此我们证明了<span class="math inline">\(\varphi = \mu \times id\)</span>，虽然这个结论是可以直接从莫比乌斯反演定理推得的，但是呢，这个例子确实展示了莫比乌斯反演的很多常用套路：</p>
<ol type="1">
<li>把式子写下来</li>
<li>用<span class="math inline">\(id\)</span>或者<span class="math inline">\(\varepsilon\)</span>修饰</li>
<li>逆用狄利克雷卷积的推论，把求和式后面反演成卷积形式</li>
<li>通过算贡献的方式设法把<span class="math inline">\(d\)</span>的求和项连带着只和<span class="math inline">\(d\)</span>有关的函数值一起拖到最前面</li>
<li>化简后半部分</li>
</ol>
<p>这一路下来其实是非常套路的，但往往效果拔群。</p>
<h2 id="示例sum_i-1n-varphii">示例：<span class="math inline">\(\sum_{i = 1}^n \varphi(i)\)</span></h2>
<p><strong>以下为了方便起见，如果出现<span class="math inline">\(n, m\)</span>，皆假设<span class="math inline">\(n \le m\)</span>！</strong></p>
<p>我们试试看刚刚学到的套路，来反演欧拉函数的前缀和： <span class="math display">\[
\begin{aligned}
\sum_{i = 1}^n \varphi(i) &amp;= \sum_{i = 1}^n \sum_{j = 1}^i [\gcd(i, j) = 1] \\
&amp;= \sum_{i = 1}^n \sum_{j = 1}^i \varepsilon(\gcd(i, j) = 1) \\
&amp;= \sum_{i = 1}^n \sum_{j = 1}^i \sum_{d \mid \gcd(i, j)} \mu(d) \\
&amp;= \sum_{i = 1}^n \sum_{j = 1}^i \sum_{d \mid i, d \mid j} \mu(d) \\
&amp;= \sum_{d = 1}^n \mu(d) \sum_{i = 1, d \mid i}^n \sum_{j = 1, d \mid j}^i 1\\
&amp;= \sum_{d = 1}^n \mu(d) \sum_{i = 1}^{\left\lfloor \frac{n}{d} \right\rfloor} \sum_{j = 1}^i 1\\
&amp;= \sum_{d = 1}^n \mu(d) \sum_{i = 1}^{\left\lfloor \frac{n}{d} \right\rfloor} i\\
&amp;= \sum_{d = 1}^n \mu(d) \frac{\left\lfloor \frac{n}{d} \right\rfloor \left(\left\lfloor \frac{n}{d} \right\rfloor + 1\right)}{2}\\
&amp;= \frac{1}{2} \sum_{d = 1}^n \mu(d) \left\lfloor \frac{n}{d} \right\rfloor \left(\left\lfloor \frac{n}{d} \right\rfloor + 1\right)
\end{aligned}
\]</span> 嗯，很好，很强大，但是这个有什么用呢？</p>
<h2 id="示例sum_i-1n-sum_j-1n-gcdi-j-1">示例：<span class="math inline">\(\sum_{i = 1}^n \sum_{j = 1}^n [\gcd(i, j) = 1]\)</span></h2>
<p>这个式子对应POJ3090，即有一个<span class="math inline">\(n \times n\)</span>个格点，问从最左下角能够看到几个格点，我们发现如果格点<span class="math inline">\((i, j)\)</span>不互素的话，它一定不会被看到，因此题目就被转化成了我们要求的式子，常规做法是通过把格点劈成三角形，进行转化得到答案为<span class="math inline">\(2\sum_{i = 1}^n \varphi(n) - 1\)</span>，但是这毕竟还需要一点智商，而如果你莫比乌斯反演熟练的话，这个东西推起来是非常机械化的： <span class="math display">\[
\begin{aligned}
\sum_{i = 1}^n \sum_{j = 1}^n [\gcd(i, j) = 1] &amp;= \sum_{i = 1}^n \sum_{j = 1}^n \varepsilon(\gcd(i, j) = 1)\\
&amp;= \sum_{i = 1}^n \sum_{j = 1}^n \sum_{d \mid i, d \mid j} \mu(d)\\
&amp;= \sum_{d = 1}^n \mu(d) \sum_{i = 1, d \mid i}^n \sum_{j = 1, d \mid j}^n 1 \\
&amp;= \sum_{d = 1}^n \mu(d) \sum_{i = 1}^{\left\lfloor \frac{n}{d} \right\rfloor} \sum_{j = 1}^{\left\lfloor \frac{n}{d} \right\rfloor} 1 \\
&amp;= \sum_{d = 1}^n \mu(d) \left\lfloor \frac{n}{d} \right\rfloor^2 \\
&amp;= 2 \left( \frac{1}{2} \sum_{d = 1}^n \mu(d) \left\lfloor \frac{n}{d} \right\rfloor \left(\left\lfloor \frac{n}{d} \right\rfloor + 1\right) \right) - \sum_{d = 1}^n \mu(d) \left\lfloor \frac{n}{d} \right\rfloor \\
&amp;= 2\sum_{i = 1}^n \varphi(i) - \sum_{d = 1}^n \mu(d) \left\lfloor \frac{n}{d} \right\rfloor
\end{aligned}
\]</span> 那么<span class="math inline">\(\sum_{d = 1}^n \mu(d) \left\lfloor \frac{n}{d} \right\rfloor\)</span>又是什么呢？我们借着套路反着反演： <span class="math display">\[
\begin{aligned}
\sum_{d = 1}^n \mu(d) \left\lfloor \frac{n}{d} \right\rfloor &amp;= \sum_{d = 1}^n \mu(d) \sum_{i = 1, d \mid i}^n 1 \\
&amp;= \sum_{i = 1}^n \sum_{d \mid i} \mu(d) \\
&amp;= \sum_{i = 1}^n (\mu \times 1)(d) \\
&amp;= \sum_{i = 1}^n \varepsilon(i) \\
&amp;= 1
\end{aligned}
\]</span> 原来这个是<span class="math inline">\(1\)</span>啊，那么带回去我们就得到了： <span class="math display">\[
\sum_{i = 1}^n \sum_{j = 1}^n [\gcd(i, j) = 1] = 2\sum_{i = 1}^n \varphi(i) - 1
\]</span> 以上推导中我们完全没有用到<span class="math inline">\(\varphi, \mu\)</span>的数学意义，而是顺着我们推导出的狄利克雷卷积的规则和推论进行着机械化的推导，最后也殊途同归，也许有些人会觉得这样没有卵用，那么试解： <span class="math display">\[
\sum_{i = 1}^n \sum_{j = 1}^m [\gcd(i, j) = 1]
\]</span> 借助图形和数学意义的人看到这个式子大概就去世了，但是如果我们利用反演的话，类似以上的过程可以推得： <span class="math display">\[
\sum_{i = 1}^n \sum_{j = 1}^m [\gcd(i, j) = 1] = \sum_{d = 1}^n \mu(d) \left\lfloor \frac{n}{d} \right\rfloor \left\lfloor \frac{m}{d} \right\rfloor
\]</span> 结合整除分块和<span class="math inline">\(O(n)\)</span>预处理莫比乌斯函数的前缀和我们就可以在<span class="math inline">\(O(\sqrt n)\)</span>的时间里回答每一个询问，这就是莫比乌斯反演的强大之处。</p>
<h2 id="示例sum_i-1n-sum_j-1m-gcdi-j">示例：<span class="math inline">\(\sum_{i = 1}^n \sum_{j = 1}^m \gcd(i, j)\)</span></h2>
<p>观察这个式子，我们发现和上面实例中式子的唯一不同就是我们把<span class="math inline">\(\varepsilon\)</span>换成了<span class="math inline">\(id\)</span>，对应下来就是<span class="math inline">\(\mu\)</span>换成了<span class="math inline">\(\varphi\)</span>，因此我们可以得到： <span class="math display">\[
\sum_{i = 1}^n \sum_{j = 1}^m \gcd(i, j) = \sum_{d = 1}^n \varphi(d) \left\lfloor \frac{n}{d} \right\rfloor \left\lfloor \frac{m}{d} \right\rfloor
\]</span> 依然是<span class="math inline">\(O(n)\)</span>预处理<span class="math inline">\(O(\sqrt n)\)</span>查询！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/07/29/PACT0710/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/29/PACT0710/" class="post-title-link" itemprop="url">PACT 07/10 主对偶方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-29 09:45:14" itemprop="dateCreated datePublished" datetime="2020-07-29T09:45:14-04:00">2020-07-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是主对偶方法">什么是主对偶方法？</h1>
<p>对于所有可以写成整数规划/线性规划形式的问题（不妨假设是最小化问题），由对偶定理可得，对偶最优解一定是<span class="math inline">\(\mathrm{OPT}\)</span>的一个下界。</p>
<p>因此，对偶可行解也是<span class="math inline">\(\mathrm{OPT}\)</span>的一个下界。</p>
<p>所谓的主对偶方法（Primal-dual Method），就是从一个对偶规划的可行解出发，不断优化这个对偶可行解，并在这个过程中利用对偶规划的特性指引我们求得原问题的解。</p>
<p>太抽象？</p>
<h1 id="叕访顶点覆盖">叕访顶点覆盖</h1>
<p>（顶点覆盖问题属实牛逼嗷，那么多近似方法都可以用）</p>
<p>顶点覆盖问题的主线性规划是 <span class="math display">\[
\begin{aligned}
    \text{minimize}\quad &amp;\sum_{v\in V}w_vx_v \\
    \text{subject to}\quad &amp;x_u+x_v\ge 1\quad \forall (u, v)\in E \\
    &amp;x_v \in \{0,1\}\quad \forall v\in V
\end{aligned}
\]</span> 其对偶规划是 <span class="math display">\[
\begin{aligned}
    \text{maximize}\quad &amp;\sum_{v\in E} y_e \\
    \text{subject to}\quad &amp;\sum_{v\in e} y_e \le w_v \quad \forall v \in V\\
    &amp;y_e \ge 0\quad \forall e\in E
\end{aligned}
\]</span> 显然，<span class="math inline">\(y_e=0\)</span>就是一个平凡的对偶可行解。基于主对偶方法的思想，我们可以得到两个算法：</p>
<h2 id="算法1">算法1</h2>
<ol type="1">
<li>初始化<span class="math inline">\(y_e\gets0,C\gets \emptyset\)</span>。</li>
<li>当还有一条边<span class="math inline">\((u,v)\)</span>没有被覆盖时，
<ol type="1">
<li><span class="math inline">\(\varepsilon\gets \min\left\{w_u-\sum_{u\in e} y_e,w_v-\sum_{v\in e} y_e\right\}\)</span>。</li>
<li><span class="math inline">\(y_e\gets y_e+\varepsilon\)</span>（以上两步旨在尽可能增加<span class="math inline">\(y_e\)</span>直至两端点中一个点对应的约束收紧）。</li>
<li>假设增加<span class="math inline">\(y_e\)</span>之后<span class="math inline">\(u\)</span>对应的约束收紧了，那么<span class="math inline">\(C\gets C\cup\{u\}\)</span>。</li>
<li>同时删除所有与<span class="math inline">\(u\)</span>邻接的边。</li>
</ol></li>
<li>返回<span class="math inline">\(C\)</span>。</li>
</ol>
<p>（注意到，当<span class="math inline">\(w_u=1\)</span>时，这个算法退化为我们最初学的极大匹配算法）</p>
<h2 id="算法2">算法2</h2>
<ol type="1">
<li>初始化<span class="math inline">\(y_e\gets0,C\gets \emptyset\)</span>。</li>
<li>当<span class="math inline">\(C\)</span>不是一个合法的顶点覆盖时，
<ol type="1">
<li><span class="math inline">\(\varepsilon\gets \min_{v\in V} \left\{\frac{1}{\deg(v)}\sum_{v\in e}y_e\right\}\)</span></li>
<li>对于所有边<span class="math inline">\(e\in E\)</span>，<span class="math inline">\(y_e\gets y_e+\varepsilon\)</span>（以上两步旨在同时增加所有<span class="math inline">\(y_e\)</span>直至有约束收紧）。</li>
<li>将所有紧约束对应的顶点加入<span class="math inline">\(C\)</span>。</li>
<li>同时删去这些点和它们邻接的所有边。</li>
</ol></li>
<li>返回<span class="math inline">\(C\)</span>。</li>
</ol>
<p>其实还有很多这样的寻找局部极大对偶可行解的方法，以上两个算法是最容易想到的。</p>
<h2 id="分析">分析</h2>
<p>两个算法的分析是共通的： <span class="math display">\[
\begin{aligned}
    \sum_{v\in C}w_v &amp;= \sum_{v \in C}\sum_{v\in e\in E} y_e \\
    &amp;= \sum_{e\in E} y_e |C\cap e| \\
    &amp;\le \sum_{e\in E} y_e \cdot 2 \\
    &amp;= 2 \cdot \mathrm{OPT}_{\text{dual}} \\
    &amp;\le 2 \cdot \mathrm{OPT}
\end{aligned}
\]</span> 以上步骤的第一步是因为我们加入覆盖集的所有顶点对应的约束都是紧的。</p>
<p>主对偶方法神奇的一点就在于：<strong>虽然我们在线性规划的指导下进行设计与分析，但是最后的算法却是一个完全不需要求解线性规划的纯粹的组合算法（Combinatorial Algorithm），因此非常优雅。</strong></p>
<h1 id="再探设施选址">再探设施选址</h1>
<p>回忆之前设施选址的线性规划。<span class="math inline">\(y_i\)</span>表示设施<span class="math inline">\(i\)</span>是否被选，<span class="math inline">\(x_{ij}\)</span>表示用户<span class="math inline">\(j\)</span>是否到设施<span class="math inline">\(i\)</span>去： <span class="math display">\[
\begin{aligned}
    \text{minimize}\quad &amp;\sum_{i\in F}f_iy_i + \sum_{j\in D}\sum_{i \in F}c_{ij}x_{ij} \\
    \text{subject to}\quad &amp;\sum_{i\in F}x_{ij} \ge 1 \quad \forall j\in D \\
    &amp;y_i - x_{ij} \ge 0 \quad \forall i\in F, j\in D \\
    &amp;x_{ij} \ge 0 \quad \forall i\in F, j\in D \\
    &amp;y_i \ge 0 \quad \forall i \in F
\end{aligned}
\]</span> 其对偶为 <span class="math display">\[
\begin{aligned}
    \text{maximize}\quad &amp;\sum_{j \in D}\alpha_j \\
    \text{subject to}\quad &amp;\alpha_j - \beta_{ij} \le c_{ij}\quad \forall i \in F, j\in D \\
    &amp;\sum_{j\in D}\beta_{ij} \le f_i\quad \forall i\in F
\end{aligned}
\]</span></p>
<p>以下将对偶规划中第一行的约束称为“第一类约束”，第二行的约束称为“第二类约束”。</p>
<h2 id="算法">算法</h2>
<p>我们设计一个基于主对偶方法的近似算法：</p>
<ol type="1">
<li>初始化<span class="math inline">\(\alpha_j\gets 0,\beta_{ij}\gets 0\)</span>（平凡的对偶可行解）。</li>
<li>以相同的速率同时增加的值<span class="math inline">\(\alpha_j\)</span>。</li>
<li>当对于某些<span class="math inline">\(i,j\)</span>出现<span class="math inline">\(\alpha_j=c_{ij}\)</span>时，为了能够在不违反第一类约束的前提下让<span class="math inline">\(\alpha_j\)</span>继续增加，我们开始同步增加<span class="math inline">\(\beta_{ij}\)</span>的值。</li>
<li>随着一些<span class="math inline">\(\beta_{ij}\)</span>值的增加某些第二类约束也会收紧，此时暂时开放该约束对应的设施。因为此时对应的<span class="math inline">\(\beta_{ij}\)</span>不能再增加了，那些<span class="math inline">\(\alpha_j\)</span>也自然不会再增加了，我们就此将这些<span class="math inline">\(\alpha_j\)</span>的值冻结起来（其余的<span class="math inline">\(\alpha_j\)</span>可以继续增加）。</li>
<li>不断重复以上步骤直至所有的<span class="math inline">\(\alpha_j\)</span>都被冻结了。</li>
<li>按照第4步开放的先后顺序处理所有暂时开放的设施，
<ol type="1">
<li>永久开放该设施，</li>
<li>并将所有和该设施共享一个“紧顾客”（tight client，指和设施对应约束是紧的顾客，这里实在是不怎么好翻，具体的解释参看下面的感性认识和接下来的分析），即那些两边的<span class="math inline">\(\beta\)</span>都大于<span class="math inline">\(0\)</span>的顾客的暂时开放的设施关闭（移出队列）。</li>
</ol></li>
</ol>
<p>听听这是人话吗？感性理解一下以上算法（也有助于接下来的分析）：</p>
<ol type="1">
<li><span class="math inline">\(\alpha_j\)</span>可以理解为每个顾客为了得到服务愿意付出的代价，一开始所有人都想白嫖。</li>
<li>显然如果大家都想白嫖的话没有一个人会得到服务，因此大家一起提升这个愿意付出的代价。</li>
<li>当<span class="math inline">\(\alpha_j=c_{ij}\)</span>也就是某个顾客发现自己愿意支付的价位内出现了设施的时候他就很高兴。但是这个设施没开，所以顾客决定给这个设施的开放分摊成本（增加<span class="math inline">\(\beta_{ij}\)</span>），但是这样也不是个事，万一不远处有个不需要他付钱或者只需要分摊很少开张费用的设施呢？所以<span class="math inline">\(\alpha_j\)</span>的增长也不能落下。</li>
<li>当有第二类约束收紧，即几个顾客终于凑够了钱让这个设施开放，那么这个设施就暂时开张了。这几个用户很满足，就准备去这个设施了，所以他们的<span class="math inline">\(\alpha_j\)</span>不增加了。</li>
<li>不断重复以上步骤直至满足所有顾客的需求。</li>
<li>按照第4步开放的先后顺序处理暂时开张的设施，
<ol type="1">
<li>永久开张，</li>
<li>如果去这个设施的顾客里有人给其他设施也分摊成本了，那把那些设施全部关掉。</li>
</ol></li>
</ol>
<p>（如果我把上面变量的名字换一下，把“第一类约束”，“第二类约束”也换个名字，那么从上面的算法当中你根本看不到线性规划的痕迹，这就是一个听着很有道理实际上近似比也有保证的组合算法。这就是主对偶方法的优雅之处。）</p>
<h2 id="分析-1">分析</h2>
<p>我们不妨称那些为最后永久开放的设施垫付开张成本的顾客为“幸运顾客”，形式上地来说，一个顾客<span class="math inline">\(j\)</span>为幸运顾客当且仅当最后永久开张的设施中有一处设施<span class="math inline">\(i\)</span>使得<span class="math inline">\(\alpha_j-\beta_{ij}=c_{ij},\beta_{ij}&gt;0\)</span>，也就是说顾客<span class="math inline">\(j\)</span>和设施<span class="math inline">\(i\)</span>之间在对偶规划对应的约束是紧的——这也是上面tight client的本意。</p>
<p>相对地我们称不是幸运顾客的那些顾客“倒霉顾客”，说他们倒霉是因为他们明明给某些设施分摊了开张成本，也都准备好去那里了，结果这个设施在最后关掉了。</p>
<p>不妨设最后决定开张的设施为<span class="math inline">\(F&#39;\)</span>，幸运顾客的集合为<span class="math inline">\(L\)</span>。<span class="math inline">\(j \to i\)</span>表示顾客<span class="math inline">\(j\)</span>到设施<span class="math inline">\(i\)</span>的约束是紧的（也就是顾客<span class="math inline">\(j\)</span>给设施<span class="math inline">\(i\)</span>分摊了成本）。注意由于我们算法最后一步的清理操作，每个幸运顾客只可能垫付一个<span class="math inline">\(F\)</span>中设施的成本，那么设施的开放费用和幸运顾客的服务成本可以一起表示为： <span class="math display">\[
\begin{align}
    &amp;\quad\,\sum_{i\in F&#39;}f_i+\sum_{j\in L} \sum_{\substack{i\in F&#39;\\ j\to i}} c_{ij}\\
    &amp;= \sum_{i \in F&#39;}\sum_{\substack{j\in L\\ j\to i}} \beta _{ij}+\sum_{j\in L} \sum_{\substack{i\in F&#39;\\ j\to i}} \left(\alpha_j - \beta_{ij}\right) \\
    &amp;=\sum_{j \in L} \alpha_{j}
\end{align}
\]</span> 我们接下来分析倒霉顾客的情况。</p>
<p>假设有一个倒霉顾客<span class="math inline">\(k\)</span>，他分摊了设施<span class="math inline">\(b\)</span>的开张成本并最终让设施<span class="math inline">\(b\)</span>暂时开张（同时假设<span class="math inline">\(b\)</span>是他分摊成本的设施中最先开张的——也就是<span class="math inline">\(\alpha_k\)</span>恰在<span class="math inline">\(b\)</span>开张后被冻结）。但是比<span class="math inline">\(b\)</span>早开张的设施<span class="math inline">\(a\)</span>中有一个幸运顾客<span class="math inline">\(j\)</span>也为<span class="math inline">\(b\)</span>分摊了成本，导致最后清理的时候<span class="math inline">\(b\)</span>被关闭了。不妨假设<span class="math inline">\(k\)</span>最后只能去<span class="math inline">\(a\)</span>。注意到由三角不等式， <span class="math display">\[
\begin{align}
c_{ak} &amp;\le c_{aj} + c_{bj} +c_{bk} \\
&amp;\le (\alpha_j-\beta_{aj}) + (\alpha_j - \beta_{bj}) + (\alpha_{k}-\beta_{bk}) \\
&amp;\le \alpha_j+\alpha_j + \alpha_k \\
&amp;\le 3\alpha_k
\end{align}
\]</span> 最后一步之所以成立，是因为<span class="math inline">\(a\)</span>开张后<span class="math inline">\(\alpha_j\)</span>必然冻结，<span class="math inline">\(\alpha_k\)</span>停止增长要等到<span class="math inline">\(b\)</span>开张后。而<span class="math inline">\(a\)</span>比<span class="math inline">\(b\)</span>先开张，因此<span class="math inline">\(\alpha_k \ge \alpha_j\)</span>。我们在上面假设<span class="math inline">\(k\)</span>最后去了<span class="math inline">\(a\)</span>，其实如果最后<span class="math inline">\(k\)</span>去了比<span class="math inline">\(a\)</span>还近的那自然他的服务成本更低了。</p>
<p>因此倒霉顾客的服务成本<span class="math inline">\(\le \sum_{k\in D\setminus L} \alpha_k\)</span>。</p>
<p>结合上述的分析，我们可以得到我们的总成本： <span class="math display">\[
\begin{align}
    \text{total cost} &amp;\le \sum_{j\in L} \alpha_j + \sum_{k\in D\setminus L} 3\alpha_k \\
    &amp;\le 3\sum_{j\in D}\alpha_j \\
    &amp;\le 3\cdot\mathrm{OPT}
\end{align}
\]</span> 也就是说，我们证明了我们这个算法的近似比为<span class="math inline">\(3\)</span>。</p>
<h2 id="为什么最后一步要清理一些暂时开张的设施">为什么最后一步要清理一些暂时开张的设施？</h2>
<p>为什么我们算法的最后一步要清理暂时开张的设施呢？为什么不能一些用户分摊够开张费用就让这个设施永久开张下去呢？</p>
<p>考虑如下的一个实例：</p>
<p>有<span class="math inline">\(n\)</span>个设施，其中<span class="math inline">\(f_1=n+1\)</span>且<span class="math inline">\(f_i=n+2\quad\forall i =2,3,\cdots,n\)</span>。</p>
<p>有<span class="math inline">\(2n\)</span>个顾客。前<span class="math inline">\(n\)</span>名顾客到所有设施的距离都是<span class="math inline">\(1\)</span>。对于后面的<span class="math inline">\(n\)</span>名顾客，第<span class="math inline">\(n+i\)</span>名顾客只和设施<span class="math inline">\(i\)</span>的距离为<span class="math inline">\(1\)</span>，和其余设施的距离都为<span class="math inline">\(3\)</span>。易证这样的边权满足三角不等式。</p>
<p>现在考察我们算法的运行情况：</p>
<ul>
<li><span class="math inline">\(t=0\)</span>，初始化。</li>
<li><span class="math inline">\(t=1\)</span>，所有的<span class="math inline">\(\alpha_j=1\)</span>，每名顾客开始为至少一个设施分摊成本了。</li>
<li><span class="math inline">\(t=2\)</span>，对于任何一个设施都有<span class="math inline">\(n+1\)</span>名顾客为其人均分摊了<span class="math inline">\(1\)</span>的开张成本，而注意到<span class="math inline">\(f_1=n+1\)</span>，因此设施<span class="math inline">\(1\)</span>开张了，相应地，前<span class="math inline">\(n\)</span>名顾客和第<span class="math inline">\(n+1\)</span>名顾客的<span class="math inline">\(\alpha_j\)</span>被冻结。其余的<span class="math inline">\(n-1\)</span>名顾客继续为对应的设施分摊费用。</li>
<li><span class="math inline">\(t=3\)</span>，剩下的<span class="math inline">\(n-1\)</span>家设施全部开张。</li>
</ul>
<p>如果没有最后的清理步骤，那么我们的算法会开放所有的设施。光是开放设施的代价就有<span class="math inline">\(n+1+(n-1)(n+2)=\Omega(n^2)\)</span>。而只开一家设施的代价是<span class="math inline">\(O(n)\)</span>的。因此最后的清理步骤非常重要！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/07/29/PACT0709/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/29/PACT0709/" class="post-title-link" itemprop="url">PACT 07/09 设施选址问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-29 04:17:40" itemprop="dateCreated datePublished" datetime="2020-07-29T04:17:40-04:00">2020-07-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="定义">定义</h1>
<p><strong>输入：</strong>二分图<span class="math inline">\(G\)</span>，顶点集分为设施集<span class="math inline">\(F\)</span>和客户集<span class="math inline">\(D\)</span>。设施<span class="math inline">\(i\)</span>的开放费用为<span class="math inline">\(f_i\)</span>，用户<span class="math inline">\(j\)</span>到设施<span class="math inline">\(i\)</span>的有权为<span class="math inline">\(c_{ij}\)</span>的边代表距离。边权满足三角不等式。</p>
<p><strong>目标：</strong>寻找一组设施<span class="math inline">\(S\)</span>，使得 <span class="math display">\[
\sum_{i \in S} f_i + \sum_{j\in D} \min_{i \in S} \{c_{ij}\}
\]</span> 即每个用户都会去离自己最近（或者说最划算）设施，求最小化开店费用加上服务成本（即每个顾客要走的距离之和）的开店方案。</p>
<h1 id="线性规划表述">线性规划表述</h1>
<p>令<span class="math inline">\(y_i\)</span>表示设施<span class="math inline">\(i\)</span>是否被选，<span class="math inline">\(x_{ij}\)</span>表示用户<span class="math inline">\(j\)</span>是否到设施<span class="math inline">\(i\)</span>去，则设施选址问题可以表述为下列线性规划（松弛整数限制）： <span class="math display">\[
\begin{aligned}
    \text{minimize}\quad &amp;\sum_{i\in F}f_iy_i + \sum_{j\in D}\sum_{i \in F}c_{ij}x_{ij} \\
    \text{subject to}\quad &amp;\sum_{i\in F}x_{ij} \ge 1 \quad \forall j\in D \\
    &amp;y_i - x_{ij} \ge 0 \quad \forall i\in F, j\in D \\
    &amp;x_{ij} \ge 0 \quad \forall i\in F, j\in D \\
    &amp;y_i \ge 0 \quad \forall i \in F
\end{aligned}
\]</span> 其中第一个约束表示所有顾客至少要去一个设施。第二个约束表示只有一个设施开的时候用户才可以去。</p>
<p>其对偶为 <span class="math display">\[
\begin{aligned}
    \text{maximize}\quad &amp;\sum_{j \in D}\alpha_j \\
    \text{subject to}\quad &amp;\alpha_j - \beta_{ij} \le c_{ij}\quad \forall i \in F, j\in D \\
    &amp;\sum_{j\in D}\beta_{ij} \le f_i\quad \forall i\in F
\end{aligned}
\]</span></p>
<p>令<span class="math inline">\((x^*,y^*)\)</span>和<span class="math inline">\((\alpha^*,\beta^*)\)</span>为主规划和对偶规划的最优解。显然，在线性规划当中很可能出现<span class="math inline">\(0&lt;x^*_{ij}&lt;1\)</span>即“部分得到服务”的情况。</p>
<h1 id="近似算法的设计思路与分析">近似算法的设计思路与分析</h1>
<p><strong>引理：</strong>如果<span class="math inline">\(x_{ij}^* &gt; 0\)</span>那么<span class="math inline">\(\alpha_j^* \ge c_{ij}\)</span>。</p>
<p><strong>证明：</strong>由主互补松弛条件，若<span class="math inline">\(x_{ij}^*&gt;0\)</span>则<span class="math inline">\(\alpha_j^*-\beta_{ij}^* = c_{ij}\)</span>，又<span class="math inline">\(\beta_{ij}^* \ge 0\)</span>，得证。</p>
<p>定义顾客<span class="math inline">\(j\)</span>所有部分光顾的设施为<span class="math inline">\(j\)</span>的邻域<span class="math inline">\(N(j)=\left\{ i \Big| x_{ij}^* &gt; 0,i\in F\right\}\)</span>。</p>
<p>很容易想到一个近似算法：<strong>对于每一个顾客，我们开放邻域中离他最近的设施</strong>。</p>
<p>由于我们的引理和弱对偶原理，我们的总服务成本<span class="math inline">\(\le \sum_{j\in D}\alpha_j^* \le \mathrm{OPT}\)</span>。如果我们开放设施的成本也有个上界就好了。</p>
<p>然而并不行。</p>
<p>考虑如下反例：</p>
<p><img src="/2020/07/29/PACT0709/P1.svg" class=""></p>
<p>如果按照我们的算法，我们会为<span class="math inline">\(j\)</span>和<span class="math inline">\(j&#39;\)</span>分别开放一个代价<span class="math inline">\(24\)</span>的设施。而事实上开那个代价<span class="math inline">\(25\)</span>的设施就够了。我们差不多浪费了两倍的钱，而这个倍数可以任意高（只要让代价稍高一点的设施处在所有顾客的邻域当中，而使每个顾客的邻域中都有比其代价略低的设施即可）。</p>
<p>但是我们知道，<strong>对于任何一组邻域不交的顾客，开放设施的代价确实是不大于<span class="math inline">\(\mathrm{OPT}\)</span>的</strong>（为什么？因为那些设施只服务一个顾客，而那个顾客有可能“部分”光顾其他设施。比如说一个顾客光顾了<span class="math inline">\(0.5\)</span>的设施<span class="math inline">\(1\)</span>（代价为<span class="math inline">\(10\)</span>）和<span class="math inline">\(0.5\)</span>的设施<span class="math inline">\(2\)</span>（代价为<span class="math inline">\(20\)</span>），那么这个顾客就给目标函数贡献了<span class="math inline">\(0.5\times10+0.5\times 20\)</span>，显然这个时候如果我去开代价<span class="math inline">\(10\)</span>的那个设施，开店费是<span class="math inline">\(10\)</span>，是小于最优目标函数的）</p>
<p>那我不妨先任选一组邻域不交的顾客（不妨称之为“幸运顾客”）按照就近原则开放他们的设施，然后再让那些邻域和幸运顾客有交集的顾客（不妨称之为“倒霉顾客”）去这些设施。</p>
<p>根据我们之前的分析，幸运顾客的服务成本一定不大于<span class="math inline">\(\mathrm{OPT}\)</span>，考虑倒霉顾客的服务成本。假设倒霉顾客<span class="math inline">\(j\)</span>和幸运顾客<span class="math inline">\(i\)</span>的邻域共享一个设施<span class="math inline">\(b\)</span>，幸运顾客可以去离他最近的设施<span class="math inline">\(a\)</span>。</p>
<p>那么根据三角不等式，让<span class="math inline">\(j\)</span>去<span class="math inline">\(a\)</span>的距离为 <span class="math display">\[
c_{aj} \le c_{bj}+c_{bi}+c_{ai}
\]</span> 根据引理， <span class="math display">\[
\begin{align}
c_{aj} &amp;\le c_{bj}+c_{bi}+c_{ai} \\
&amp;\le \alpha_j^* + \alpha_i^* + \alpha _i^* \\
&amp;\stackrel{?}{\le} 3\alpha_j^* 
\end{align}
\]</span> 最后一步是我们希望得出的，因为如果这样，那么所有顾客的服务成本的上界就是（不妨令幸运顾客的集合为<span class="math inline">\(D_1\)</span>，不幸运顾客的集合为<span class="math inline">\(D_2\)</span>）： <span class="math display">\[
\begin{align}
    \sum_{j\in D_1} \alpha_j^* + \sum_{j\in D_2}3\alpha_j^* \le \sum_{j\in D_1}3 \alpha_j^* + \sum_{j\in D_2}3\alpha_j^* = \mathrm{OPT}_{\text{dual}} \le \mathrm{OPT}
\end{align}
\]</span> 但是按照目前的信息最后一步并不总是成立的。</p>
<p>那怎么办？改算法呗。我们只需要保证所有幸运顾客的<span class="math inline">\(\alpha^*\)</span>都小于等于倒霉顾客的<span class="math inline">\(\alpha^*\)</span>，也就是说排一下序就好了。</p>
<p>于是我们就得到了我们的算法：</p>
<ol type="1">
<li>解原线性规划和对偶线性规划，得到<span class="math inline">\((x^*,y^*),(\alpha^*,\beta^*)\)</span>。</li>
<li>选一个<span class="math inline">\(\alpha^*\)</span>最小的顾客并开放他邻域当中离他最近的店。</li>
<li>暂时移除所有和这个顾客有相交邻域的顾客。</li>
<li>持续以上两步直至所有顾客都被选中或移除。</li>
<li>让所有被移除的顾客去离他们最近的已开放设施。</li>
</ol>
<p>这个算法的近似是多少呢？上面的分析已经说明了这个方案的设施成本不大于<span class="math inline">\(\mathrm{OPT}\)</span>，而服务成本不大于<span class="math inline">\(3\mathrm{OPT}\)</span>，因此总的来说这就是一个<span class="math inline">\(4\)</span>倍近似算法。</p>
<h1 id="近似难度">近似难度</h1>
<p><strong>定理（Guha, Khuller 1999）：</strong>如果设施选址问题存在近似比小于<span class="math inline">\(1.463\)</span>的算法，则<span class="math inline">\(\mathsf{P}=\mathsf{NP}\)</span>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chengyuan Ma</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js" integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha512-br8H6OngKoLht57WKRU5jz3Vr0vF+Tw4G6yhNN2F3dSDheq4JiaasROPJB1wy7PxPk7kV/+5AIbmoZLxxx7Zow==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-bash.min.js" integrity="sha512-JvRd44DHaJAv/o3wxi/dxhz2TO/jwwX8V5/LTr3gj6QMQ6qNNGXk/psoingLDuc5yZmccOq7XhpVaelIZE4tsQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-c.min.js" integrity="sha512-T6Lco61aWqCKSznWkd38lf159pD0+EwZ9UCEv6ARAvaWFiy/UHtYgOmlasT8lq5Ck17ZNHzbe5eHUablTGRXxw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cmake.min.js" integrity="sha512-M99z3be36IUB5pA3DWoJvjSYaZA9BiUqf1jXzVcjntASBZFNI53oDRzdJqGzH5voybcAx5Sg8F5QyryE6afD3g==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cpp.min.js" integrity="sha512-hxZJ6OUEpUl9/o4C1gMGvrAbeqDaldBiZbs08c/V8NcU7YImBFlqJAc7Uzjf3bh2W8Wx26/dVDyPk9cUMQY0Mw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-go.min.js" integrity="sha512-SgF1uayJ2/8TV+MhLasqygnm++vYRXswmrR2ZAmUCL4pXtf+6KzUgXPpn10Y6xca658sxOQEOsoP3MChfhke5A==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-java.min.js" integrity="sha512-PWHY6Vao4E9K4LsGBYCY0ttDeiWZwuUozTbJvSy9UFHRz2J4Bl7rcWML3wEnJTVuCJhSwGne/8My5gTo/gnbpg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-json.min.js" integrity="sha512-IC7rV8RslChgByOdUFC6ePqOGn+OwJhnKC3S5AezM8DAiOdGhJMwgsIvBChsa2yuxxoPbH2+W/kjNUM1cc+jUQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-kotlin.min.js" integrity="sha512-aTozTdtORp/xxS/dhRRDfmv/p1eyEMTje96MplkSOqdbKGGvOYIlogoGdtsh/BD91vaqKoAw9M7O/DodqqudIQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-julia.min.js" integrity="sha512-eTGeKQdDzC2rPAUVfM2Fa36s9B9wp138NEhzZqJpRSdJQ66BwLUot25r2YQveCRU5uYNVfX3gckDkl4byfBIWw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-latex.min.js" integrity="sha512-6D3l3Fy8g/hr6AeK2g1rcVZHyFjCqiqgUrwy0mBZTGFd8UwVcUDhzQeIIv3eYeXDecGPTtBOS9ctyRzJyUgypQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-rust.min.js" integrity="sha512-kgT7r2HlCEO4b+Rp3nJvm+/EMBwGMvv1WMdWkb3eNgnS91llMli8Y3T1CgnD8Hifqx50Q3XLUQXDd7PzKQQtUA==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-python.min.js" integrity="sha512-wK9tQmDrstGtZqTKcyVf3h457QGMlNriKs+fHmEkiCizrq0LVovfT3v1smeT1DlQetHhdRkkX1JSuZg5LoNHJg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-nginx.min.js" integrity="sha512-/MNzg8GlnVrAau/TZClh1jxgHNX0HDgidbGnHS5x1OtbKiNoK3e0XNd1oV16xmmeDHjisa3GKLArUau+43GZ4A==" crossorigin="anonymous"></script>
<script type = "text/javascript">
    document.addEventListener('pjax:complete', function() {
        if (typeof Prism !== 'undefined') {
            Prism.highlightAll();
        }
    });
</script>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  






  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    <div class="pjax">

  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



    </div>
</body>
</html>
