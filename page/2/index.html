<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"alan20210202.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="不务正业高中生一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="Chengyuan Ma&#39;s Blog">
<meta property="og:url" content="https://alan20210202.github.io/page/2/index.html">
<meta property="og:site_name" content="Chengyuan Ma&#39;s Blog">
<meta property="og:description" content="不务正业高中生一枚">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chengyuan Ma">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://alan20210202.github.io/page/2/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.css" integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbggqjHJeyzx88I3rfwjS38WJag/ihH7lzuGlGHpDBymLirZQ==" crossorigin="anonymous" />
<title>Chengyuan Ma's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-65HSG5NCY6"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-65HSG5NCY6');
      }
    </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Chengyuan Ma's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-pagedewarp"><a href="/dewarp/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>PageDewarp</a></li>
        <li class="menu-item menu-item-english"><a href="/english/" rel="section"><i class="fa fa-globe-americas fa-fw"></i>English</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chengyuan Ma"
      src="/avatar.png">
  <p class="site-author-name" itemprop="name">Chengyuan Ma</p>
  <div class="site-description" itemprop="description">不务正业高中生一枚</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">94</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://kalasearch.cn/" title="https:&#x2F;&#x2F;kalasearch.cn&#x2F;" rel="noopener" target="_blank">卡拉搜索</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/08/28/Minecraft%20ILP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/28/Minecraft%20ILP/" class="post-title-link" itemprop="url">Designing Computational Redstone Circuits Automatically in Minecraft with Integer Programming: Preliminary Thoughts and Tests</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-28 13:48:50" itemprop="dateCreated datePublished" datetime="2020-08-28T13:48:50+08:00">2020-08-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-25 17:05:52" itemprop="dateModified" datetime="2020-11-25T17:05:52+08:00">2020-11-25</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>UNFINISHED ARTICLE -- WORK IN PROGRESS</strong></p>
<p><strong>UNFINISHED ARTICLE -- WORK IN PROGRESS</strong></p>
<p><strong>UNFINISHED ARTICLE -- WORK IN PROGRESS</strong></p>
<p>This was a project I worked on two months ago, but it wasn't until now that I have the time to write it down and share it on my blog.</p>
<h1 id="intro">Intro</h1>
<p>Redstone has been a core element in the game Minecraft for quite some years. It is presumably the most untrivial one as well: while anyone could master nearly all Minecraft mechanics through experiences, it takes not only experience but also ingenuity to design a good redstone circuit. Few of us are bold enough to claim "I master redstone", even after playing Minecraft for a decade.</p>
<p>So here comes the question: <strong>Can the design of redstone circuits, the core of Minecraft automations, be automated?</strong> and <strong>If so, how?</strong> (appreciate how meta this is :)</p>
<p>Theoretically, the answer is "yes...but". Minecraft has a finite world, and each position has a finite number of possible blockstates. We can write a program to enumerate all possible placements of blocks until we find some placement corresponding to the desired redstone circuit. However, this needs exponential time and we may need to wait for a century before it could give us, for instance, a decent piston door. Moreover, if a circuit involves manipulation of entities (which could have infinite many states), then we are easily screwed.</p>
<p>Well, perhaps it is difficult to let a program design any redstone circuit. But there is indeed a subset of redstone circuits whose design can very likely be automated -- <strong>computational redstone circuits</strong>, aka. logic gates, calculators, CPUs etc. Why? Because software that design their real world electronic counterparts are readily available -- they are called "EDA".</p>
<p>As a high school student I, of course, know little about the inner workings of real-world EDA applications (and there doesn't seem to be a lot of resources out there). I am convinced that this problem is NPC (further articulated below), so designing an efficient polytime combinatorial algorithm doesn't seem plausible. That said, what about reducing this problem to some other NPC problems which we can solve relatively quickly with optimized algorithms / heuristics -- say, ILP? This is what I am trying to do here.</p>
<h1 id="formulating-the-problem">Formulating the problem</h1>
<p>"Designing computational redstone circuit automatically" is a vague idea, so it is necessary that we know what this truly means.</p>
<h2 id="whats-the-input">What's the input?</h2>
<p>The input should describe the intended functionality of a circuit. Recall how we usually describe a circuit: we draw a <strong>circuit diagram</strong>. I here characterize a redstone circuit diagram by the assumptions and constraints below:</p>
<ol type="1">
<li>A circuit contains two parts: <strong>wires and components</strong>.</li>
<li>Components are the <strong>primitives</strong> of a circuit. E.g. A torch or a wire junction.</li>
<li>A component has <strong>interfaces</strong>, either <strong>in or out</strong>, as where the component receives signals from and sends signals to.</li>
<li>A wire connects <strong>an</strong> out-interface from a component ("source") to <strong>an</strong> in-interface of another component ("target").</li>
<li>Wires are <strong>directed</strong>.</li>
<li>Components are <strong>independent</strong>. i.e. they do not interfere with other components in any way other than being connected by wires from interfaces.</li>
</ol>
<p>A circuit diagram can be represented in a directed graph, with components as vertices and wires as edges. Source/target interfaces as extra information stored on edges.</p>
<h2 id="whats-the-output">What's the output?</h2>
<p>We want our program to tell us how the circuit we described in the input can be built in the Minecraft world. Therefore, we could define the the output to be a set of position - blockstate pairs, (which, in implementation, can be stored in a schematic file).</p>
<p>However, we don't want to jump straight from a circuit diagram to a detailed Minecraft schematic because that means taking interference between components, quasi connectivity, update order -- basically everything that makes redstone engineering complex -- into consideration in the first place.</p>
<p>Instead, we could first build our circuit in an <strong>ideal world</strong>, in which we forget about all those factors above, and then convert the ideal placement into an actual Minecraft schematic.</p>
<p>What's an idea world?</p>
<ol type="1">
<li>A circuit consists of multiple ideal blocks.</li>
<li>A component fully occupies a set of ideal blocks, some of which are its interfaces. How many and which blocks a certain type of component occupies depend on its size in Minecraft and how we plan to convert the ideal placement to a real schematic.</li>
<li>A wire is a chain of blocks, where any adjacent two share a face. The first block is always the source interface and the last is always the target interface.</li>
<li><strong>Exclusiveness: </strong>All components and all wires (ignoring their first and last block) mustn't overlap.</li>
<li><strong>Mutual Independence: </strong>Unless both blocks are occupied by the same component / wire, anything in two adjacent cells do not interfere with each other.</li>
<li>Wire junctions are special components and are exceptions to rule 2 and 3. A wire junction always have three interfaces (1 in &amp; 2 outs, or 2 ins &amp; 1 out). Multiple junctions can overlap and they can overlap with an interface of some component.</li>
<li>There are times when we want to fix the location of some components in the input. These components are usually just placeholders that mark the position of IO. (We don't want to produce a circuit with an unreachable input/output in the center of everything else, right?)</li>
</ol>
<h2 id="the-objective">The Objective</h2>
<ol type="1">
<li>The circuit represented by the output must have the same functionality as described by the input circuit diagram.</li>
<li>The delay of the circuit should be minimized.</li>
</ol>
<h2 id="example-the-and-gate">Example: the AND gate</h2>
<p>Let's see how we design a simple AND gate.</p>
<p>Suppose the only primitive components we have are NOT gate (torch), wire junction, and IO placeholder. The circuit diagram of AND gate is:</p>
<p><img src="/2020/08/28/Minecraft%20ILP/ANDCD.svg" class=""></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/08/20/NOI%202020/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/20/NOI%202020/" class="post-title-link" itemprop="url">蒟蒻的NOI 2020退役记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-08-20 16:23:58 / 修改时间：16:18:17" itemprop="dateCreated datePublished" datetime="2020-08-20T16:23:58+08:00">2020-08-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="day--1">Day -1</h1>
<p>在中午太阳晒得最狠的时候到了学校。宿舍爬楼累死人，也不知道为啥学校楼要建那么高。幸好宿舍里的空调给力，好评。</p>
<p>宿舍的环境还行。个人觉得比当年WC2018的要好。</p>
<p>信号出奇地差，必须在直接靠窗的地方才有4G，不然连2G也别想收到，听宿管和小卖部阿姨说当初就是设计成这个样子的。差评。</p>
<p>插座很多好评。</p>
<p>但是还是没有桌子，无论用什么姿势看电脑都贼难受。同寝室的jtl带了一个床上架的桌子，看了直呼内行。床板贼硬，差评。</p>
<p>伙食还可以，豆浆我觉得挺好喝的，就是湖南菜多多少少带点辣个人不是很能接受，而且菜很细碎的样子。</p>
<p>睡前随随便便背了点笔试题。</p>
<h1 id="day-0">Day 0</h1>
<p>早上迷迷糊糊地去参加了开幕式。听到dzd说有剩饭扣1分大惊。其他就没啥印象了=_=。</p>
<p>结束后拱火mr押题，mr说看到才艺表演一个跳舞的转来转去暗示会考平衡树，一本正经胡说八道.jpg。</p>
<p>感觉周围大佬都贼多，互相之间也都认识，我一个蒟蒻在当中不知所措。自己看来对于在竞赛圈内的信息闭塞的可以。</p>
<p>中午又背了一会笔试题，然后下午就去试机了。笔试没有想象中的难，但是确实是有超纲的，纠结了很久。幸好最后还是满分飘过了。唯一值得吐槽的或许是CCF十年不变的远古测评系统。</p>
<p>随后在试机场上敲了一波LCT和FFT。看到jtl在写MTT有想敲三模数的冲动但是最后的合并调了好一会才勉强调出来，于是就很慌。</p>
<p>晚上寝室里大家都在欢快地打板子。对面两个人都在打带花树，然后惊奇地发现带花树的代码似乎也没有想象中那么长。三个人讨论了一下觉得似乎有概率考分块的样子，但是笑一笑也就过去了。我自己把各种字符串的算法全部过了一遍。</p>
<h1 id="day-1">Day 1</h1>
<p>看到T1愣了好一会，愣是没有第一时间看出DP。不知道为什么当时满脑子都是Tarjan和缩点然后沿着这个方向陷入了死胡同。于是先敲了一个DFS，觉得自己要完蛋。</p>
<p>看了T2又愣了一会，先敲了个暴力，然后觉得<span class="math inline">\(m\)</span>比较小的情况可以动态维护链并+容斥解决。先放着。</p>
<p>看到T3深切地感受到这或许是个数据结构毒瘤？先敲了一个二维树状数组的暴力。当时脑子大概是坏掉了不是枚举矩形直接算而是枚举点算贡献。总之暴力复杂度似乎<span class="math inline">\(\mathcal O(nm\log^2 n)\)</span>非常差。然后认真思考了一下部分分，发现可以莫队。于是基于二维树状数组写了一个<span class="math inline">\(\mathcal O\left(n\sqrt m \log^2 n\right)\)</span>的算法。然后觉得<span class="math inline">\(\mathcal O(\log ^2n)\)</span>的二维数点不妥，改成了<span class="math inline">\(\mathcal O(\log n)\)</span>的可持久化线段树，于是暴力和莫队的复杂度都少了一个<span class="math inline">\(\log\)</span>。再一看发现莫队我可以用树状数组干嘛要二维数点，于是莫队的常数又降下来一点。瞄了一眼后面觉得应该可以用<span class="math inline">\(\mathcal O(n^{7/4})\)</span>的四维莫队，可惜当初没认真学高维莫队不知道块大小咋算了，于是作罢。最后敲了一个莫队和暴力的对拍放着。</p>
<p>回到T2开始敲树剖和容斥，写了一个<span class="math inline">\(\mathcal O\left(m2^m\log^2n\right)\)</span>的算法。和暴力结合在一起觉得至少能拿<span class="math inline">\(32\)</span>分，常数小一点也可以冲冲<span class="math inline">\(40\)</span>样子。</p>
<p>然后回到T1，突然发现这不就一个裸的DP吗，直骂自己前面傻逼。于是花5分钟敲完朴素DP，然后再花10分钟敲完环的部分分。</p>
<p>然后发现边权至多为<span class="math inline">\(5\)</span>，意识到正解显然是用max-plus algebra下的矩阵快速幂进行优化，于是开始敲。此时离考试结束还有60分钟，心中贼慌。等到敲完离考试结束还有30分钟，心态爆炸，然后死活调不出来。只能把这个正解例程写在程序里作为最后之选。离交卷还有5分钟的时候不改了。检查其他两题的程序无误后就开始坐着怀疑自己前三个小时脑子到底在想什么……</p>
<p>出考场觉得自己已经成为了时代的眼泪（笑）。</p>
<p>下午三点去查分。听jtl说这次CCF准时出分没有咕简直是奇迹。结果就是<span class="math inline">\(50+32+40=122\)</span>。和预想的完全一致。这个时候就很后悔。如果当初早点看出矩阵快速幂把T1的正解调出来就好了。这个分觉得铁牌已经在向我招手。</p>
<p>晚上讲题。T1的确是快速幂正解。T2的正解是线段树合并维护树形DP这个之前也在寝室里有了大概的想法，但是一看这个DP的状态设计果然神仙。出题人怒斥了我们打<span class="math inline">\(32\)</span>分树剖暴力的，说是什么数据结构学傻了……然后说写个虚树不就<span class="math inline">\(40\)</span>了吗。我下面听着就很无语：我也想打虚树，但是我不会啊…… T3的出题人原来就是各种OJ上人们一直吐槽的lxl。这个题目的内部名称似乎叫“第十三分块”？正解似乎是先建一个树套树然后再分治再分块……讲到一半就lost了，内心大骂出题人毒瘤。</p>
<p>回寝室后所有人都是颓废的状态，gyc在打Splay的板子。剩下我们两个人开始摸鱼。</p>
<h1 id="day-2">Day 2</h1>
<p>T1一看给人一种网络流的既视感，然后发现图建不出来。退而求其次试图写出线性规划进行代数化建图，发现线性规划必须使用Big M的办法才能建出来，而且直观一看integrity gap大的离谱是不可能建图的。因为是求可行解也不知道目标函数咋写，所以也不能从对偶下手，只能作罢。敲了一个非常粗暴的DFS暴力枚举每道菜用哪两个原材料分别用多少，发现这个DFS在最坏情况下跑得巨慢无比——难不成我暴力骗分都不成？</p>
<p>这个时候有了一个乱搞的intuition，就是枚举原料的排列然后按照排列来确定所用的原料。然后发现过不了样例，于是作罢。</p>
<p>之后稍微改进了一点暴力，只枚举每道菜用哪两个原材料，最后时候用多少最后用网络流来判。这下终于拿到了<span class="math inline">\(15\)</span>分的暴力。顺便基于这个敲了一个随机化，但是似乎表现也不佳的样子。</p>
<p>T2题面长度属实劝退。读完题面之后觉得似乎不是很可做。看了样例之后有了一点暴力的想法，写了一个复杂度为<span class="math inline">\(\mathcal O\left(2^{2^{h_{\text{max}}-1}}\right)\)</span>的算法。简单来说就是把输入的树补成最大树高然后枚举能否扩张成最大树高下的所有可能的二叉树形态。觉得除了<span class="math inline">\(12\)</span>分纯暴力还可以拿<span class="math inline">\(h_{\text{max}}=4\)</span>的分？之后就不会了。</p>
<p>T3一看给我整懵了。可真就暴力不会写呗。直觉上似乎可以写Dijkstra然后在转移的时候排除掉当前路径下的割边。但是很快意识到Dijkstra的本质是DP而这个转移方案是有后效性的。事实上也是如此，样例都没有过。然后试验性地写了一个不可行的判定方法：求出最短路，如果把最短路去掉之后全图不连通，则不可行——也不知道这样对不对。</p>
<p>5个小时就在三个题目的来回懵逼当中度过。</p>
<p>这次CCF出分直接咕了将近两个小时。我们很明智地从一开始就待在寝室里，那些下去等分的就苦逼了。分数出来是<span class="math inline">\(15+12+5=32\)</span>、也差不多是我预想的这个水平，T2树高为<span class="math inline">\(4\)</span>的点我还是超时了，大概还是没有判同构去重的原因？</p>
<p>下午去听讲题。T1正解的思路源于<span class="math inline">\(m=n-1\)</span>的思考，其他的情况都是向<span class="math inline">\(m=n-1\)</span>情况的规约，感觉是非常巧妙的。T2的最优算法居然是线性的？有点听蒙了。听到T3讲解的时候才意识到T3当中的图叫做弦图，而正解源于对于弦图性质的思考，最后用过两次类Dijkstra来解决，感觉是非常非常神奇，不明觉厉，自愧不如。</p>
<p>讲的时候就出榜了，一看果然Cu，心情复杂，但是一开始也没有期望，所以也没有太沮丧。感觉心态真正崩盘的大概是jtl，人家Cu第一……差一分就Ag了。但是看榜还是有<span class="math inline">\(500\)</span>分以上的，觉得这些人真的很厉害。我或许不比他们笨，但是他们确实历练的比我这种多多了。我这种常年边缘划水的OIer果然不能和这些人比。</p>
<h1 id="day-3">Day 3</h1>
<p>看着手中的铜牌，意识到自己划水的OI之路至少到此为止暂时地画上了句号，颇有些不真实感。</p>
<p>我一直在想，如果D1T1的正解我调出来了，我就是Ag了，会不会好一点呢？但是这终究也只是一个幻想而已罢了。一是比赛不能重来，二是我似乎也不知道缓存矩阵乘方的套路所以真写快速幂有可能复杂度还是会炸的样子。</p>
<p>一如既往，自己复习的算法完美地和考试算法错开了。没有LCT，没有FFT，没有字符串。我深切意识到OI果然还是靠平时积累的，这种比赛临时抱佛脚很大概率是不靠谱的。</p>
<p>还是要谢谢NOI最后给了我一个意识到自己有多菜的机会。还有那么多我没有学的啊~</p>
<p>大概在没有竞赛压力之后我还是会对这些算法认真地研究一番的吧。觉得自己的心态是一个很奇妙的东西。在被父母逼着学竞赛的时候总觉得这些算法很烦，但是意识到自己远离竞赛之后，反而又觉得它们有趣起来了。</p>
<p>网上看过很多这样的游记，一般到最后作者不是Au就是进队了，这种好事终究不会发生在我身上。</p>
<p>唉。这就退役了。</p>
<p>写于Day 3从长沙回上海的火车上。自己的思路一如既往地混乱。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/08/14/TreapMultiset/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/14/TreapMultiset/" class="post-title-link" itemprop="url">Reinventing the Wheel: A Drop-in STL Multiset Alternative Using Treap</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-14 15:20:55" itemprop="dateCreated datePublished" datetime="2020-08-14T15:20:55+08:00">2020-08-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-16 11:30:48" itemprop="dateModified" datetime="2021-03-16T11:30:48+08:00">2021-03-16</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>It turns out that writing a STL container from scratch is mostly a tedious physical labor.</p>
</blockquote>
<p>STL is created to save C++ programmers the time of reinventing wheels. Unfortunately, many STL data structures, most notably self-balancing BSTs (aka. <code>std::(multi)set</code>), are not extendable and are by itself too limited to be used in the context of competitive programming, forcing us to write our own BSTs again and again in competitions.</p>
<p>There comes the fact I find really interesting: A quick and dirty self-balancing BST implementation written during a competition is only about 50-60 lines long, while the STL implementation of <code>std::set</code> and <code>std::multiset</code> is usually more than a thousand-lines long in total.</p>
<p>It does make me wonder: what makes this huge difference? And, will the code of our BST bloat as well if we write it the STL way -- with generics, iterators, and all the necessary bits and pieces as specified in the reference?</p>
<p>To answer my question, I have here tried creating my implementation of multiset using treap as the underlying data structure. The result, <code>treap_multiset</code>, is almost a drop-in replacement to <code>std::multiset</code>. The few places where it does not conform to the C++ standard are:</p>
<ol type="1">
<li>It is currently not allocator-aware, so all allocator-related features are not implemented.</li>
<li><code>emplace</code> and <code>emplace_hint</code> are not implemented.</li>
<li>All operations that have logarithmic time complexity in <code>std::multiset</code> still have logarithmic time complexity here, but only in the average sense (because treap is a randomized data structure), and could have linear worst-case time complexity (though very, very, very unlikely).</li>
<li><code>void erase(iterator)</code> takes amortized logarithmic time instead of constant time.</li>
<li>A few uncommonly-used member types are missing.</li>
</ol>
<p><code>treap_multiset</code> also supports two new operations that are not supported in the original <code>std::multiset</code>:</p>
<ol type="1">
<li><pre class="line-numbers"><code class="language-cpp">   size_type rank(iterator it) const;
   size_type rank(const_iterator it) const;</code></pre>
<p>Both take average logarithmic time and return the rank / position of the iterator.</p></li>
<li><pre class="line-numbers"><code class="language-cpp">   iterator at(size_type index);
   const iterator at(size_type index) const;</code></pre>
<p>Both take average logarithmic time and return the iterator at the specified index/position.</p></li>
</ol>
<p>The code is shown below:</p>
<pre class="line-numbers"><code class="language-cpp">#include &lt;stdexcept&gt;
#include &lt;random&gt;
#include &lt;algorithm&gt;

static std::random_device random_device;
static std::mt19937_64 random_engine(random_device());

template &lt;typename T&gt;
struct treap_node &#123;
    using rand_weight_type = decltype(random_engine)::result_type;
    using size_type = std::size_t;

    treap_node *left, *right, *parent;
    rand_weight_type weight;
    size_type size;
    T value;

    treap_node(const T &amp;value): left(nullptr), right(nullptr), parent(nullptr),
        weight(random_engine()), size(1), value(value) &#123;&#125;

    treap_node(treap_node *left, treap_node *right, treap_node *parent, 
        rand_weight_type weight, size_type size, const T &amp;value): 
        left(left), right(right), parent(parent), weight(weight),
        size(size), value(value) &#123;&#125;

    void update_size() &#123;
        size = 1 + (left ? left-&gt;size : 0) + (right ? right-&gt;size : 0);
    &#125;
&#125;;

#define IMPL_ITERATOR_MOVE_NEXT do &#123; \
    if (!node) break; \
    if (node-&gt;right) &#123; \
        node = node-&gt;right; \
        while (node &amp;&amp; node-&gt;left) node = node-&gt;left; \
    &#125; else &#123; \
        bool from_right = true; \
        while (from_right) &#123; \
            if (!node-&gt;parent) &#123; node = nullptr; break; &#125; \
            from_right = node-&gt;parent-&gt;right == node; \
            node = node-&gt;parent; \
        &#125; \
    &#125; \
&#125; while (0)

#define IMPL_ITERATOR_MOVE_PREV do &#123; \
    if (!node) break; \
    if (node-&gt;left) &#123; \
        node = node-&gt;left; \
        while (node &amp;&amp; node-&gt;right) node = node-&gt;right; \
    &#125; else &#123; \
        bool from_left = true; \
        while (from_left) &#123; \
            if (!node-&gt;parent) &#123; node = nullptr; break; &#125; \
            from_left = node-&gt;parent-&gt;left == node; \
            node = node-&gt;parent; \
        &#125; \
    &#125; \
&#125; while (0)

#define TREAP_ITERATOR_DECL(name, qualifier, inc, dec) \
template &lt;typename T&gt; struct name &#123; \
    qualifier treap_node&lt;T&gt; *node; bool past_the_end; \
    name(): node(nullptr), past_the_end(true) &#123;&#125; \
    name(qualifier treap_node&lt;T&gt; *node, bool past_the_end) \
        : node(node), past_the_end(past_the_end) &#123;&#125; \
    name(qualifier treap_node&lt;T&gt; *node): node(node), past_the_end(false) &#123;&#125; \
    qualifier T &amp;operator *() qualifier &#123; \
        if (!node || past_the_end) \
            throw std::runtime_error(&quot;dereferencing null/past-end iterator&quot;); \
        return node-&gt;value; \
    &#125; \
    bool operator ==(const name&lt;T&gt; &amp;b) const &#123; \
        return node == b.node &amp;&amp; past_the_end == b.past_the_end; \
    &#125; \
    bool operator !=(const name&lt;T&gt; &amp;b) const &#123; \
        return node != b.node || past_the_end != b.past_the_end; \
    &#125; \
    name&lt;T&gt; &amp;operator ++() &#123; \
        qualifier treap_node&lt;T&gt; *backup = node; \
        IMPL_ITERATOR_MOVE_##inc; \
        if (!node) past_the_end = true, node = backup; \
        return *this; \
    &#125; \
    name&lt;T&gt; operator ++(int) &#123; \
        name&lt;T&gt; ret(*this); \
        return ++(*this), ret; \
    &#125; \
    name&lt;T&gt; &amp;operator --() &#123; \
        if (past_the_end) past_the_end = false; \
        else IMPL_ITERATOR_MOVE_##dec; \
        if (!node) \
            throw std::runtime_error(&quot;can&#39;t decrement at the beginning&quot;); \
        return *this; \
    &#125; \
    name&lt;T&gt; operator --(int) &#123; \
        name&lt;T&gt; ret(*this); \
        return --(*this), ret; \
    &#125; \
&#125;

TREAP_ITERATOR_DECL(treap_iterator, /* NO QUALIFIER */, NEXT, PREV);
TREAP_ITERATOR_DECL(reverse_treap_iterator, /* NO QUALIFIER */, PREV, NEXT);
TREAP_ITERATOR_DECL(const_treap_iterator, const, NEXT, PREV);
TREAP_ITERATOR_DECL(const_reverse_treap_iterator, const, PREV, NEXT);

template &lt;typename T, typename Compare = std::less&lt;T&gt;&gt;
class treap_multiset &#123;
public:
    using key_type = T;
    using value_type = T;
    using size_type = typename treap_node&lt;T&gt;::size_type;
    using key_compare = Compare;
    using value_compare = Compare;
    using node_type = treap_node&lt;T&gt;*;
    using iterator = treap_iterator&lt;T&gt;;
    using reverse_iterator = reverse_treap_iterator&lt;T&gt;;
    using const_iterator = const_treap_iterator&lt;T&gt;;
    using const_reverse_iterator = const_reverse_treap_iterator&lt;T&gt;;

    treap_multiset(): root(nullptr) &#123;&#125;

    treap_multiset(const treap_multiset &amp;b): root(deep_copy(b.root)), comp(b.comp) &#123;&#125;

    treap_multiset(treap_multiset &amp;&amp;b): root(b.root), comp(b.comp) &#123;&#125;

    ~treap_multiset() &#123; if (root) recursive_free(root); &#125;

    bool empty() const &#123; return root == nullptr; &#125;

    size_type size() const &#123; return root ? root-&gt;size : 0; &#125;

    size_type max_size() const &#123; return 0x7FFFFFFF; &#125;

    key_compare key_comp() const &#123; return comp; &#125;

    value_compare value_comp() const &#123; return comp; &#125;

    iterator begin() 
        &#123; return iterator(leftmost(root)); &#125;

    const_iterator begin() const 
        &#123; return const_iterator(leftmost(root)); &#125;

    const_iterator cbegin() const 
        &#123; return const_iterator(leftmost(root)); &#125;

    iterator end() 
        &#123; return iterator(rightmost(root), true); &#125;

    const_iterator end() const 
        &#123; return const_iterator(rightmost(root), true); &#125;

    const_iterator cend() const 
        &#123; return const_iterator(rightmost(root), true); &#125;

    reverse_iterator rbegin() 
        &#123; return reverse_iterator(rightmost(root)); &#125;

    const_reverse_iterator rbegin() const 
        &#123; return const_reverse_iterator(rightmost(root)); &#125;

    const_reverse_iterator crbegin() const 
        &#123; return const_reverse_iterator(rightmost(root)); &#125;

    reverse_iterator rend() 
        &#123; return reverse_iterator(leftmost(root), true); &#125;

    const_reverse_iterator rend() const 
        &#123; return const_reverse_iterator(leftmost(root), true); &#125;

    const_reverse_iterator crend() const 
        &#123; return const_reverse_iterator(leftmost(root), true); &#125;

    iterator insert(const value_type &amp;value) &#123;
        node_type left, right;
        split_le(root, value, left, nullptr, right, nullptr);
        node_type temp = new treap_node&lt;T&gt;(value);
        root = join(join(left, temp), right);
        return iterator(temp);
    &#125;

    iterator insert(iterator position, const value_type &amp;value) 
        &#123; return insert(value); &#125;

    template &lt;typename II&gt;
    void insert(II first, II last) &#123; 
        for (; first != last; first++) 
            insert(*first); 
    &#125;

    size_type rank(iterator it) const &#123; return rank(it.node); &#125;
    
    size_type rank(const_iterator it) const &#123; return rank(it.node); &#125;

    iterator at(size_type index) &#123;
        if (index &lt; 0 || index &gt; size()) return end();
        return iterator(at_internal(index));
    &#125;

    const_iterator at(size_type index) const &#123;
        if (index &lt; 0 || index &gt; size()) return end();
        return const_iterator(at_internal(index));
    &#125;

    void erase(iterator pos) &#123;
        assert_valid(pos);
        node_type a, b, c;
        size_type rank = this-&gt;rank(pos.node);
        split_size(root, rank, a, nullptr, c, nullptr);
        split_size(a, rank - 1, a, nullptr, b, nullptr);
        root = join(a, c);
        // assert(b == pos.node);
        delete b;
    &#125;

    size_type erase(const value_type &amp;key) &#123;
        node_type a, b, c;
        split_le(root, key, a, nullptr, c, nullptr);
        split_re(a, key, a, nullptr, b, nullptr);
        root = join(a, c);
        if (b) &#123;
            size_type ret = b-&gt;size;
            recursive_free(b);
            return ret;
        &#125;
        return 0;
    &#125;

    void erase(iterator first, iterator last) &#123;
        size_type rank_first = rank(first);
        size_type rank_last = rank(last);
        node_type a, b, c;
        split_size(root, rank_last, a, nullptr, c, nullptr);
        split_size(a, rank_last - 1, a, nullptr, b, nullptr);
        root = join(a, c);
        if (b) recursive_free(b);
    &#125;

    void clear() &#123; if (root) recursive_free(root); &#125;

    void swap(treap_multiset &amp;b) &#123; swap(root, b.root); &#125;

    iterator find(const value_type &amp;key) &#123;
        node_type ret = find_internal(key);
        return ret ? iterator(ret) : end();
    &#125;

    const_iterator find(const value_type &amp;key) const &#123;
        node_type ret = const_cast&lt;treap_multiset&lt;T&gt;*&gt;(this)-&gt;find_internal(key);
        return ret ? const_iterator(ret) : end();
    &#125;

    size_type count(const value_type &amp;key) const &#123;
        node_type a, b, c;
        treap_multiset&lt;T&gt; *thiz = const_cast&lt;treap_multiset&lt;T&gt;*&gt;(this);
        thiz-&gt;split_le(root, key, a, nullptr, c, nullptr);
        thiz-&gt;split_re(root, key, a, nullptr, b, nullptr);
        size_type ret = b ? b-&gt;size : 0;
        thiz-&gt;root = thiz-&gt;join(thiz-&gt;join(a, b), c);
        return ret;
    &#125;

    iterator lower_bound(const value_type &amp;key) &#123;
        node_type ret = lower_bound_internal(key);
        return ret ? iterator(ret) : end();
    &#125;

    const_iterator lower_bound(const value_type &amp;key) const &#123;
        node_type ret = const_cast&lt;treap_multiset&lt;T&gt;*&gt;(this)-&gt;lower_bound_internal(key);
        return ret ? const_iterator(ret) : end();
    &#125;

    iterator upper_bound(const value_type &amp;key) &#123;
        node_type ret = upper_bound_internal(key);
        return ret ? iterator(ret) : end();
    &#125;

    const_iterator upper_bound(const value_type &amp;key) const &#123;
        node_type ret = const_cast&lt;treap_multiset&lt;T&gt;*&gt;(this)-&gt;upper_bound_internal(key);
        return ret ? const_iterator(ret) : end();
    &#125;

    std::pair&lt;iterator, iterator&gt; equal_range(const value_type &amp;key) &#123;
        return std::make_pair(lower_bound(key), upper_bound(key));
    &#125;

    std::pair&lt;const_iterator, const_iterator&gt; equal_range(const value_type &amp;key) const &#123;
        return std::make_pair(lower_bound(key), upper_bound(key));
    &#125;

    size_type depth(node_type node) &#123;
        if (!node) return 0;
        return 1 + std::max(depth(node-&gt;left), depth(node-&gt;right));
    &#125;
    
private:
    Compare comp;
    node_type root;

    void recursive_free(node_type root) &#123;
        if (root-&gt;left) 
            recursive_free(root-&gt;left);       
        if (root-&gt;right) 
            recursive_free(root-&gt;right);
        delete root;
    &#125;

    void split_le(node_type root, const value_type &amp;key, 
        node_type &amp;left, node_type left_parent,
        node_type &amp;right, node_type right_parent) &#123;
        if (!root) &#123; left = right = nullptr; return; &#125;
        if (!comp(key, root-&gt;value)) &#123;
            left = root; root-&gt;parent = left_parent;
            split_le(root-&gt;right, key, root-&gt;right, root, right, right_parent);
        &#125; else &#123;
            right = root; root-&gt;parent = right_parent;
            split_le(root-&gt;left, key, left, left_parent, root-&gt;left, root);
        &#125;
        root-&gt;update_size();
    &#125;

    void split_re(node_type root, const value_type &amp;key, 
        node_type &amp;left, node_type left_parent,
        node_type &amp;right, node_type right_parent) &#123;
        if (!root) &#123; left = right = nullptr; return; &#125;
        if (comp(root-&gt;value, key)) &#123;
            left = root; root-&gt;parent = left_parent;
            split_re(root-&gt;right, key, root-&gt;right, root, right, right_parent);
        &#125; else &#123;
            right = root; root-&gt;parent = right_parent;
            split_re(root-&gt;left, key, left, left_parent, root-&gt;left, root);
        &#125;
        root-&gt;update_size();
    &#125;

    void split_size(node_type root, size_type size, 
        node_type &amp;left, node_type left_parent,
        node_type &amp;right, node_type right_parent) &#123;
        if (!root) &#123; left = right = nullptr; return; &#125;
        size_type left_size = 1 + (root-&gt;left ? root-&gt;left-&gt;size : 0);
        if (left_size &lt;= size) &#123;
            left = root; root-&gt;parent = left_parent;
            split_size(root-&gt;right, 
                size - left_size, root-&gt;right, root, right, right_parent);
        &#125; else &#123;
            right = root; root-&gt;parent = right_parent;
            split_size(root-&gt;left, size, left, left_parent, root-&gt;left, root);
        &#125;
        root-&gt;update_size();
    &#125;

    node_type join(node_type left, node_type right) &#123;
        if (!left) return right;
        if (!right) return left;
        if (left-&gt;weight &lt;= right-&gt;weight) &#123;
            node_type temp = join(left-&gt;right, right);
            if (temp) temp-&gt;parent = left;
            left-&gt;right = temp;
            left-&gt;update_size();
            return left;
        &#125; else &#123;
            node_type temp = join(left, right-&gt;left);
            if (temp) temp-&gt;parent = right;
            right-&gt;left = temp;
            right-&gt;update_size();
            return right;
        &#125;
    &#125;

    node_type leftmost(node_type x) const &#123;
        if (!x) return nullptr;
        node_type ret = x; while (ret-&gt;left) ret = ret-&gt;left;
        return ret;
    &#125;

    node_type rightmost(node_type x) const &#123;
        if (!x) return nullptr;
        node_type ret = x; while (ret-&gt;right) ret = ret-&gt;right;
        return ret;
    &#125;

    node_type find_internal(const value_type &amp;key) &#123;
        node_type a, b, c;
        split_le(root, key, a, nullptr, c, nullptr);
        split_re(root, key, a, nullptr, b, nullptr);
        root = join(join(a, b), c);
        return b;
    &#125;

    node_type lower_bound_internal(const value_type &amp;key) &#123;
        node_type left, right;
        split_re(root, key, left, nullptr, right, nullptr);
        node_type ret = leftmost(right);
        root = join(left, right);
        return ret;
    &#125;

    node_type upper_bound_internal(const value_type &amp;key) &#123;
        node_type left, right;
        split_le(root, key, left, nullptr, right, nullptr);
        node_type ret = leftmost(right);
        root = join(left, right);
        return ret;
    &#125;

    node_type at_internal(size_type index) const &#123;
        node_type temp = root;
        while (true) &#123;
            size_type left_size = 1 + (temp-&gt;left ? temp-&gt;left-&gt;size : 0);
            if (index == left_size) return temp;
            else if (index &lt; left_size) temp = temp-&gt;left;
            else temp = temp-&gt;right, index -= left_size;
        &#125;
        return nullptr; // UNREACHABLE
    &#125;

    size_type rank(node_type node) &#123;
        bool from_right = true;
        size_type ret = 0;
        while (node) &#123;
            if (from_right)
                ret += 1 + (node-&gt;left ? node-&gt;left-&gt;size : 0);
            if (node-&gt;parent)
                from_right = node == node-&gt;parent-&gt;right;
            node = node-&gt;parent;
        &#125;
        return ret;
    &#125;

    node_type deep_copy(node_type node) &#123;
        if (!node) return nullptr;
        node_type left = deep_copy(node-&gt;left);
        node_type right = deep_copy(node-&gt;right);
        node_type ret = new treap_node&lt;T&gt;(
            left, right, nullptr,
            node-&gt;weight, node-&gt;size, node-&gt;value
        );
        if (left) left-&gt;parent = ret;
        if (right) right-&gt;parent = ret;
        return ret;
    &#125;

    void assert_valid(iterator it) &#123;
        if (!it.node || it.past_the_end)
            throw std::runtime_error(&quot;invalid iterator&quot;);
        node_type temp = it.node;
        while (temp-&gt;parent) temp = temp-&gt;parent;
        if (temp != root)
            throw std::runtime_error(&quot;invalid iterator&quot;);
    &#125;
&#125;;</code></pre>
<p>(The code above hasn't been thoroughly tested yet and could still contain bugs).</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/08/12/AlipayParanoia/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/12/AlipayParanoia/" class="post-title-link" itemprop="url">论支付宝对Xposed框架的被害妄想症</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-08-12 13:29:54 / 修改时间：22:30:26" itemprop="dateCreated datePublished" datetime="2020-08-12T13:29:54+08:00">2020-08-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近真的是被支付宝的操作恶心到了。</p>
<p>跑到医院门口，要出示健康码了。打开支付宝选择随申码，登录授权时要刷脸，然后告诉我手机不支持刷脸？场面一度非常尴尬。</p>
<p>“您的手机不支持刷脸”。为什么不支持？缺少硬件？缺少驱动？含糊其辞，搞得我一开始真以为XDA上下下来的ROM不贴合我国国情少预装了一套刷脸的库。</p>
<p>查了好久才意识到原来是支付宝检测到Magisk和Xposed的缘故。</p>
<p>好啊，这可以理解嘛，人脸验证和支付都是安全性极高的，关键步骤被hook是会出大事的。</p>
<p>于是停用了Riru和EdXposed的模块。但是还是不支持。</p>
<p>三清之后重装，又支持了。</p>
<p>然后我遵循网友的经验，安装Magisk，然后开启随机包名重装和Magisk Hide。没有出问题。</p>
<p>然后再安装EdXposed，即时模块打开，黑名单打开把支付宝加进去，然后开启强制SafetyNet检验。</p>
<p>然后支付宝安全检查之后就又告诉我不支持了。</p>
<p>唉，我啥模块都没装呢，拉黑之后就算装了也hook不到你支付宝紧张啥？</p>
<p>网上逛了一圈，有不少遇到这个问题的，大家都没有好的解决办法，有的说双开，有的说双手机，有的说回退到play上的19年9月份的75版本。最后一条亲测确实有效，但是一直停留在老版本也不是个事啊。</p>
<p>也看了CSDN上一些关于阿里系应用反hook机制的研究，大概是18年左右写的。当时的机制是通过反射检测有没有<code>XposedHelper</code>这个类，有这个类之后检测缓存里面有没有alipay等关键词。这个机制非常巧妙，而且我觉得强度也足够了。</p>
<p>但是现在似乎已经不是这个机制了。通过有些解决方案当中关闭读取应用列表权限这一项我隐约可以猜出这支付宝大概是直接读取手机安装的所有应用，然后发现带Xposed就是不安全？</p>
<p>这也太过了吧，我个人甚至觉得有些流氓之嫌。</p>
<blockquote>
<p>看到Xposed，立刻想到自己被hook，立刻想到这hook一定会让用户亏钱，立刻想到自己要赔钱，然后就紧张的要命。支付宝的想像惟在这一层能够如此跃进。<del>——鲁迅</del></p>
</blockquote>
<p>这个逻辑链有两处是有待商榷的。</p>
<p>为什么所有Xposed插件一定要来hook你？我手机一般就装两模块，一个修改界面的locale让不够本地化的地方本地化，一个修改图标让系统更美观。这两个模块都不用hook进支付宝，而且还都是我自己一行一行写出来的。我脑子坏掉了去搞支付宝自己坑自己？</p>
<p>为什么觉得因为用户因为hook造成的损失一定要支付宝负责？还真就社会责任心爆棚呗。服务条款里面加一行“由于用户使用第三方软件自行修改系统框架进而影响本应用的正常运行，导致财产损失的，责任自负，支付宝概不负责”有那么困难吗？Xposed必须是用户自己装的，模块一定是用户自己下载并且启用的，考虑到使用Xposed基本上都是安卓的发烧友，翻车了自己负责这条道理大家都认，也没有人来说是支付宝的不对。</p>
<p>退一步，如果我真的要搞尽一切代价搞支付宝，支付宝检测有没有被hook的代码可不可能被hook呢？我能不能不用Xposed而用一些更底层的框架例如Riru来搞呢？支付宝作为一个正常权限的应用软件，面对因用户主动选择破坏承载其运行的，本来安全的安卓系统框架，而导致的可能来自底层的，高权限的修改与破坏一定是无能为力的。支付宝完全没有必要对一个受害者主动引发，且本质上自身无能为力的损失负责。</p>
<p>进一步，今天支付宝可以读取应用看到Xposed就不让刷脸，明天如果腾讯和阿里干架，支付宝也可以读取应用列表看到有微信就不让用（3Q大战既视感）。现在看来“读取应用列表”不是安卓原生自带的权限实在是一个设计漏洞。支付宝这个行为也显然开了一个不好的先例。</p>
<p>最后，我其实一直不理解的一点是，是什么让支付宝觉得原来合理的Xposed框架检测逻辑有问题，进而换上了这套长臂管辖似的一刀切呢？</p>
<p>在不知道更多信息以前，我只能认为是支付宝自身在有些情境下不必要的责任感以及过度的被害妄想症在作祟。</p>
<p>在此，向设计这个安全检查模块的所有阿里员工以及十八代亲属致以最诚挚的问候。</p>
<p>最后的最后，讲一讲在保留Magisk和Xposed功能的情况下，可能的解决办法吧。</p>
<ol type="1">
<li>停留在老版本的支付宝。</li>
<li>让EdXposed也有和Magisk类似的随机包名重装功能。</li>
<li>让支付宝找一个更合理的办法检验自己有没有被hook。</li>
<li>让支付宝目前这套方案失效，比如说禁止支付宝调用<code>getInstalledPackages</code>来获取已经安装的应用。这个我知道在一些国产的系统里面是有类似功能的。但是目前类原生的系统还没有。虽可以通过Xposed模块来实现，但是在这个背景下毫无意义。唯一的一个方案是把系统的源码clone一份下来，然后直接改代码。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/08/07/FWHT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/07/FWHT/" class="post-title-link" itemprop="url">Fast Walsh-Hadamard Transform in Competitive Programming</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-08-07 13:26:34 / 修改时间：16:56:27" itemprop="dateCreated datePublished" datetime="2020-08-07T13:26:34+08:00">2020-08-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>This should be the very first English post I write on my blog and I expect there to be some minor errors. This is a popular technique in the Chinese competitive programming community but there doesn't seem to be a lot of documentation about its application in the English CP community. The posts I found on Codeforces doesn't seem to be very clear to me...</p>
<h1 id="prerequisites">Prerequisites</h1>
<ul>
<li>A decent proficiency in competitive programming.</li>
<li>A basic understanding of the Cooley-Tukey FFT and its application in competitive programming.</li>
<li>A decent understanding of bitwise operations.</li>
</ul>
<h1 id="why-do-we-need-fwht">Why do we need FWHT?</h1>
<p>Recall what we would do if we are to quickly calculate the following convolution of two sequences <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, each of length <span class="math inline">\(n\)</span>: <span class="math display">\[
\{a\circledast b\}_i=\sum_{j+k=i}a_{j}b_k \Bigg/ \{a\circledast b\}_i=\sum_{j=0}^ia_{j}b_{i-j}
\]</span> We use FFT, which applies the following transformation to the input sequence: <span class="math display">\[
\mathcal{F}\{a\}_i = \sum_{j=0}^n a_j\omega_{n}^{ij}
\]</span> Since the calculation of this transformation (and its inverse) can be done in a divide-and-conquer manner in <span class="math inline">\(\mathcal O(n\log n)\)</span> and the element wise product of the transformation is equivalent to the convolution on the original series, we are able to calculate the convolution in <span class="math inline">\(\mathcal O(n\log n)\)</span>.</p>
<p>Now we try to generalize our findings to a more general case: <span class="math display">\[
\{a\circledast b\}_i=\sum_{j \star k=i}a_jb_k
\]</span> where <span class="math inline">\(\star\)</span> is some binary operation. The convolution we see at the beginning is a special case where <span class="math inline">\(\star = +\)</span>.</p>
<p>FWHT is an algorithm that borrows similar notions from FFT and is able to compute the convolution in <span class="math inline">\(\mathcal O(n \log n)\)</span> time for <span class="math inline">\(\star =\vee,\wedge,\oplus\)</span> (bitwise OR, bitwise AND, and bitwise XOR). Why do the convolutions of these bitwise operations matter? Observe that binary representation is a way of encoding sets and these three operations correspond to set union, set intersection and set symmetric difference respectively, therefore, FWHT can be used to accelerate set-based DPs.</p>
<h1 id="bitwise-or-convolution">Bitwise OR convolution</h1>
<p>Let's start with the convolution with respect to bitwise OR: <span class="math display">\[
\{a\circledast b\}_i = \sum_{j\vee k=i}a_jb_k
\]</span> We start by exploiting an interesting property of bitwise OR: <span class="math display">\[
x \vee z = z,y\vee z = z \Leftrightarrow (x\vee y)\vee z=z
\]</span> or its clearer equivalent in set-based notations: <span class="math display">\[
X\subseteq Z,Y\subseteq Z \Leftrightarrow (X\cup Y)\subseteq Z
\]</span> <strong>Claim:</strong> The following transformation can turn OR convolutions to element-wise multiplications: <span class="math display">\[
\mathcal{FWHT}\{a\}_i=\sum_{j\vee i=i} a_j
\]</span> <strong>Proof:</strong> <span class="math display">\[
\begin{aligned}
\mathcal{FWHT}\{a\}_i\cdot\mathcal{FWHT}\{b\}_i &amp;= \left(\sum_{j\vee i=i}a_j\right) \left(\sum_{k\vee i=i}b_k\right) \\
&amp;= \sum_{j\vee i=i}\sum_{k\vee i=i}a_jb_k \\
&amp;= \sum_{(j\vee k)\vee i=i} a_jb_k \\
&amp;= \sum_{l\vee i = i}\sum_{j \vee k = l} a_jb_k\\
&amp;= \mathcal{FWHT}\{a\circledast b\}_i
\end{aligned}
\]</span> Then how are we able to compute <span class="math inline">\(\mathcal{FWHT}\{a\}\)</span> quickly? A trivial implementation still takes <span class="math inline">\(\mathcal O(n^2)\)</span> time.</p>
<p>Recall what we did in FFT: we divide <span class="math inline">\(a\)</span> into two subsequences based on parity of indices, a.k.a, the last bit of indices. We did this because the root of unity has such amazing property as <span class="math inline">\(\omega_n^k=\omega_{n/2}^{k/2}\)</span>. We could do that here as well, but a limitation of dividing based on the last bit is that the order of elements changes in the process, so an efficient in-place implementation has to do a pre-shuffle to cope with that. Since OR is a bitwise operation, which bit based on which we divide doesn't really matter much. Why not simply <strong>divide based on the first, or the most significant bit</strong>, such that the order of elements is preserved in the process? Dividing based on the highest bit of indices, simply put, is to split <span class="math inline">\(a\)</span> into the first half, <span class="math inline">\(a^0\)</span>, and the second half, <span class="math inline">\(a^1\)</span>, in their natural order.</p>
<p>Here I introduce a notation, <span class="math inline">\(1|a\)</span> or <span class="math inline">\(0|a\)</span>. In the context where the length of the sequence is <span class="math inline">\(n\)</span> (and <span class="math inline">\(n\)</span> is a power of <span class="math inline">\(2\)</span>), <span class="math inline">\(1|a=\frac{n}{2}+a\)</span> where <span class="math inline">\(0\le a&lt;n/2\)</span>, and <span class="math inline">\(0|a\)</span> is just <span class="math inline">\(a\)</span>. In other words, <span class="math inline">\(1|a\)</span> has <span class="math inline">\(1\)</span> as the highest bit and <span class="math inline">\(0|a\)</span> has <span class="math inline">\(0\)</span> as the highest bit.</p>
<p>(Note using this notation, <span class="math inline">\(a^0_i = a_{0|i}\)</span> and <span class="math inline">\(a^1_i = a_{1|i}\)</span>)</p>
<p>To make our writing clearer, denote <span class="math display">\[
\begin{aligned}
\mathcal{FWHT}\{a\} &amp;= A \\
\mathcal{FWHT}\left\{a^0\right\} &amp;= A^0 \\
\mathcal{FWHT}\left\{a^1\right\} &amp;= A^1 \\
\end{aligned}
\]</span> We want to express each element of <span class="math inline">\(A\)</span> as a combination of some element in <span class="math inline">\(A^0\)</span> and <span class="math inline">\(A^1\)</span>.</p>
<p>We first look at the first half of <span class="math inline">\(A\)</span>. Using the notation I defined above, these elements can be expressed as <span class="math inline">\(A_{0|i}\)</span>. <span class="math display">\[
\begin{aligned}
A_{0|i}&amp;=\sum_{j\vee (0|i)=0|i}a_j \\
&amp;= \sum_{(0|j)\vee (0|i)=0|i}a^0_j + \sum_{(1|j)\vee (0|i)=0|i}a^1_j \\
\end{aligned}
\]</span> We know that the highest bit of <span class="math inline">\((1|j)\vee (0|i)\)</span> should always be <span class="math inline">\(1\)</span>, so the condition in the second summation is never satisfied, and we can simply throw the second term away. And <span class="math inline">\((0|j)\vee (0|i)=0|i\)</span> simplifies to <span class="math inline">\(j\vee i =i\)</span>, so we get, by definition of <span class="math inline">\(A^0\)</span>: <span class="math display">\[
A_{0|i} = A^0_i
\]</span> What about the second half, <span class="math inline">\(A_{1|i}\)</span>? <span class="math display">\[
\begin{aligned}
A_{1|i}&amp;=\sum_{j\vee (1|i)=1|i}a_j \\
&amp;= \sum_{(0|j)\vee (1|i)=1|i}a^0_j + \sum_{(1|j)\vee (1|i)=1|i}a^1_j \\
&amp;= A_i^0+A_i^1
\end{aligned}
\]</span> Together we get: <span class="math display">\[
A=\left(A^0, A^0+A^1\right)
\]</span> with the trivial recursion boundary <span class="math inline">\(A_0=a_0\)</span> when <span class="math inline">\(n=0\)</span>.</p>
<p>(here I use the tuple notation to denote concatenation, and <span class="math inline">\(+\)</span> to denote element-wise addition).</p>
<p>This is something we can write an in-place implementation for with ease:</p>
<pre class="line-numbers"><code class="language-cpp">void fwht_or(int n, int *a, int *A) &#123;
    copy(a, a + n, A);
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1)
        for (int l = 0; l &lt; n; l += s)
            for (int i = 0; i &lt; h; i++)
                A[l + h + i] += A[l + i]
&#125;</code></pre>
<p>Its time complexity is obviously <span class="math inline">\(\mathcal O(n\log n)\)</span> with a really small constant factor.</p>
<p>Its reverse transform turns out to be simple as well, suppose we know <span class="math inline">\(A\)</span> and let <span class="math display">\[
A=(A&#39;,A&#39;&#39;)
\]</span> (Assuming <span class="math inline">\(n\)</span> is a power of <span class="math inline">\(2\)</span> and <span class="math inline">\(A&#39;\)</span> and <span class="math inline">\(A&#39;&#39;\)</span> each have length <span class="math inline">\(n/2\)</span>)</p>
<p>Then we can recover <span class="math inline">\(A^0\)</span> and <span class="math inline">\(A^1\)</span>: <span class="math display">\[
\begin{cases}
    A^0=A&#39;\\
    A^1=A&#39;&#39;-A&#39;
\end{cases}
\]</span> Implementation:</p>
<pre class="line-numbers"><code class="language-cpp">void ifwht_or(int n, int *a, int *A) &#123; 
    std::copy(A, A + n, a);
    // If n is guaranteed to be a power of 2 then we don&#39;t need n_ and the min(...) in the inner loop.
    int n_ = 1; while (n_ &lt; n) n_ &lt;&lt;= 1; 
    // n_ = 1 &lt;&lt; (32 - __builtin_clz(n - 1));
    for (int s = n_, h = n_ / 2; h; s &gt;&gt;= 1, h &gt;&gt;= 1)
        for (int l = 0; l &lt; n; l += s)
            for (int i = 0; i &lt; std::min(i, n - l - h); i++)
                a[l + h + i] -= a[l + i]
&#125;</code></pre>
<p>And an amazing thing about this, which I haven't quite figured out why, is that the order of the outermost loop above can be reversed and both functions can be merged into one:</p>
<pre class="line-numbers"><code class="language-cpp">void fwht_or(int n, int *a, int *A, int dir = 1) &#123;
    std::copy(a, a + n, A);
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1)
        for (int l = 0; l &lt; n; l += s)
            for (int i = 0; i &lt; h; i++)
                A[l + h + i] += dir * A[l + i]
&#125;</code></pre>
<p>(Fast bitwise OR / set union convolution is sometimes aliased "Fast Mobius Transform" in Chinese CP community. Both are essentially the same.)</p>
<h1 id="bitwise-and-convolution">Bitwise AND convolution</h1>
<p>The bitwise AND convolution <span class="math display">\[
\{a\circledast b\}_i = \sum_{j\wedge k=i}a_jb_k
\]</span> can be accelerated in a similar way.</p>
<p>(Actually, by de Morgan's Law we can always reduce an AND convolution to an OR convolution)</p>
<p>Note that AND also has this interesting property: <span class="math display">\[
x \wedge z = z,y\wedge z = z \Leftrightarrow (x\wedge y)\wedge z=z
\]</span> or in set notations: <span class="math display">\[
Z\subseteq X,Z\subseteq Y \Leftrightarrow Z\subseteq(X\cap Y)
\]</span> Thus, we can prove in a way similar to what we did in OR convolution that the transform <span class="math display">\[
\mathcal{FWHT}\{a\}_i=\sum_{j\wedge i=i} a_j
\]</span> can turn convolutions to element-wise multiplications.</p>
<p>We still adopt the same divide-and-conquer approach and continue to use the notations <span class="math inline">\(a, a^0,a^1,A,A^0,A^1\)</span>.</p>
<p>Consider the first half of <span class="math inline">\(A\)</span>, which can be expressed as <span class="math inline">\(A_{0|i}\)</span>: <span class="math display">\[
\begin{aligned}
A_{0|i}&amp;=\sum_{j\wedge (0|i)=0|i}a_j \\
&amp;= \sum_{(0|j)\wedge (0|i)=0|i}a^0_j + \sum_{(1|j)\wedge (0|i)=0|i}a^1_j \\
\end{aligned}
\]</span> And by the properties of AND, both <span class="math inline">\((0|j)\wedge (0|i)=0|i\)</span> and <span class="math inline">\((1|j)\wedge (0|i)=0|i\)</span> simplify to <span class="math inline">\(j\wedge i=i\)</span>. So by definition we get <span class="math display">\[
A_{0|i}=A^0_i+A_i^1
\]</span> Then consider the other half of <span class="math inline">\(A\)</span>: <span class="math display">\[
\begin{aligned}
A_{1|i}&amp;=\sum_{j\wedge (1|i)=1|i}a_j \\
&amp;= \sum_{(0|j)\wedge (1|i)=1|i}a^0_j + \sum_{(1|j)\wedge (1|i)=1|i}a^1_j \\
&amp;= A_i^1
\end{aligned}
\]</span> Together we have: <span class="math display">\[
A=\left(A^0+A^1,A^1\right)
\]</span> with the trivial recursion boundary <span class="math inline">\(A_0=a_0\)</span> when <span class="math inline">\(n=0\)</span>.</p>
<p>This gives an efficient implementation very similar to <code>fwht_or</code> above:</p>
<pre class="line-numbers"><code class="language-cpp">void fwht_and(int n, int *a, int *A) &#123;
    std::copy(a, a + n, A);
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1)
        for (int l = 0; l &lt; n; l += s)
            for (int i = 0; i &lt; h; i++)
                A[l + i] += A[l + h + i]
&#125;</code></pre>
<p>The inverse transform is simple as well. Let <span class="math inline">\(A=(A&#39;, A&#39;&#39;)\)</span>, then <span class="math display">\[
\begin{cases}
A^0=A&#39;-A&#39;&#39; \\
A^1=A&#39;&#39;
\end{cases}
\]</span> The code:</p>
<pre class="line-numbers"><code class="language-cpp">void ifwht_and(int n, int *a, int *A) &#123; 
    std::copy(A, A + n, a);
    // If n is guaranteed to be a power of 2 then we don&#39;t need n_ and the min(...) in the inner loop.
    int n_ = 1; while (n_ &lt; n) n_ &lt;&lt;= 1; 
    for (int s = n_, h = n_ / 2; h; s &gt;&gt;= 1, h &gt;&gt;= 1)
        for (int l = 0; l &lt; n; l += s)
            for (int i = 0; i &lt; std::min(i, n - l - h); i++)
                a[l + i] -= a[l + h + i]
&#125;</code></pre>
<p>The order of the outermost loop can be reversed and we can also merge the functions above together.</p>
<h1 id="bitwise-xor-convolution">Bitwise XOR convolution</h1>
<p>The XOR operation does <strong>not</strong> have such nice property as <span class="math display">\[
x\oplus z=z, y\oplus z=z\Leftrightarrow (x\oplus y)\oplus z=z
\]</span> So accelerating the convolution <span class="math display">\[
\{a\circledast b\}_i = \sum_{j\oplus k=i}a_jb_k
\]</span> is not as straightforward as we did above.</p>
<p>We first introduce an auxiliary operation, define <span class="math inline">\(x \otimes y= \operatorname{popcount}(x\wedge y) \bmod 2\)</span>, where <span class="math inline">\(\operatorname{popcount}(x)\)</span> denotes the number of <span class="math inline">\(1\)</span>s in the binary representation of <span class="math inline">\(x\)</span>.</p>
<p><strong>Claim:</strong> The transformation below turns convolutions to element-wise multiplications: <span class="math display">\[
\mathcal{FWHT}\{a\}_i=\sum_{j\otimes i=0} a_j - \sum_{j\otimes i=1} a_j
\]</span> <strong>Proof: </strong> <span class="math display">\[
\begin{aligned}
\mathcal{FWHT}\{a\}_i\cdot\mathcal{FWHT}\{b\}_i &amp;= \left(\sum_{j\otimes i=0} a_j - \sum_{j\otimes i=1} a_j\right) \left(\sum_{k\otimes i=0} b_k - \sum_{k\otimes i=1} b_k\right) \\
&amp;= \sum_{j\otimes i=0}\sum_{k\otimes i=0}a_jb_k +\sum_{j\otimes i=1}\sum_{k\otimes i=1}a_jb_k \\
&amp;- \sum_{j\otimes i=1}\sum_{k\otimes i=0}a_jb_k - \sum_{j\otimes i=0}\sum_{k\otimes i=1}a_jb_k
\end{aligned}
\]</span> How to simplify those terms?</p>
<p>Observe that by the definition of XOR we have <span class="math display">\[
\operatorname{popcount}(x\oplus y) = \operatorname{popcount}(x)+\operatorname{popcount}(y)-2\operatorname{popcount}(x\wedge y)
\]</span> So if we apply modulo <span class="math inline">\(2\)</span> on both sides, <span class="math display">\[
\operatorname{popcount}(x\oplus y) \equiv \operatorname{popcount}(x)+\operatorname{popcount}(y) \pmod 2
\]</span> Plug in <span class="math inline">\(x=j\wedge i,y=k\wedge i\)</span> and we get <span class="math display">\[
\operatorname{popcount}((j\wedge i)\oplus (k\wedge i)) \equiv \operatorname{popcount}(j\wedge i)+\operatorname{popcount}(k\wedge i) \pmod 2
\]</span> We are almost there. Apply the identity below, whose proof I simply omit here, <span class="math display">\[
(j\wedge i)\oplus (k\wedge i)=(j\oplus k)\wedge i
\]</span> (This is something good about bitwise operations: if you cannot prove an identity the smart way you can always fall back on the dumb method -- making a truth table)</p>
<p>We finally get <span class="math display">\[
(j \oplus k)\otimes i \equiv j\otimes i+k\otimes i \pmod 2
\]</span> (We are actually quite familiar with this if we remove the circles outside <span class="math inline">\(+\)</span>s and <span class="math inline">\(\times\)</span>s)</p>
<p>With this conclusion we can simplify the four terms above: <span class="math display">\[
\begin{aligned}
\mathcal{FWHT}\{a\}_i\cdot\mathcal{FWHT}\{b\}_i &amp;= \cdots \\
&amp;= \sum_{(j\oplus k)\otimes i=0}a_jb_k - \sum_{(j\oplus k)\otimes i=1}a_jb_k \\
&amp;=  \mathcal{FWHT}\{a\circledast b\}_i
\end{aligned}
\]</span> which completes the proof.</p>
<p>We then explore how to compute <span class="math inline">\(\mathcal{FWHT}\{a\}\)</span> efficiently. Divide and conquer is still our friend, and dividing <span class="math inline">\(a\)</span> based on the highest bit works here so we continue to use those notations.</p>
<p>Consider the first half of <span class="math inline">\(A\)</span>... <span class="math display">\[
\begin{aligned}
A_{0|i} &amp;= \sum_{j\otimes (0|i)=0} a_j - \sum_{j\otimes (0|i)=1} a_j \\
&amp;= \sum_{(0|j)\otimes (0|i)=0} a_j^0+  \sum_{(1|j)\otimes (0|i)=0}a_j^1 -  \sum_{(0|j)\otimes (0|i)=1} a_j^0-  \sum_{(1|j)\otimes (0|i)=1}a_j^1 \\
&amp;= \sum_{j\otimes i=0} a_j^0+  \sum_{j\otimes i=0}a_j^1 -  \sum_{j\otimes i=1} a_j^0-  \sum_{j\otimes i=1}a_j^1 \\
&amp;= A_i^0
+A_i^1\end{aligned}
\]</span> and the other half: <span class="math display">\[
\begin{aligned}
A_{1|i} &amp;= \sum_{j\otimes (1|i)=0} a_j - \sum_{j\otimes (1|i)=1} a_j \\
&amp;= \sum_{(0|j)\otimes (1|i)=0} a_j^0+  \sum_{(1|j)\otimes (1|i)=0}a_j^1 -  \sum_{(0|j)\otimes (1|i)=1} a_j^0-  \sum_{(1|j)\otimes (1|i)=1}a_j^1 \\
&amp;= \sum_{j\otimes i=0} a_j^0+  \sum_{j\otimes i=1}a_j^1 -  \sum_{j\otimes i=1} a_j^0-  \sum_{j\otimes i=0}a_j^1 \\
&amp;= A_i^0 - A_i^1
\end{aligned}
\]</span> So together we get <span class="math display">\[
A=\left(A^0+A^1,A^0-A^1\right)
\]</span> and the inverse transform <span class="math display">\[
A=(A&#39;,A&#39;&#39;) \Rightarrow \begin{cases}
\displaystyle A^0=\frac{A&#39;+A&#39;&#39;}{2} \\
\displaystyle A^1=\frac{A&#39;-A&#39;&#39;}{2}
\end{cases}
\]</span> The code for both transforms are a bit longer than those for OR and AND, but not by too much:</p>
<pre class="line-numbers"><code class="language-cpp">void fwht_xor(int n, int *a, int *A) &#123;
    std::copy(a, a + n, A);
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1) &#123;
        for (int l = 0; l &lt; n; l += s) &#123;
            for (int i = 0; i &lt; h; i++) &#123;
                int t = A[l + h + i];
                A[l + h + i] = A[l + i] - t;
                A[l + i] += t;
            &#125;
        &#125;
    &#125;
&#125;
void ifwht_xor(int n, int *a, int *A) &#123;
    std::copy(A, A + n, a);
    // If n is guaranteed to be a power of 2 then we don&#39;t need n_ and the min(...) in the inner loop.
    int n_ = 1; while (n_ &lt; n) n_ &lt;&lt;= 1; 
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1) &#123;
        for (int l = 0; l &lt; n; l += s) &#123;
            for (int i = 0; i &lt; std::min(i, n - l - h); i++) &#123;
                int t = a[l + h + i];
                a[l + h + i] = (a[l + i] - t) / 2;
                a[l + i] = (a[l + i] + t) / 2;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>They can be merged as well:</p>
<pre class="line-numbers"><code class="language-cpp">void fwht_xor(int n, int *a, int *A, bool inv = false) &#123;
    std::copy(a, a + n, A);
    for (int s = 2, h = 1; s &lt;= n; s &lt;&lt;= 1, h &lt;&lt;= 1) &#123;
        for (int l = 0; l &lt; n; l += s) &#123;
            for (int i = 0; i &lt; h; i++) &#123;
                int t = A[l + h + i];
                A[l + h + i] = A[l + i] - t;
                A[l + i] += t;
                if (inv) A[l + h + i] /= 2, A[l + i] /= 2;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p><strong>This code above is what Wikipedia refers to as the authentic Fast Walsh-Hadamard Transform</strong>.</p>
<h1 id="some-sidenotes">Some sidenotes</h1>
<p>Note that though FFT and FWHT shares the same idea of divide and conquer, FWHT does not require <span class="math inline">\(n\)</span> to be a power of <span class="math inline">\(2\)</span> whereas FFT does. (Well actually neither of them "require" <span class="math inline">\(n\)</span> to be a power of <span class="math inline">\(2\)</span>, but to apply FFT when <span class="math inline">\(n\)</span> is not a power of <span class="math inline">\(2\)</span> you either need to pad with <span class="math inline">\(0\)</span>s or you have to make your implementation really complicated).</p>
<p>Also, I just came to know that if we express WHT in the language of matrices and vectors, the matrix is called a Hadamard Matrix.</p>
<p>Another fact that I didn't quite understand is why the order of the inverse FWHT can be reversed.</p>
<p>For instance, when <span class="math inline">\(n=8\)</span>, after fully dividing the sequence into individual elements, we first merge <span class="math inline">\((0,1),(2,3),(4,5),(6,7)\)</span>, then we merge <span class="math inline">\((0,1,2,3),(4,5,6,7)\)</span> and finally <span class="math inline">\((0,1,2,3,4,5,6,7)\)</span>. Naturally when we do the inverse transform we have to start with <span class="math inline">\((0,1,2,3,4,5,6,7)\)</span>, recover <span class="math inline">\((0,1,2,3),(4,5,6,7)\)</span>, then recover <span class="math inline">\((0,1),(2,3),(4,5),(6,7)\)</span> and then recover the individual elements. But the popular implementation seems to suggest that the inverse transformation algorithm works in another direction as well. I am now puzzled why this is true and currently I'm just taking this for granted. Perhaps I derived the inversion in a different way than others did? If you have a simple explanation please leave a comment :)</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/07/29/PACT0710/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/29/PACT0710/" class="post-title-link" itemprop="url">PACT 07/10 主对偶方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-07-29 16:29:11 / 修改时间：21:45:12" itemprop="dateCreated datePublished" datetime="2020-07-29T16:29:11+08:00">2020-07-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是主对偶方法">什么是主对偶方法？</h1>
<p>对于所有可以写成整数规划/线性规划形式的问题（不妨假设是最小化问题），由对偶定理可得，对偶最优解一定是<span class="math inline">\(\mathrm{OPT}\)</span>的一个下界。</p>
<p>因此，对偶可行解也是<span class="math inline">\(\mathrm{OPT}\)</span>的一个下界。</p>
<p>所谓的主对偶方法（Primal-dual Method），就是从一个对偶规划的可行解出发，不断优化这个对偶可行解，并在这个过程中利用对偶规划的特性指引我们求得原问题的解。</p>
<p>太抽象？</p>
<h1 id="叕访顶点覆盖">叕访顶点覆盖</h1>
<p>（顶点覆盖问题属实牛逼嗷，那么多近似方法都可以用）</p>
<p>顶点覆盖问题的主线性规划是 <span class="math display">\[
\begin{aligned}
    \text{minimize}\quad &amp;\sum_{v\in V}w_vx_v \\
    \text{subject to}\quad &amp;x_u+x_v\ge 1\quad \forall (u, v)\in E \\
    &amp;x_v \in \{0,1\}\quad \forall v\in V
\end{aligned}
\]</span> 其对偶规划是 <span class="math display">\[
\begin{aligned}
    \text{maximize}\quad &amp;\sum_{v\in E} y_e \\
    \text{subject to}\quad &amp;\sum_{v\in e} y_e \le w_v \quad \forall v \in V\\
    &amp;y_e \ge 0\quad \forall e\in E
\end{aligned}
\]</span> 显然，<span class="math inline">\(y_e=0\)</span>就是一个平凡的对偶可行解。基于主对偶方法的思想，我们可以得到两个算法：</p>
<h2 id="算法1">算法1</h2>
<ol type="1">
<li>初始化<span class="math inline">\(y_e\gets0,C\gets \emptyset\)</span>。</li>
<li>当还有一条边<span class="math inline">\((u,v)\)</span>没有被覆盖时，
<ol type="1">
<li><span class="math inline">\(\varepsilon\gets \min\left\{w_u-\sum_{u\in e} y_e,w_v-\sum_{v\in e} y_e\right\}\)</span>。</li>
<li><span class="math inline">\(y_e\gets y_e+\varepsilon\)</span>（以上两步旨在尽可能增加<span class="math inline">\(y_e\)</span>直至两端点中一个点对应的约束收紧）。</li>
<li>假设增加<span class="math inline">\(y_e\)</span>之后<span class="math inline">\(u\)</span>对应的约束收紧了，那么<span class="math inline">\(C\gets C\cup\{u\}\)</span>。</li>
<li>同时删除所有与<span class="math inline">\(u\)</span>邻接的边。</li>
</ol></li>
<li>返回<span class="math inline">\(C\)</span>。</li>
</ol>
<p>（注意到，当<span class="math inline">\(w_u=1\)</span>时，这个算法退化为我们最初学的极大匹配算法）</p>
<h2 id="算法2">算法2</h2>
<ol type="1">
<li>初始化<span class="math inline">\(y_e\gets0,C\gets \emptyset\)</span>。</li>
<li>当<span class="math inline">\(C\)</span>不是一个合法的顶点覆盖时，
<ol type="1">
<li><span class="math inline">\(\varepsilon\gets \min_{v\in V} \left\{\frac{1}{\deg(v)}\sum_{v\in e}y_e\right\}\)</span></li>
<li>对于所有边<span class="math inline">\(e\in E\)</span>，<span class="math inline">\(y_e\gets y_e+\varepsilon\)</span>（以上两步旨在同时增加所有<span class="math inline">\(y_e\)</span>直至有约束收紧）。</li>
<li>将所有紧约束对应的顶点加入<span class="math inline">\(C\)</span>。</li>
<li>同时删去这些点和它们邻接的所有边。</li>
</ol></li>
<li>返回<span class="math inline">\(C\)</span>。</li>
</ol>
<p>其实还有很多这样的寻找局部极大对偶可行解的方法，以上两个算法是最容易想到的。</p>
<h2 id="分析">分析</h2>
<p>两个算法的分析是共通的： <span class="math display">\[
\begin{aligned}
    \sum_{v\in C}w_v &amp;= \sum_{v \in C}\sum_{v\in e\in E} y_e \\
    &amp;= \sum_{e\in E} y_e |C\cap e| \\
    &amp;\le \sum_{e\in E} y_e \cdot 2 \\
    &amp;= 2 \cdot \mathrm{OPT}_{\text{dual}} \\
    &amp;\le 2 \cdot \mathrm{OPT}
\end{aligned}
\]</span> 以上步骤的第一步是因为我们加入覆盖集的所有顶点对应的约束都是紧的。</p>
<p>主对偶方法神奇的一点就在于：<strong>虽然我们在线性规划的指导下进行设计与分析，但是最后的算法却是一个完全不需要求解线性规划的纯粹的组合算法（Combinatorial Algorithm），因此非常优雅。</strong></p>
<h1 id="再探设施选址">再探设施选址</h1>
<p>回忆之前设施选址的线性规划。<span class="math inline">\(y_i\)</span>表示设施<span class="math inline">\(i\)</span>是否被选，<span class="math inline">\(x_{ij}\)</span>表示用户<span class="math inline">\(j\)</span>是否到设施<span class="math inline">\(i\)</span>去： <span class="math display">\[
\begin{aligned}
    \text{minimize}\quad &amp;\sum_{i\in F}f_iy_i + \sum_{j\in D}\sum_{i \in F}c_{ij}x_{ij} \\
    \text{subject to}\quad &amp;\sum_{i\in F}x_{ij} \ge 1 \quad \forall j\in D \\
    &amp;y_i - x_{ij} \ge 0 \quad \forall i\in F, j\in D \\
    &amp;x_{ij} \ge 0 \quad \forall i\in F, j\in D \\
    &amp;y_i \ge 0 \quad \forall i \in F
\end{aligned}
\]</span> 其对偶为 <span class="math display">\[
\begin{aligned}
    \text{maximize}\quad &amp;\sum_{j \in D}\alpha_j \\
    \text{subject to}\quad &amp;\alpha_j - \beta_{ij} \le c_{ij}\quad \forall i \in F, j\in D \\
    &amp;\sum_{j\in D}\beta_{ij} \le f_i\quad \forall i\in F
\end{aligned}
\]</span></p>
<p>以下将对偶规划中第一行的约束称为“第一类约束”，第二行的约束称为“第二类约束”。</p>
<h2 id="算法">算法</h2>
<p>我们设计一个基于主对偶方法的近似算法：</p>
<ol type="1">
<li>初始化<span class="math inline">\(\alpha_j\gets 0,\beta_{ij}\gets 0\)</span>（平凡的对偶可行解）。</li>
<li>以相同的速率同时增加的值<span class="math inline">\(\alpha_j\)</span>。</li>
<li>当对于某些<span class="math inline">\(i,j\)</span>出现<span class="math inline">\(\alpha_j=c_{ij}\)</span>时，为了能够在不违反第一类约束的前提下让<span class="math inline">\(\alpha_j\)</span>继续增加，我们开始同步增加<span class="math inline">\(\beta_{ij}\)</span>的值。</li>
<li>随着一些<span class="math inline">\(\beta_{ij}\)</span>值的增加某些第二类约束也会收紧，此时暂时开放该约束对应的设施。因为此时对应的<span class="math inline">\(\beta_{ij}\)</span>不能再增加了，那些<span class="math inline">\(\alpha_j\)</span>也自然不会再增加了，我们就此将这些<span class="math inline">\(\alpha_j\)</span>的值冻结起来（其余的<span class="math inline">\(\alpha_j\)</span>可以继续增加）。</li>
<li>不断重复以上步骤直至所有的<span class="math inline">\(\alpha_j\)</span>都被冻结了。</li>
<li>按照第4步开放的先后顺序处理所有暂时开放的设施，
<ol type="1">
<li>永久开放该设施，</li>
<li>并将所有和该设施共享一个“紧顾客”（tight client，指和设施对应约束是紧的顾客，这里实在是不怎么好翻，具体的解释参看下面的感性认识和接下来的分析），即那些两边的<span class="math inline">\(\beta\)</span>都大于<span class="math inline">\(0\)</span>的顾客的暂时开放的设施关闭（移出队列）。</li>
</ol></li>
</ol>
<p>听听这是人话吗？感性理解一下以上算法（也有助于接下来的分析）：</p>
<ol type="1">
<li><span class="math inline">\(\alpha_j\)</span>可以理解为每个顾客为了得到服务愿意付出的代价，一开始所有人都想白嫖。</li>
<li>显然如果大家都想白嫖的话没有一个人会得到服务，因此大家一起提升这个愿意付出的代价。</li>
<li>当<span class="math inline">\(\alpha_j=c_{ij}\)</span>也就是某个顾客发现自己愿意支付的价位内出现了设施的时候他就很高兴。但是这个设施没开，所以顾客决定给这个设施的开放分摊成本（增加<span class="math inline">\(\beta_{ij}\)</span>），但是这样也不是个事，万一不远处有个不需要他付钱或者只需要分摊很少开张费用的设施呢？所以<span class="math inline">\(\alpha_j\)</span>的增长也不能落下。</li>
<li>当有第二类约束收紧，即几个顾客终于凑够了钱让这个设施开放，那么这个设施就暂时开张了。这几个用户很满足，就准备去这个设施了，所以他们的<span class="math inline">\(\alpha_j\)</span>不增加了。</li>
<li>不断重复以上步骤直至满足所有顾客的需求。</li>
<li>按照第4步开放的先后顺序处理暂时开张的设施，
<ol type="1">
<li>永久开张，</li>
<li>如果去这个设施的顾客里有人给其他设施也分摊成本了，那把那些设施全部关掉。</li>
</ol></li>
</ol>
<p>（如果我把上面变量的名字换一下，把“第一类约束”，“第二类约束”也换个名字，那么从上面的算法当中你根本看不到线性规划的痕迹，这就是一个听着很有道理实际上近似比也有保证的组合算法。这就是主对偶方法的优雅之处。）</p>
<h2 id="分析-1">分析</h2>
<p>我们不妨称那些为最后永久开放的设施垫付开张成本的顾客为“幸运顾客”，形式上地来说，一个顾客<span class="math inline">\(j\)</span>为幸运顾客当且仅当最后永久开张的设施中有一处设施<span class="math inline">\(i\)</span>使得<span class="math inline">\(\alpha_j-\beta_{ij}=c_{ij},\beta_{ij}&gt;0\)</span>，也就是说顾客<span class="math inline">\(j\)</span>和设施<span class="math inline">\(i\)</span>之间在对偶规划对应的约束是紧的——这也是上面tight client的本意。</p>
<p>相对地我们称不是幸运顾客的那些顾客“倒霉顾客”，说他们倒霉是因为他们明明给某些设施分摊了开张成本，也都准备好去那里了，结果这个设施在最后关掉了。</p>
<p>不妨设最后决定开张的设施为<span class="math inline">\(F&#39;\)</span>，幸运顾客的集合为<span class="math inline">\(L\)</span>。<span class="math inline">\(j \to i\)</span>表示顾客<span class="math inline">\(j\)</span>到设施<span class="math inline">\(i\)</span>的约束是紧的（也就是顾客<span class="math inline">\(j\)</span>给设施<span class="math inline">\(i\)</span>分摊了成本）。注意由于我们算法最后一步的清理操作，每个幸运顾客只可能垫付一个<span class="math inline">\(F\)</span>中设施的成本，那么设施的开放费用和幸运顾客的服务成本可以一起表示为： <span class="math display">\[
\begin{align}
    &amp;\quad\,\sum_{i\in F&#39;}f_i+\sum_{j\in L} \sum_{\substack{i\in F&#39;\\ j\to i}} c_{ij}\\
    &amp;= \sum_{i \in F&#39;}\sum_{\substack{j\in L\\ j\to i}} \beta _{ij}+\sum_{j\in L} \sum_{\substack{i\in F&#39;\\ j\to i}} \left(\alpha_j - \beta_{ij}\right) \\
    &amp;=\sum_{j \in L} \alpha_{j}
\end{align}
\]</span> 我们接下来分析倒霉顾客的情况。</p>
<p>假设有一个倒霉顾客<span class="math inline">\(k\)</span>，他分摊了设施<span class="math inline">\(b\)</span>的开张成本并最终让设施<span class="math inline">\(b\)</span>暂时开张（同时假设<span class="math inline">\(b\)</span>是他分摊成本的设施中最先开张的——也就是<span class="math inline">\(\alpha_k\)</span>恰在<span class="math inline">\(b\)</span>开张后被冻结）。但是比<span class="math inline">\(b\)</span>早开张的设施<span class="math inline">\(a\)</span>中有一个幸运顾客<span class="math inline">\(j\)</span>也为<span class="math inline">\(b\)</span>分摊了成本，导致最后清理的时候<span class="math inline">\(b\)</span>被关闭了。不妨假设<span class="math inline">\(k\)</span>最后只能去<span class="math inline">\(a\)</span>。注意到由三角不等式， <span class="math display">\[
\begin{align}
c_{ak} &amp;\le c_{aj} + c_{bj} +c_{bk} \\
&amp;\le (\alpha_j-\beta_{aj}) + (\alpha_j - \beta_{bj}) + (\alpha_{k}-\beta_{bk}) \\
&amp;\le \alpha_j+\alpha_j + \alpha_k \\
&amp;\le 3\alpha_k
\end{align}
\]</span> 最后一步之所以成立，是因为<span class="math inline">\(a\)</span>开张后<span class="math inline">\(\alpha_j\)</span>必然冻结，<span class="math inline">\(\alpha_k\)</span>停止增长要等到<span class="math inline">\(b\)</span>开张后。而<span class="math inline">\(a\)</span>比<span class="math inline">\(b\)</span>先开张，因此<span class="math inline">\(\alpha_k \ge \alpha_j\)</span>。我们在上面假设<span class="math inline">\(k\)</span>最后去了<span class="math inline">\(a\)</span>，其实如果最后<span class="math inline">\(k\)</span>去了比<span class="math inline">\(a\)</span>还近的那自然他的服务成本更低了。</p>
<p>因此倒霉顾客的服务成本<span class="math inline">\(\le \sum_{k\in D\setminus L} \alpha_k\)</span>。</p>
<p>结合上述的分析，我们可以得到我们的总成本： <span class="math display">\[
\begin{align}
    \text{total cost} &amp;\le \sum_{j\in L} \alpha_j + \sum_{k\in D\setminus L} 3\alpha_k \\
    &amp;\le 3\sum_{j\in D}\alpha_j \\
    &amp;\le 3\cdot\mathrm{OPT}
\end{align}
\]</span> 也就是说，我们证明了我们这个算法的近似比为<span class="math inline">\(3\)</span>。</p>
<h2 id="为什么最后一步要清理一些暂时开张的设施">为什么最后一步要清理一些暂时开张的设施？</h2>
<p>为什么我们算法的最后一步要清理暂时开张的设施呢？为什么不能一些用户分摊够开张费用就让这个设施永久开张下去呢？</p>
<p>考虑如下的一个实例：</p>
<p>有<span class="math inline">\(n\)</span>个设施，其中<span class="math inline">\(f_1=n+1\)</span>且<span class="math inline">\(f_i=n+2\quad\forall i =2,3,\cdots,n\)</span>。</p>
<p>有<span class="math inline">\(2n\)</span>个顾客。前<span class="math inline">\(n\)</span>名顾客到所有设施的距离都是<span class="math inline">\(1\)</span>。对于后面的<span class="math inline">\(n\)</span>名顾客，第<span class="math inline">\(n+i\)</span>名顾客只和设施<span class="math inline">\(i\)</span>的距离为<span class="math inline">\(1\)</span>，和其余设施的距离都为<span class="math inline">\(3\)</span>。易证这样的边权满足三角不等式。</p>
<p>现在考察我们算法的运行情况：</p>
<ul>
<li><span class="math inline">\(t=0\)</span>，初始化。</li>
<li><span class="math inline">\(t=1\)</span>，所有的<span class="math inline">\(\alpha_j=1\)</span>，每名顾客开始为至少一个设施分摊成本了。</li>
<li><span class="math inline">\(t=2\)</span>，对于任何一个设施都有<span class="math inline">\(n+1\)</span>名顾客为其人均分摊了<span class="math inline">\(1\)</span>的开张成本，而注意到<span class="math inline">\(f_1=n+1\)</span>，因此设施<span class="math inline">\(1\)</span>开张了，相应地，前<span class="math inline">\(n\)</span>名顾客和第<span class="math inline">\(n+1\)</span>名顾客的<span class="math inline">\(\alpha_j\)</span>被冻结。其余的<span class="math inline">\(n-1\)</span>名顾客继续为对应的设施分摊费用。</li>
<li><span class="math inline">\(t=3\)</span>，剩下的<span class="math inline">\(n-1\)</span>家设施全部开张。</li>
</ul>
<p>如果没有最后的清理步骤，那么我们的算法会开放所有的设施。光是开放设施的代价就有<span class="math inline">\(n+1+(n-1)(n+2)=\Omega(n^2)\)</span>。而只开一家设施的代价是<span class="math inline">\(O(n)\)</span>的。因此最后的清理步骤非常重要！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/07/15/DDNS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/15/DDNS/" class="post-title-link" itemprop="url">自己写一个DDNS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-15 21:38:08" itemprop="dateCreated datePublished" datetime="2020-07-15T21:38:08+08:00">2020-07-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-18 19:51:53" itemprop="dateModified" datetime="2020-12-18T19:51:53+08:00">2020-12-18</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>前几天借着Github的学生优惠在name.com上嫖了一个域名，这个域名是带SSL的，而恰巧家里的主机因为443端口被封的缘故无法通过Let's Encrypt获得证书，所以把这个域名给家里的主机升级HTTPS再合适不过了。</p>
<p>唯一的问题是name.com只提供静态DNS服务，而服务器放在家里自然是动态IP的。虽然IP不是经常换但是如果换了IP没有及时更新记录就会出问题，何况手动更新记录也有点烦。有两个方案：</p>
<ol type="1">
<li>我目前使用的是花生壳的DDNS，这个的记录是动态更新的。我可以在新域名下面新建一条CNAME记录指向动态域名。这样的好处是省事，坏处是可能会增加DNS解析的时间，我目前还不清楚HTTPS要不要求CNAME指向的域名也有证书，如果要求的话这个方法就更不行了。</li>
<li>name.com作为一家比较大的域名商有自己的API以及<a target="_blank" rel="noopener" href="https://www.name.com/api-docs">完备的文档</a>，可以自己写一个定时更新脚本来实现类似DDNS的功能。</li>
</ol>
<p>经过考虑之后我选择后者。自己写的脚本如下：</p>
<pre class="line-numbers"><code class="language-bash">#!/bin/sh

domain=&#39;&lt;DOMAIN&gt;&#39;
credential=&#39;&lt;ACCESS TOKEN&gt;&#39;
ttl=300
interval=10

echo &#39;Querying type A record ID...&#39;
rec_id=$(curl -su $credential &quot;https://api.name.com/v4/domains/$&#123;domain&#125;/records&quot; | jq &#39;.records|map(select(.type==&quot;A&quot;))|.[0].id&#39;)
echo &#39;Found type A record ID:&#39; $rec_id

while true; do
    res_ip=$(host $domain | grep -ohP &#39;\b(?:\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1,3&#125;\b&#39;)
    real_ip=$(curl -s myip.ipip.net | grep -ohP &#39;\b(?:\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1,3&#125;\b&#39;)
    echo &#39;Resolution IP:&#39; $res_ip &#39;Real IP:&#39; $real_ip
    if [[ $real_ip != $res_ip ]]; then
        echo &quot;Resolution mismatch! Updating record...&quot;  
        req_data=&quot;&#123;\&quot;type\&quot;:\&quot;A\&quot;,\&quot;fqdn\&quot;:\&quot;$&#123;domain&#125;.\&quot;,\&quot;answer\&quot;:\&quot;$&#123;real_ip&#125;\&quot;,\&quot;ttl\&quot;:$&#123;ttl&#125;&#125;&quot;
        echo &quot;Request data:&quot; $(echo $req_data | jq &#39;.&#39;)
        req_res=$(curl -m 30 -su $credential &quot;https://api.name.com/v4/domains/$&#123;domain&#125;/records/$&#123;rec_id&#125;&quot; \
            -X PUT -H &#39;Content-Type: application/json&#39; --data $req_data | jq &#39;.&#39;)
        echo &quot;Request result:&quot; $req_res 
        sleep $ttl
    fi
    sleep $interval
done</code></pre>
<p>其实很简单，主要分为一下几个部分：</p>
<ol type="1">
<li>记录id的获取。name.com对每一个记录都分配了一个id以便于API操作，这个id在网站管理面板上是不可见的，因此需要在运行时查询，命令为<code>curl -su $credential "https://api.name.com/v4/domains/$&#123;domain&#125;/records"</code>。查询之后需要解析JSON，这里我使用的是<code>jq</code>这个第三方JSON parser。</li>
<li>当前DNS解析的IP。这个使用<code>host</code>结合<code>grep</code>提取IP字符串即可。</li>
<li>获取本机真实IP。这个接口就多了，我这里用的是<code>myip.ipip.net</code>的接口。据我所知还有接口是直接返回IP字符串的，还可以后处理的功夫。</li>
<li>如果解析IP和真实IP不符，那就调用API更新记录。注意在更新完之后最好等待TTL的时间以避免更新生效前多次更新。</li>
</ol>
<p>写完这个脚本再写一个配套的systemd service file，然后<code>systemctl</code>挂在后台运行就好了。运行到现在效果非常好。如果有name.com的域名同时也有类似需求的或许可以参考一下。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/07/14/PACT0709/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/14/PACT0709/" class="post-title-link" itemprop="url">PACT 07/09 设施选址问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-14 14:08:14" itemprop="dateCreated datePublished" datetime="2020-07-14T14:08:14+08:00">2020-07-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-07-29 16:17:38" itemprop="dateModified" datetime="2020-07-29T16:17:38+08:00">2020-07-29</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="定义">定义</h1>
<p><strong>输入：</strong>二分图<span class="math inline">\(G\)</span>，顶点集分为设施集<span class="math inline">\(F\)</span>和客户集<span class="math inline">\(D\)</span>。设施<span class="math inline">\(i\)</span>的开放费用为<span class="math inline">\(f_i\)</span>，用户<span class="math inline">\(j\)</span>到设施<span class="math inline">\(i\)</span>的有权为<span class="math inline">\(c_{ij}\)</span>的边代表距离。边权满足三角不等式。</p>
<p><strong>目标：</strong>寻找一组设施<span class="math inline">\(S\)</span>，使得 <span class="math display">\[
\sum_{i \in S} f_i + \sum_{j\in D} \min_{i \in S} \{c_{ij}\}
\]</span> 即每个用户都会去离自己最近（或者说最划算）设施，求最小化开店费用加上服务成本（即每个顾客要走的距离之和）的开店方案。</p>
<h1 id="线性规划表述">线性规划表述</h1>
<p>令<span class="math inline">\(y_i\)</span>表示设施<span class="math inline">\(i\)</span>是否被选，<span class="math inline">\(x_{ij}\)</span>表示用户<span class="math inline">\(j\)</span>是否到设施<span class="math inline">\(i\)</span>去，则设施选址问题可以表述为下列线性规划（松弛整数限制）： <span class="math display">\[
\begin{aligned}
    \text{minimize}\quad &amp;\sum_{i\in F}f_iy_i + \sum_{j\in D}\sum_{i \in F}c_{ij}x_{ij} \\
    \text{subject to}\quad &amp;\sum_{i\in F}x_{ij} \ge 1 \quad \forall j\in D \\
    &amp;y_i - x_{ij} \ge 0 \quad \forall i\in F, j\in D \\
    &amp;x_{ij} \ge 0 \quad \forall i\in F, j\in D \\
    &amp;y_i \ge 0 \quad \forall i \in F
\end{aligned}
\]</span> 其中第一个约束表示所有顾客至少要去一个设施。第二个约束表示只有一个设施开的时候用户才可以去。</p>
<p>其对偶为 <span class="math display">\[
\begin{aligned}
    \text{maximize}\quad &amp;\sum_{j \in D}\alpha_j \\
    \text{subject to}\quad &amp;\alpha_j - \beta_{ij} \le c_{ij}\quad \forall i \in F, j\in D \\
    &amp;\sum_{j\in D}\beta_{ij} \le f_i\quad \forall i\in F
\end{aligned}
\]</span></p>
<p>令<span class="math inline">\((x^*,y^*)\)</span>和<span class="math inline">\((\alpha^*,\beta^*)\)</span>为主规划和对偶规划的最优解。显然，在线性规划当中很可能出现<span class="math inline">\(0&lt;x^*_{ij}&lt;1\)</span>即“部分得到服务”的情况。</p>
<h1 id="近似算法的设计思路与分析">近似算法的设计思路与分析</h1>
<p><strong>引理：</strong>如果<span class="math inline">\(x_{ij}^* &gt; 0\)</span>那么<span class="math inline">\(\alpha_j^* \ge c_{ij}\)</span>。</p>
<p><strong>证明：</strong>由主互补松弛条件，若<span class="math inline">\(x_{ij}^*&gt;0\)</span>则<span class="math inline">\(\alpha_j^*-\beta_{ij}^* = c_{ij}\)</span>，又<span class="math inline">\(\beta_{ij}^* \ge 0\)</span>，得证。</p>
<p>定义顾客<span class="math inline">\(j\)</span>所有部分光顾的设施为<span class="math inline">\(j\)</span>的邻域<span class="math inline">\(N(j)=\left\{ i \Big| x_{ij}^* &gt; 0,i\in F\right\}\)</span>。</p>
<p>很容易想到一个近似算法：<strong>对于每一个顾客，我们开放邻域中离他最近的设施</strong>。</p>
<p>由于我们的引理和弱对偶原理，我们的总服务成本<span class="math inline">\(\le \sum_{j\in D}\alpha_j^* \le \mathrm{OPT}\)</span>。如果我们开放设施的成本也有个上界就好了。</p>
<p>然而并不行。</p>
<p>考虑如下反例：</p>
<p><img src="/2020/07/14/PACT0709/P1.svg" class=""></p>
<p>如果按照我们的算法，我们会为<span class="math inline">\(j\)</span>和<span class="math inline">\(j&#39;\)</span>分别开放一个代价<span class="math inline">\(24\)</span>的设施。而事实上开那个代价<span class="math inline">\(25\)</span>的设施就够了。我们差不多浪费了两倍的钱，而这个倍数可以任意高（只要让代价稍高一点的设施处在所有顾客的邻域当中，而使每个顾客的邻域中都有比其代价略低的设施即可）。</p>
<p>但是我们知道，<strong>对于任何一组邻域不交的顾客，开放设施的代价确实是不大于<span class="math inline">\(\mathrm{OPT}\)</span>的</strong>（为什么？因为那些设施只服务一个顾客，而那个顾客有可能“部分”光顾其他设施。比如说一个顾客光顾了<span class="math inline">\(0.5\)</span>的设施<span class="math inline">\(1\)</span>（代价为<span class="math inline">\(10\)</span>）和<span class="math inline">\(0.5\)</span>的设施<span class="math inline">\(2\)</span>（代价为<span class="math inline">\(20\)</span>），那么这个顾客就给目标函数贡献了<span class="math inline">\(0.5\times10+0.5\times 20\)</span>，显然这个时候如果我去开代价<span class="math inline">\(10\)</span>的那个设施，开店费是<span class="math inline">\(10\)</span>，是小于最优目标函数的）</p>
<p>那我不妨先任选一组邻域不交的顾客（不妨称之为“幸运顾客”）按照就近原则开放他们的设施，然后再让那些邻域和幸运顾客有交集的顾客（不妨称之为“倒霉顾客”）去这些设施。</p>
<p>根据我们之前的分析，幸运顾客的服务成本一定不大于<span class="math inline">\(\mathrm{OPT}\)</span>，考虑倒霉顾客的服务成本。假设倒霉顾客<span class="math inline">\(j\)</span>和幸运顾客<span class="math inline">\(i\)</span>的邻域共享一个设施<span class="math inline">\(b\)</span>，幸运顾客可以去离他最近的设施<span class="math inline">\(a\)</span>。</p>
<p>那么根据三角不等式，让<span class="math inline">\(j\)</span>去<span class="math inline">\(a\)</span>的距离为 <span class="math display">\[
c_{aj} \le c_{bj}+c_{bi}+c_{ai}
\]</span> 根据引理， <span class="math display">\[
\begin{align}
c_{aj} &amp;\le c_{bj}+c_{bi}+c_{ai} \\
&amp;\le \alpha_j^* + \alpha_i^* + \alpha _i^* \\
&amp;\stackrel{?}{\le} 3\alpha_j^* 
\end{align}
\]</span> 最后一步是我们希望得出的，因为如果这样，那么所有顾客的服务成本的上界就是（不妨令幸运顾客的集合为<span class="math inline">\(D_1\)</span>，不幸运顾客的集合为<span class="math inline">\(D_2\)</span>）： <span class="math display">\[
\begin{align}
    \sum_{j\in D_1} \alpha_j^* + \sum_{j\in D_2}3\alpha_j^* \le \sum_{j\in D_1}3 \alpha_j^* + \sum_{j\in D_2}3\alpha_j^* = \mathrm{OPT}_{\text{dual}} \le \mathrm{OPT}
\end{align}
\]</span> 但是按照目前的信息最后一步并不总是成立的。</p>
<p>那怎么办？改算法呗。我们只需要保证所有幸运顾客的<span class="math inline">\(\alpha^*\)</span>都小于等于倒霉顾客的<span class="math inline">\(\alpha^*\)</span>，也就是说排一下序就好了。</p>
<p>于是我们就得到了我们的算法：</p>
<ol type="1">
<li>解原线性规划和对偶线性规划，得到<span class="math inline">\((x^*,y^*),(\alpha^*,\beta^*)\)</span>。</li>
<li>选一个<span class="math inline">\(\alpha^*\)</span>最小的顾客并开放他邻域当中离他最近的店。</li>
<li>暂时移除所有和这个顾客有相交邻域的顾客。</li>
<li>持续以上两步直至所有顾客都被选中或移除。</li>
<li>让所有被移除的顾客去离他们最近的已开放设施。</li>
</ol>
<p>这个算法的近似是多少呢？上面的分析已经说明了这个方案的设施成本不大于<span class="math inline">\(\mathrm{OPT}\)</span>，而服务成本不大于<span class="math inline">\(3\mathrm{OPT}\)</span>，因此总的来说这就是一个<span class="math inline">\(4\)</span>倍近似算法。</p>
<h1 id="近似难度">近似难度</h1>
<p><strong>定理（Guha, Khuller 1999）：</strong>如果设施选址问题存在近似比小于<span class="math inline">\(1.463\)</span>的算法，则<span class="math inline">\(\mathsf{P}=\mathsf{NP}\)</span>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/07/12/PACT0708/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/12/PACT0708/" class="post-title-link" itemprop="url">PACT 07/08 叒访顶点覆盖 & 单机任务调度</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-07-12 11:21:25 / 修改时间：17:11:43" itemprop="dateCreated datePublished" datetime="2020-07-12T11:21:25+08:00">2020-07-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="用对偶规划解顶点覆盖">用对偶规划解顶点覆盖</h1>
<p>回顾一下，顶点覆盖问题的主线性规划（松弛后）是 <span class="math display">\[
\begin{aligned}
    \text{minimize}\quad &amp;\sum_{v\in V}w_vx_v \\
    \text{subject to}\quad &amp;x_u+x_v\ge 1\quad \forall (u, v)\in E \\
    &amp;x_v \in \{0,1\}\quad \forall v\in V
\end{aligned}
\]</span> 其对偶规划是 <span class="math display">\[
\begin{aligned}
    \text{maximize}\quad &amp;\sum_{v\in E} y_e \\
    \text{subject to}\quad &amp;\sum_{v\in e} y_e \le w_v \quad \forall v \in V\\
    &amp;y_e \ge 0\quad \forall e\in E
\end{aligned}
\]</span> 我们在此设计一个通过解对偶规划来求得原问题解的近似算法。依赖于对偶规划的好处是：在分析过程中我们必须给<span class="math inline">\(\mathrm{OPT}\)</span>一个下界，而由对偶规划的定义，对偶规划的目标函数值就是一个非常好的下界，因此基于对偶规划的近似算法在分析上是比较便利的。</p>
<p>假设我们已经求得了对偶规划的最优解，如何以此确定原规划的变量取值呢？回忆我们在学对偶时学到的互补松弛条件</p>
<blockquote>
<p>若主线性规划最优解中一变量非零，则其对偶规划中对应约束收紧。</p>
</blockquote>
<p>其逆命题为</p>
<blockquote>
<p>若对偶规划中对应约束收紧，则主规划中对应变量非零。</p>
</blockquote>
<p>虽该命题未必正确，但给我们设计算法提供了思路。我们的算法就是：</p>
<ol type="1">
<li>求取对偶规划的最优解。</li>
<li>对于最优解中每一个紧约束，将其在主规划中对应的顶点加入顶点覆盖。</li>
</ol>
<p>接下来我们分析一下这个算法：</p>
<p><strong>引理：</strong>我们给出的顶点覆盖是可行的。</p>
<p><strong>证明：</strong>不妨假设我们给出的顶点覆盖不合法，即有一条边<span class="math inline">\(e=(u,v)\)</span>没有被覆盖到。那么由我们的算法可知<span class="math inline">\(u,v\)</span>对应的对偶约束在对偶最优解中是松的，而既然如此为什么不增加<span class="math inline">\(y_e\)</span>使其一收紧，同时增加目标函数的值呢？显然这和“我们求得对偶规划的最优解”是矛盾的。</p>
<p><strong>定理：</strong>我们的算法是一个<span class="math inline">\(2\)</span>倍近似算法。</p>
<p><strong>证明：</strong>假设我们算法给出的覆盖集为<span class="math inline">\(C\)</span>，则我们顶点覆盖的总代价就是<span class="math inline">\(\sum_{v\in C}w_v\)</span>，而由我们算法选取顶点的条件，有 <span class="math display">\[
\begin{aligned}
    \sum_{v\in C}w_v &amp;= \sum_{v \in C}\sum_{v\in e\in E} y_e \\
    &amp;= \sum_{e\in E} y_e |C\cap e| \\
    &amp;\le \sum_{e\in E} y_e \cdot 2 \\
    &amp;= 2 \cdot \mathrm{OPT}_{\text{dual}} \\
    &amp;\le 2 \cdot \mathrm{OPT}
\end{aligned}
\]</span> （正如之前所说，对偶规划的目标函数给我们提供了<span class="math inline">\(\mathrm{OPT}\)</span>的一个极佳的下界）</p>
<p>得证。</p>
<p>（后记：其实对偶解的最优性在这里并没有用到，是不是每一组对偶规划的极大解都可以呢？）</p>
<h1 id="单机任务调度">单机任务调度</h1>
<h2 id="定义">定义</h2>
<p><strong>输入：</strong>一台机器<span class="math inline">\(n\)</span>个任务，第<span class="math inline">\(i\)</span>个任务的发布时间是<span class="math inline">\(r_i\)</span>，耗时<span class="math inline">\(p_i\)</span>。</p>
<p><strong>目标：</strong>设第<span class="math inline">\(i\)</span>个任务的完成时刻为<span class="math inline">\(C_i\)</span>，要求制定一个非竞争性（non-preemptive）的任务调度方案，使得<span class="math inline">\(\sum_{i=1}^nC_i\)</span>最小。所谓非竞争性，是指一个任务一旦开始就不能被其他任务所打断，不能够一个任务做一会暂停再去做另一个任务，与其相对的成为竞争性调度。</p>
<h2 id="思路与算法">思路与算法</h2>
<p>我们不妨先考虑如果允许竞争性调度，我们应该怎么办呢？</p>
<p>一个显然的策略是<strong>不断选取剩余耗时最短的任务优先完成</strong>，这样其他任务等待的时间最少。</p>
<p>注意到，一个非竞争性的调度方案可以在允许竞争的情况下应用，而反之未必然。因此，若设<span class="math inline">\(C_i^{\text P}\)</span>为在最优竞争性调度中任务<span class="math inline">\(i\)</span>的结束时刻，那么就有 <span class="math display">\[
\sum_{i=1}^n C^{\text P}_i \le \mathrm{OPT}
\]</span> 一个竞争性的方案可以被转化为一个非竞争性的方案吗？这就是我们的算法：</p>
<ol type="1">
<li>求解在允许竞争的情况下的最优调度方案。</li>
<li>按照任务在竞争性最优调度中结束的顺序确定我们解当中各任务的执行顺序，并基于这个顺序给出我们非竞争性的调度方案。</li>
</ol>
<h2 id="分析">分析</h2>
<p>设<span class="math inline">\(C_i^{\text N}\)</span>为我们的非竞争性调度中任务<span class="math inline">\(i\)</span>的结束时刻，那我们方案的代价就是<span class="math inline">\(\sum_{i=1}^n C^{\text N}_i\)</span>。</p>
<p>接下来假设我们已经按照任务在竞争性最优调度当中结束的顺序给任务排了序。</p>
<p>注意到 <span class="math display">\[
C^{\text N}_i \le \max_{1 \le k \le i} \{r_k\}+ \sum_{k=1}^i p_k
\]</span> 这是显然的，因为不等式的右边描述了一种可行的调度方案：等前<span class="math inline">\(i\)</span>个任务全部发布后再连续把它们做完，而我们的方案不会比这个可行方案差。</p>
<p>令任务<span class="math inline">\(l\)</span>为前<span class="math inline">\(i\)</span>个任务当中最晚发布的那个任务，即<span class="math inline">\(r_l = \max_{1\le k \le i}\{r_k\}\)</span>。因为我们是按照竞争性最优方案中任务结束的顺序调度的，因此<span class="math inline">\(C_i^{\text P} \ge C_l^{\text P}\)</span>。常识告诉我们<span class="math inline">\(C_l^{\text P} \ge r_l\)</span>，因此<span class="math inline">\(C_i^{\text P} \ge r_l\)</span>。而显然又有<span class="math inline">\(C_i^{\text P} \ge \sum_{k=1}^i p_k\)</span>，因此 <span class="math display">\[
C^{\text N}_i \le \max_{1 \le k \le i} \{r_k\}+ \sum_{k=1}^i p_k \le C_i^{\text P} + C_i ^{\text P} = 2C_i^{\text P}
\]</span> 因此 <span class="math display">\[
\sum_{i=1}^n C^{\text N}_i \le 2\sum_{i=1}^n C^{\text P}_i \le 2\cdot \mathrm{OPT}
\]</span> 所以我们的算法是一个<span class="math inline">\(2\)</span>倍近似算法。</p>
<h2 id="拓展任务带权">拓展：任务带权</h2>
<p>我们现在对于这个问题进行拓展，每个任务都有一个权重<span class="math inline">\(w_i\)</span>，我们要最小化<span class="math inline">\(\sum_{i=1}^nw_iC_i\)</span>。</p>
<p>对于这个问题，我们上面的思路就行不通了：我们上面的算法建立在可以最优求解竞争性调度的基础上，而可以证明，即使允许竞争，求解带权任务调度也是一个NP hard问题。</p>
<p>因此我们必须换一个思路，考虑给我们的问题放宽一下条件，再以这个松弛的问题为基础建立一个线性规划（LP-relaxation）。很容易就能想到如下的线性规划： <span class="math display">\[
\begin{aligned}
    \text{minimize}\quad &amp;\sum_{i=1}^n w_iC_i \\
    \text{subject to}\quad &amp;C_i \ge r_i + p_i\quad \forall i=1,2,\cdots,n \\
    &amp;C_i \ge 0\quad \forall i=1,2,\cdots,n
\end{aligned}
\]</span> 可是这个线性规划一看就松到了一个扯淡的地步。是个人就知道这个规划的最优解就是<span class="math inline">\(C_i=r_i+p_i\)</span>，我们完全不能够指望这个破规划给我们任何有意义的结果或指引我们进行算法设计。我们还要加点条件——多多少少要体现出任务的非竞争性吧？</p>
<p>于是就有了这个加强版的线性规划： <span class="math display">\[
\begin{aligned}
    \text{minimize}\quad &amp;\sum_{i=1}^n w_iC_i \\
    \text{subject to}\quad &amp;C_i \ge r_i + p_i\quad \forall i=1,2,\cdots,n \\
    &amp; \sum_{i\in S}p_iC_i \le \frac{1}{2}p(S)^2 \quad \forall S\subseteq \{1,2,\cdots. m\}\\
    &amp;C_i \ge 0\quad \forall i=1,2,\cdots,n
\end{aligned}
\]</span> 其中<span class="math inline">\(p(S) = \sum_{i \in S} p_i\)</span>。</p>
<p>这个第二个约束是怎么一回事呢？考虑所有任务都在一开始就发布，然后任务时间无缝衔接的情况。此时一个任务的完成时间就等于之前所有任务耗时之和。为方便起见，不妨令<span class="math inline">\(S=\{p_1,p_2,p_3,\cdots,p_{|S|}\}\)</span>，于是有 <span class="math display">\[
\begin{aligned}
    \sum_{i = 1}^{|S|} p_iC_i &amp;=  \sum_{i = 1}^{|S|} p_i\sum_{j=1}^i p_j \\
    &amp;= \sum_{i = 1}^{|S|} p_i^2 +\sum_{i = 1}^{|S|} p_i\sum_{j=1}^{i-1} p_j \\
    &amp;= \frac{1}{2}\left(\sum_{i = 1}^{|S|} p_i^2 + 2\sum_{i = 1}^{|S|} p_i\sum_{j=1}^{i-1} p_j\right) + \frac{1}{2}\sum_{i = 1}^{|S|} p_i^2 \\
    &amp;= \frac{1}{2}\left(\sum_{i = 1}^{|S|} p_i\right)^2+ \frac{1}{2}\sum_{i = 1}^{|S|} p_i^2 \\
    &amp;\ge \frac{1}{2}p(S)^2
\end{aligned}
\]</span></p>
<p>若嫌代数证明太不直观，则下图在几何上说明了这一点：</p>
<p><img src="/2020/07/12/PACT0708/C1.svg" class=""></p>
<p>在实际的调度当中，几个任务未必无缝衔接，因此<span class="math inline">\(C_i \ge \sum_{j=1}^i p_j\)</span>，而我们的证明依然成立。因此对于可行的非竞争性调度，以上约束总是成立。虽反之不然，却也比一开始那个过于简陋的线性规划更多地刻画了“非竞争性”的特点。对于我们的算法来说，这个线性规划已经足够。我们的算法为：</p>
<ol type="1">
<li>求解以上线性规划。</li>
<li>假设给出的解为<span class="math inline">\(C_i^*\)</span>，我们按照<span class="math inline">\(C_i^*\)</span>从小到大来确定各任务在我们调度方案中的顺序。</li>
</ol>
<p>接下来我们分析一下这个算法。因为我们的线性规划对原问题进行松弛，原问题的解一定是线性规划的一组可行解，因此 <span class="math display">\[
\sum_{i=1}^n w_iC_i^* \le \mathrm{OPT}
\]</span> 回顾我们在不带权情形的算法分析中用到的 <span class="math display">\[
C^{\text N}_i \le \max_{1 \le k \le i} \{r_k\}+ \sum_{k=1}^i p_k
\]</span> 若令<span class="math inline">\(S=\{1,2,3,\cdots,i\}\)</span>，则上式可以写作 <span class="math display">\[
C^{\text N}_i \le \max_{1 \le k \le i} \{r_k\}+ p(S)
\]</span> 结合线性规划的第一个约束： <span class="math display">\[
C^{\text N}_i \le C_i^*+ p(S)
\]</span> 线性规划的第二个约束告诉我们 <span class="math display">\[
p(S)^2 \le 2\sum_{j=1}^i w_jC_j^*
\]</span> 因为<span class="math inline">\(i\)</span>是前<span class="math inline">\(i\)</span>个任务当中最后完成的，因此<span class="math inline">\(C_i^*\ge C_j^*,\forall j&lt;i\)</span>，于是 <span class="math display">\[
\begin{aligned}
    p(S) &amp;\le 2\sum_{j=1}^i w_jC_j^* \\
    &amp;\le 2\sum_{j=1}^i w_jC_i^* \\
    &amp;\le 2C_i^* p(S) \\
    \Rightarrow p(S) &amp;\le  2C_i^*
\end{aligned}
\]</span> 因此 <span class="math display">\[
C_i^{\text N} \le 3C_i^* \Rightarrow \sum_{i=1}^nC_i^{\text N} \le 3\sum_{i=1}^nC_i^* \le 3\cdot\mathrm{OPT}
\]</span> 我们便证明了我们的算法是一个<span class="math inline">\(3\)</span>倍近似算法。</p>
<p>整个算法唯一剩下的一个小问题便是：我们要解的这个线性规划的约束数量是指数级的，我们解线性规划所需要的时间难道不会变成指数级吗？事实上，有一类椭圆形法可以在多项式时间内解线性规划的同时处理这些子集约束，所以这个问题我们并不用担心。（具体的内容大概会在明天讲到吧）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2020/07/10/%E8%AF%84%E8%AE%BA%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/10/%E8%AF%84%E8%AE%BA%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">评论测试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-07-10 11:47:25 / 修改时间：11:51:30" itemprop="dateCreated datePublished" datetime="2020-07-10T11:47:25+08:00">2020-07-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>刚刚启用了博客的评论功能，基于Valine。本帖用于测试（如果后续更换评论系统，则依然使用本帖进行测试）</p>
<p>（真的会有人评论吗？）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chengyuan Ma</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js" integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha512-br8H6OngKoLht57WKRU5jz3Vr0vF+Tw4G6yhNN2F3dSDheq4JiaasROPJB1wy7PxPk7kV/+5AIbmoZLxxx7Zow==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-bash.min.js" integrity="sha512-JvRd44DHaJAv/o3wxi/dxhz2TO/jwwX8V5/LTr3gj6QMQ6qNNGXk/psoingLDuc5yZmccOq7XhpVaelIZE4tsQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-c.min.js" integrity="sha512-T6Lco61aWqCKSznWkd38lf159pD0+EwZ9UCEv6ARAvaWFiy/UHtYgOmlasT8lq5Ck17ZNHzbe5eHUablTGRXxw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cmake.min.js" integrity="sha512-M99z3be36IUB5pA3DWoJvjSYaZA9BiUqf1jXzVcjntASBZFNI53oDRzdJqGzH5voybcAx5Sg8F5QyryE6afD3g==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cpp.min.js" integrity="sha512-hxZJ6OUEpUl9/o4C1gMGvrAbeqDaldBiZbs08c/V8NcU7YImBFlqJAc7Uzjf3bh2W8Wx26/dVDyPk9cUMQY0Mw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-go.min.js" integrity="sha512-SgF1uayJ2/8TV+MhLasqygnm++vYRXswmrR2ZAmUCL4pXtf+6KzUgXPpn10Y6xca658sxOQEOsoP3MChfhke5A==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-java.min.js" integrity="sha512-PWHY6Vao4E9K4LsGBYCY0ttDeiWZwuUozTbJvSy9UFHRz2J4Bl7rcWML3wEnJTVuCJhSwGne/8My5gTo/gnbpg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-json.min.js" integrity="sha512-IC7rV8RslChgByOdUFC6ePqOGn+OwJhnKC3S5AezM8DAiOdGhJMwgsIvBChsa2yuxxoPbH2+W/kjNUM1cc+jUQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-kotlin.min.js" integrity="sha512-aTozTdtORp/xxS/dhRRDfmv/p1eyEMTje96MplkSOqdbKGGvOYIlogoGdtsh/BD91vaqKoAw9M7O/DodqqudIQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-julia.min.js" integrity="sha512-eTGeKQdDzC2rPAUVfM2Fa36s9B9wp138NEhzZqJpRSdJQ66BwLUot25r2YQveCRU5uYNVfX3gckDkl4byfBIWw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-latex.min.js" integrity="sha512-6D3l3Fy8g/hr6AeK2g1rcVZHyFjCqiqgUrwy0mBZTGFd8UwVcUDhzQeIIv3eYeXDecGPTtBOS9ctyRzJyUgypQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-rust.min.js" integrity="sha512-kgT7r2HlCEO4b+Rp3nJvm+/EMBwGMvv1WMdWkb3eNgnS91llMli8Y3T1CgnD8Hifqx50Q3XLUQXDd7PzKQQtUA==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-python.min.js" integrity="sha512-wK9tQmDrstGtZqTKcyVf3h457QGMlNriKs+fHmEkiCizrq0LVovfT3v1smeT1DlQetHhdRkkX1JSuZg5LoNHJg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-nginx.min.js" integrity="sha512-/MNzg8GlnVrAau/TZClh1jxgHNX0HDgidbGnHS5x1OtbKiNoK3e0XNd1oV16xmmeDHjisa3GKLArUau+43GZ4A==" crossorigin="anonymous"></script>
<script type = "text/javascript">
    document.addEventListener('pjax:complete', function() {
        if (typeof Prism !== 'undefined') {
            Prism.highlightAll();
        }
    });
</script>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  






  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    <div class="pjax">

  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



    </div>
</body>
</html>
