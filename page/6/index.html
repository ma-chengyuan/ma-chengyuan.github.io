<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"alan20210202.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="不务正业高中生一枚">
<meta property="og:type" content="website">
<meta property="og:title" content="Chengyuan Ma&#39;s Blog">
<meta property="og:url" content="https://alan20210202.github.io/page/6/index.html">
<meta property="og:site_name" content="Chengyuan Ma&#39;s Blog">
<meta property="og:description" content="不务正业高中生一枚">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chengyuan Ma">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://alan20210202.github.io/page/6/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.css" integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbggqjHJeyzx88I3rfwjS38WJag/ihH7lzuGlGHpDBymLirZQ==" crossorigin="anonymous" />
<title>Chengyuan Ma's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-65HSG5NCY6"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-65HSG5NCY6');
      }
    </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Chengyuan Ma's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-pagedewarp"><a href="/dewarp/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>PageDewarp</a></li>
        <li class="menu-item menu-item-english"><a href="/english/" rel="section"><i class="fa fa-globe-americas fa-fw"></i>English</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chengyuan Ma"
      src="/avatar.png">
  <p class="site-author-name" itemprop="name">Chengyuan Ma</p>
  <div class="site-description" itemprop="description">不务正业高中生一枚</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">94</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://kalasearch.cn/" title="https:&#x2F;&#x2F;kalasearch.cn&#x2F;" rel="noopener" target="_blank">卡拉搜索</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/PACT0701/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/PACT0701/" class="post-title-link" itemprop="url">PACT 07/01 任务调度问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-07-04 03:23:26" itemprop="dateModified" datetime="2020-07-04T03:23:26-04:00">2020-07-04</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="定义">定义</h1>
<p><strong>输入：</strong><span class="math inline">\(n\)</span>个任务，第<span class="math inline">\(i\)</span>个任务的运行时间为<span class="math inline">\(p_i\)</span>，共有<span class="math inline">\(m\)</span>个相同的机器（一个任务在每台机器上运行时间都相同）。每台机器同一时间只能运行一个任务，每个任务只能在一台机器上运行（不能拆分）。</p>
<p><strong>目标：</strong>合理地调度任务，使得完成所有任务的时间（makespan）最短。</p>
<h1 id="下界估计">下界估计</h1>
<p>自然而然地，我们首先思考<span class="math inline">\(\mathrm{OPT}\)</span>的下界。一个比较容易想到的下界是耗时最长的任务所需要的时间： <span class="math display">\[
\mathrm{OPT} \ge \max_{i} \{p_i\}
\]</span> 除此以外，考虑如果可以拆分任务，最短的运行时间是多少？自然是<span class="math inline">\(\frac{\sum_i p_i}{m}\)</span>，而这在现实中常常是做不到的，因此有： <span class="math display">\[
\mathrm{OPT} \ge \frac{\sum_i p_i}{m}
\]</span> 这两个下界对于之后的算法分析非常有用。</p>
<h1 id="算法">算法</h1>
<ol type="1">
<li>将所有的任务随机排成一列。</li>
<li>当一台机器完成了一个任务变得闲置了，马上把列表上的下一项任务安排到这个机器上去执行。</li>
<li>重复步骤2直至所有任务都被执行完毕。</li>
</ol>
<p>这个算法是非常简单且自然的。</p>
<h1 id="分析">分析</h1>
<p>我们算法给出结果的什么？自然是最后一个结束的任务的结束时间。如果我们设最后一个结束的任务为任务<span class="math inline">\(l\)</span>，且这个任务开始于<span class="math inline">\(s_l\)</span>，那么就有： <span class="math display">\[
\mathrm{Cost} = s_l+p_l
\]</span> 接下来我们进行放缩。</p>
<p>考虑<span class="math inline">\(s_l\)</span>的上界是什么？</p>
<p><img src="/2021/07/25/PACT0701/SIPM1.svg" class=""></p>
<p>很显然，<strong>在<span class="math inline">\(s_l\)</span>时刻，除了<span class="math inline">\(l\)</span>即将运行的那台机器，其他机器上必须有任务在运行或者刚刚空下来</strong>（如果有机器已经空了一阵子了，那当时<span class="math inline">\(l\)</span>就会被安排到那台机器上去跑），因此不难得出<span class="math inline">\(ms_l \le \sum_{i\neq l} p_i\)</span>，即 <span class="math display">\[
s_l \le \frac{\sum_{i \neq l}p_i}{m}
\]</span> 因此 <span class="math display">\[
\begin{aligned}
\mathrm{Cost} &amp;= s_l+p_l \\
&amp; \le \frac{\sum_{i \neq l}p_i}{m} + p_l \\
&amp;= \frac{\sum_{i}p_i}{m} + \left(1 - \frac{1}{m}\right) p_l \\
&amp;\le \frac{\sum_{i}p_i}{m} + \left(1 - \frac{1}{m}\right)\max_{i}\{p_i\} \\
&amp;\le \mathrm{OPT} + \left(1 - \frac{1}{m}\right)\mathrm{OPT} \\
&amp;= \left(2 - \frac{1}{m}\right)\mathrm{OPT}
\end{aligned}
\]</span> 我们就证明了我们的算法是一个<span class="math inline">\(2\)</span>倍近似算法！</p>
<h1 id="提升近似比">提升近似比</h1>
<p>能不能在这个算法的基础上提升呢？我们注意到将<span class="math inline">\(\mathrm{OPT}\)</span>作为<span class="math inline">\(p_l\)</span>的上界其实还是太松了。如果我们能够缩短<span class="math inline">\(p_l\)</span>，那上界的估计有没有改善的空间呢？</p>
<p>于是我们在原来算法的基础上不妨进行一个改进：与其在一开始将所有任务随机排列，不如<strong>将其按照运行时间从大到小的顺序进行排序</strong>。这也很符合直觉，一开始就把需要时间很长的任务跑完，之后肯定有些机器空着有些机器还在忙，这个时候就可以用完成时间比较短的小任务来灵活地填补这些空缺了。</p>
<p>这一下让近似比提升了多少呢？</p>
<p><strong>引理：</strong>加上排序之后的算法具有<span class="math inline">\(\frac{3}{2}\)</span>的近似比。</p>
<p><strong>证明：</strong>我们不妨分类讨论，</p>
<p><strong>情形1. </strong><span class="math inline">\(p_l \le \frac{1}{2}\mathrm{OPT}\)</span>，这个时候按照我们上文分析的路子走直接就可以得到<span class="math inline">\(\mathrm{Cost} \le \frac{3}{2}\mathrm{OPT}\)</span>，就做完了。</p>
<p><strong>情形2. </strong><span class="math inline">\(p_l &gt; \frac{1}{2}\mathrm{OPT}\)</span>，此时所有<span class="math inline">\(l\)</span>之前的任务也肯定具有大于<span class="math inline">\(\frac{1}{2} \mathrm{OPT}\)</span>的运行时间。注意到<strong>我们不需要考虑<span class="math inline">\(p_l\)</span>之后的任务</strong>，因为依据定义<span class="math inline">\(l\)</span>是最后结束的，后面的任务对于我们的结果没有影响。那<span class="math inline">\(l\)</span>之前的任务在最优调度里面是怎么样的呢？反证法可以很快说明：<strong>在最优调度里面，每一台机器至多只能处理一件任务</strong>（忽略<span class="math inline">\(l\)</span>之后的任务）！也就是说事实上<span class="math inline">\(l\)</span>以及之前的任务数目加起来不会超过机器数<span class="math inline">\(m\)</span>，那再想一想在这种机器充足的情况下，我们的算法在分配这些任务的时候也是一个机器一个任务，<span class="math inline">\(p_l\)</span>必定是从一开始就执行的，因此<span class="math inline">\(\mathrm{Cost}=p_l\)</span>，而显然<span class="math inline">\(\mathrm{OPT} \ge p_l\)</span>，因此必有<span class="math inline">\(\mathrm{Cost} = \mathrm{OPT}\)</span>，结束。（事实上，由于<span class="math inline">\(l\)</span>还是最后结束的任务，不难想通在一机器一任务的情形下，<span class="math inline">\(l\)</span>之前的所有任务都一定和<span class="math inline">\(l\)</span>花费相同的时间，或<span class="math inline">\(l\)</span>就是我们算法分配的第一个任务。）</p>
<p>综上所述，近似比是<span class="math inline">\(\frac{3}{2}\)</span>。</p>
<h1 id="进一步提升近似比">进一步提升近似比</h1>
<p>通过对于上述论证的些许修改，我们其实可以证明：</p>
<p><strong>引理：</strong>加上排序之后的算法具有<span class="math inline">\(\frac{4}{3}\)</span>的近似比。</p>
<p><strong>证明：</strong>我们故技重施：</p>
<p><strong>情形1. </strong><span class="math inline">\(p_l \le \frac{1}{3}\mathrm{OPT}\)</span>，这个时候我们直接就可以得到<span class="math inline">\(\mathrm{Cost} \le \frac{4}{3}\mathrm{OPT}\)</span>。</p>
<p><strong>情形2. </strong><span class="math inline">\(p_l &gt; \frac{1}{3}\mathrm{OPT}\)</span>，此时所有<span class="math inline">\(l\)</span>之前的任务也肯定具有大于<span class="math inline">\(\frac{1}{3} \mathrm{OPT}\)</span>的运行时间。我们同样不考虑<span class="math inline">\(l\)</span>之后的任务。可以通过反证证明：<strong>在最优调度里，每一台机器至多只能处理两件任务！</strong>因此，我们确定有足够的机器让我们的算法得以这样调度任务：</p>
<p><img src="/2021/07/25/PACT0701/SIPM2.svg" class=""></p>
<p>（看着是不是很像双指针？）</p>
<p>具体来说，如果我们把机器按照第一个任务的耗时降序排序，那么它们第二个任务的耗时一定成升序排列。（这并不难证明：第一个任务耗时最短的机器一定能够先领到列表中最长的任务作为第二个任务，之后的机器领到的任务时间递减）</p>
<p>（在这里我们假定<span class="math inline">\(l\)</span>一定是第二个任务，如果<span class="math inline">\(l\)</span>从头开始运行而且时间特别长的话，参考上一节的证明）</p>
<p>而接下来我们证明这样的分配方式是最优的。</p>
<p>我们采取反证的方法：不妨假设在最优方案中存在两个机器，两个机器上都有两个任务，耗时分别为<span class="math inline">\((a,b)\)</span>和<span class="math inline">\((c,d)\)</span>，且<span class="math inline">\(a&gt;c,b&gt;d\)</span>。那么我们把两个机器上的第二个任务互换，变成<span class="math inline">\((a,d)\)</span>和<span class="math inline">\((c,b)\)</span>，不难发现此时完成任务的最短时间会减少，和“最优”矛盾。因此，对于最优方案的任意两台机器<span class="math inline">\((a,b)\)</span>和<span class="math inline">\((c,d)\)</span>，如果<span class="math inline">\(a&gt;c\)</span>那么<span class="math inline">\(b&lt;d\)</span>：</p>
<p><img src="/2021/07/25/PACT0701/SIPM3.svg" class=""></p>
<p>这正是我们算法所给出的调度方案。因此<span class="math inline">\(\mathrm{OPT}\)</span>不会比我们算法的结果更好了。</p>
<p>综上所述，近似比为<span class="math inline">\(\frac{4}{3}\)</span>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/PACT0629/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/PACT0629/" class="post-title-link" itemprop="url">PACT 06/29 三大概率不等式以及近似算法初步</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-07-11 23:17:10" itemprop="dateModified" datetime="2020-07-11T23:17:10-04:00">2020-07-11</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概率论初步">概率论初步</h1>
<h2 id="期望的线性性">期望的线性性</h2>
<p><span class="math display">\[
\mathbb{E}[X+Y] = \mathbb E [X] + \mathbb E[Y]
\]</span></p>
<h2 id="随机变量的方差">随机变量的方差</h2>
<p><span class="math display">\[
\begin{aligned}
    \operatorname{Var}[X] &amp;:= \mathbb{E}\left[\left(X-\mathbb{E}[X]\right)^2\right] \\
    &amp;= \mathbb{E} \left[X^2 - 2\mathbb{E}[X]X+\mathbb{E}[X]^2\right] \\
    &amp;= \mathbb{E} \left[X^2\right] - 2\mathbb{E}[X]^2 + \mathbb{E}[X]^2 \\
    &amp;= \mathbb{E} \left[X^2\right] - \mathbb{E}[X]^2
\end{aligned}
\]</span></p>
<p><strong>推论：</strong>若随机变量<span class="math inline">\(X,Y\)</span>互相独立，则有：</p>
<ol type="1">
<li><span class="math inline">\(\operatorname{Var}[X+Y] = \operatorname{Var}[X] + \operatorname{Var}[Y]\)</span></li>
<li><span class="math inline">\(\mathbb{E}[XY] = \mathbb{E}[X]\mathbb{E}[Y]\)</span></li>
</ol>
<p>（互相独立的定义：<span class="math inline">\(\forall x, y, \operatorname{Pr}[X=x\cap Y=y]=\operatorname{Pr}[X=x]\operatorname{Pr}[Y=y]\)</span>）</p>
<h2 id="马尔科夫不等式">马尔科夫不等式</h2>
<p>设<span class="math inline">\(X\)</span>为<strong>非负</strong>随机变量，则<span class="math inline">\(\forall a &gt;0\)</span>： <span class="math display">\[
\operatorname{Pr}[X\ge a] \le \frac{\mathbb{E}[X]}{a}
\]</span> <strong>证明：</strong> <span class="math display">\[
\begin{aligned}
    \mathbb{E}[X] &amp;= \sum_{x}x\operatorname{Pr}[X=x] \\
    &amp;= \sum_{x&lt;a}x\operatorname{Pr}[X=x] + \sum_{x\ge a}x\operatorname{Pr}[X=x] \\
    &amp;\ge \sum_{x\ge a}x\operatorname{Pr}[X=x] \\
    &amp;\ge \sum_{x\ge a}a\operatorname{Pr}[X=x] \\
    &amp;= a \sum_{x\ge a}\operatorname{Pr}[X=x] \\
    &amp;= a \operatorname{Pr}[X\ge x]
\end{aligned}
\]</span> （离散形式，连续形式的证明方法类似）</p>
<p>其中第一个<span class="math inline">\(\ge\)</span>依赖于<span class="math inline">\(X\)</span>非负的特性，因此非负是必须的！</p>
<p>马尔科夫不等式让我们可以在只知道随机变量期望的情况下对于其分布概率进行粗略定界。</p>
<h2 id="切比雪夫不等式">切比雪夫不等式</h2>
<p>设<span class="math inline">\(X\)</span>为随机变量，则<span class="math inline">\(\forall a &gt; 0\)</span>： <span class="math display">\[
\operatorname{Pr}\left[|X-\mathbb{E}[X]| \ge a\right] \le \frac{\operatorname{Var}[X]}{a^2}
\]</span> <strong>证明：</strong> <span class="math display">\[
\begin{aligned}
    \operatorname{Pr}\left[|X-\mathbb{E}[X]| \ge a\right] &amp;= \operatorname{Pr}\left[(X-\mathbb{E}[X])^2 \ge a^2\right] \\
    &amp;\le \frac{\mathbb{E}\left[(X-\mathbb{E}[X])^2\right]}{a^2} \\
    &amp;= \frac{\operatorname{Var}[X]}{a^2}
\end{aligned}
\]</span> 注意到<span class="math inline">\(a^2&gt;0\)</span>且<span class="math inline">\((X-\mathbb{E}[X])^2\)</span>非负，因此我们可以在第二步使用马尔科夫不等式。</p>
<p>如果我们不仅知道随机变量的期望（一阶矩），还知道其方差（二阶矩），那么切比雪夫不等式可以给出比马尔科夫不等式更为精确的上界。</p>
<h2 id="切尔诺夫上界chernoff-bound">切尔诺夫上界（Chernoff Bound）</h2>
<p>设随机变量<span class="math inline">\(X=\sum_{i=1}^n X_i\)</span>，其中<span class="math inline">\(X_1,\cdots,X_n\)</span>为<span class="math inline">\([0,1]\)</span>上互相独立的随机变量，则<span class="math inline">\(\forall t&gt;1\)</span>： <span class="math display">\[
\operatorname{Pr}\left[|X - \mathbb{E}[X]| \ge t\mathbb{E}[X]\right] \le 2\exp\left(-\frac{t\mathbb{E}[X]}{3}\right)
\]</span> 且<span class="math inline">\(\forall \epsilon \in (0,1]\)</span>： <span class="math display">\[
\operatorname{Pr}\left[|X - \mathbb{E}[X]| \ge \epsilon\mathbb{E}[X]\right] \le 2\exp\left(-\frac{\epsilon^2\mathbb{E}[X]}{3}\right)
\]</span> <em>加性切尔诺夫不等式（Additive Chernoff Bound）</em>：<span class="math inline">\(\forall b &gt;1\)</span>： <span class="math display">\[
\operatorname{Pr}\left[|X - \mathbb{E}[X]| \ge b\right] \le 2\exp\left(-\frac{2b^2}{n}\right)
\]</span></p>
<h2 id="三个不等式给出上界的比较">三个不等式给出上界的比较</h2>
<p>考虑如下问题：投<span class="math inline">\(n\)</span>次均质硬币，设随机变量<span class="math inline">\(X\)</span>表示头朝上的次数。估计<span class="math inline">\(\operatorname{Pr}\left[X\ge \frac{3n}{4}\right]\)</span>？</p>
<p><strong>马尔科夫不等式：</strong></p>
<p>显然，<span class="math inline">\(\mathbb{E}[X]=\frac{n}{2}\)</span>，且<span class="math inline">\(X\)</span>非负： <span class="math display">\[
\operatorname{Pr}\left[X\ge \frac{3n}{4}\right] \le \frac{\frac{n}{2}}{\frac{3n}{4}} = \frac{2}{3}
\]</span> 这个上界是很松的。</p>
<p><strong>切比雪夫不等式：</strong></p>
<p>设随机二元变量<span class="math inline">\(X_i\)</span>表示第<span class="math inline">\(i\)</span>次投是否头朝上，则显然<span class="math inline">\(X=\sum_{i=1}^nX_i\)</span>，且易得<span class="math inline">\(\operatorname{Var}[X_i]=\frac{1}{4}\)</span>，由于<span class="math inline">\(X_i\)</span>两两独立，则<span class="math inline">\(\operatorname{Var}[X]=\frac{n}{4}\)</span>，运用切比雪夫不等式： <span class="math display">\[
\begin{aligned}
    \operatorname{Pr}\left[X\ge \frac{3n}{4}\right] &amp;= \operatorname{Pr}\left[X - \frac{n}{2}\ge \frac{n}{4}\right] \\
    &amp;= \frac{1}{2}\operatorname{Pr}\left[\left|X - \frac{n}{2}\right|\ge \frac{n}{4}\right] \\
    &amp;= \frac{1}{2}\operatorname{Pr}\left[\left|X - \mathbb{E}[X]\right|\ge \frac{n}{4}\right] \\
    &amp;\le \frac{1}{2} \frac{\frac{n}{4}}{\left(\frac{n}{4}\right)^2} \\
    &amp;= \frac{2}{n}
\end{aligned}
\]</span> <strong>切尔诺夫上界：</strong></p>
<p>显然，取<span class="math inline">\(\epsilon = \frac{1}{2}\)</span>： <span class="math display">\[
\begin{aligned}
    \operatorname{Pr}\left[X\ge \frac{3n}{4}\right] &amp;= \operatorname{Pr}\left[X - \frac{n}{2}\ge \frac{n}{4}\right] \\
    &amp;= \frac{1}{2}\operatorname{Pr}\left[\left|X - \frac{n}{2}\right|\ge \frac{n}{4}\right] \\
    &amp;= \frac{1}{2}\operatorname{Pr}\left[\left|X - \mathbb{E}[X]\right|\ge \frac{1}{2}\mathbb{E}[X]\right] \\
    &amp;\le \exp\left(-\frac{1}{12}\cdot \frac{n}{2}\right)\\
    &amp;= \exp\left(-\frac{n}{24}\right)
\end{aligned}
\]</span> 各上界的效果：</p>
<p><img src="/2021/07/25/PACT0629/Bounds.png" class=""></p>
<p>看来这个例子里面还是切比雪夫不等式给出的上界最好——是不是切尔诺夫上界我学到的形式本身太loose了？</p>
<h1 id="近似算法初步">近似算法初步</h1>
<h2 id="定义">定义</h2>
<p>若算法<span class="math inline">\(A\)</span>满足以下条件，则称算法<span class="math inline">\(A\)</span>是某个问题（不妨假设是最小化问题）的<span class="math inline">\(\alpha\)</span>近似比的近似算法：</p>
<ol type="1">
<li><span class="math inline">\(A\)</span>是多项式时间的。</li>
<li>对于所有输入，<span class="math inline">\(A\)</span>的输出<span class="math inline">\(\operatorname{soln}(A) \le \alpha \cdot\mathrm{OPT}\)</span>，其中<span class="math inline">\(\mathrm{OPT}\)</span>是该输入的最优解。</li>
</ol>
<p><em>对于最大化问题，第二个条件为<span class="math inline">\(\operatorname{soln}(A) \ge \frac{1}{\alpha} \cdot\mathrm{OPT}\)</span></em>。</p>
<p>（继续假设是最小化问题）</p>
<p>显然，为了精确计算<span class="math inline">\(\alpha\)</span>我们必须知道<span class="math inline">\(\mathrm{OPT}\)</span>，而这显然是不现实的（如果可以我还要近似算法干嘛？），因此我们退而求其次寻找<span class="math inline">\(\mathrm{OPT}\)</span>的一个比较紧的<strong>下界</strong>，我们的解与该下界之比自然就是<span class="math inline">\(\alpha\)</span>的上界了。</p>
<h2 id="例最小顶点覆盖问题">例：最小顶点覆盖问题</h2>
<p><strong>输入：</strong><span class="math inline">\(G=(V,E)\)</span></p>
<p><strong>目标：</strong>最小化点集<span class="math inline">\(S\subseteq V\)</span>，同时满足<span class="math inline">\(\forall (u,v) \in E\)</span>，<span class="math inline">\(u\in S\)</span>或<span class="math inline">\(v \in S\)</span>。</p>
<p>这是一个知名的NP Complete问题。在这里我们设计一个简单的<span class="math inline">\(2\)</span>近似算法。然而令人吃惊地是，<span class="math inline">\(2\)</span>的近似比已经是我们目前能够做到的最好结果！</p>
<p><strong>思路：</strong>考虑<span class="math inline">\(G\)</span>的一个<strong>极大匹配</strong>，显然极大匹配是可以在多项式时间内求出的。</p>
<p>同时注意到，任意无向图极大匹配的大小必定是其点覆盖集大小的下界，因为点覆盖必须取极大匹配当中每一条边的至少一个端点才能完成覆盖！</p>
<p><strong>算法：</strong></p>
<ol type="1">
<li>计算<span class="math inline">\(G\)</span>的一个极大匹配<span class="math inline">\(M\)</span>。</li>
<li>取极大匹配所有边的所有端点为<span class="math inline">\(S\)</span>。</li>
</ol>
<p><strong>为什么正确？</strong>考虑反证：若<span class="math inline">\(\exists (u,v) \in E\)</span>，使<span class="math inline">\(u\not\in S\)</span>且<span class="math inline">\(v \not \in S\)</span>，那显然边<span class="math inline">\((u, v)\)</span>还可以加入<span class="math inline">\(M\)</span>，这和<span class="math inline">\(M\)</span>的极大性是矛盾的。</p>
<p>近似比证明： <span class="math display">\[
\begin{aligned}
    |S| = 2|M| \le 2\cdot \mathrm{OPT}
\end{aligned}
\]</span> 得证。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/PACT0630/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/PACT0630/" class="post-title-link" itemprop="url">PACT 06/30 $k$中心问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-07-11 23:17:28" itemprop="dateModified" datetime="2020-07-11T23:17:28-04:00">2020-07-11</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="定义">定义</h1>
<p>定义所谓<span class="math inline">\(k\)</span>中心问题为：</p>
<p><strong>输入：</strong>完全图<span class="math inline">\(G=(V,E)\)</span>，边带正权，且满足三角不等式<span class="math inline">\(w_{uv} \le w_{uk} + w_{kv}\)</span>，以及一个正整数<span class="math inline">\(k\)</span>。</p>
<p><strong>目标：</strong>求一个点集<span class="math inline">\(|S|=k\)</span>（称为<span class="math inline">\(k\)</span>个中心），定义一个点到一个点集的距离 <span class="math display">\[
d(u,S) = \min_{v\in S} w_{uv}
\]</span> （显然，如果满足三角不等式，那么任意两点之间的最短距离就是直接连接两点的边权）</p>
<p>要求最小化<span class="math inline">\(\max_{u\in V} d(u,S)\)</span>。即所有顶点到这<span class="math inline">\(k\)</span>个中心的<strong>最短路程的最大值</strong>（不妨称之为这个这个<span class="math inline">\(k\)</span>中心的<strong>代价</strong>）最小。</p>
<h1 id="近似算法1gonzalez">近似算法1（Gonzalez）</h1>
<h2 id="算法">算法</h2>
<ol type="1">
<li>任意选取一个顶点并将其加入<span class="math inline">\(S\)</span>。</li>
<li>选取离当前<span class="math inline">\(S\)</span>最远的顶点加入<span class="math inline">\(S\)</span>。</li>
<li>重复步骤2直至<span class="math inline">\(|S|=k\)</span>。</li>
</ol>
<p>第2步的操作是非常合乎直觉的：如果不把离<span class="math inline">\(S\)</span>最远的顶点加入<span class="math inline">\(S\)</span>的话，这条最远的边权就可能会被计入答案当中，这显然是不合算的，而如果将这个最远点作为新的中心，那么这条最远边就必定不会被计入答案。</p>
<h2 id="分析">分析</h2>
<p>这个算法给出方案的代价是什么？在这个算法的背景下，我们不妨说：<em>这个算法结果的代价是如果不跳出循环，下一个选取的中心到当前<span class="math inline">\(S\)</span>的距离</em>（依据第2步）。假设这个中心为<span class="math inline">\(x\)</span>，我们不妨画图：</p>
<p><img src="/2021/07/25/PACT0630/Analysis1.jpg" class=""></p>
<p>其中左边的<span class="math inline">\(S\)</span>是我们的解，右边是最优解（我们这里把他们化成了不重叠的形式，事实上有重叠对于我们的论证也不造成影响）。</p>
<p>我们的解加上<span class="math inline">\(x\)</span>总共有<span class="math inline">\(k+1\)</span>个点，最优解有<span class="math inline">\(k\)</span>个点，因此由抽屉原理，至少左边有两个点，它们在最优解中的最近点是相同的（即图中的两条横叉边），且由于是最优解，两条边的长度都<span class="math inline">\(\le \mathrm{OPT}\)</span>。</p>
<p>不妨设这两个点为<span class="math inline">\(u,v\)</span>，由三角不等式，可以得出<span class="math inline">\(w_{uv}\le2\cdot\mathrm{OPT}\)</span>。</p>
<p>接下来不妨假设<span class="math inline">\(u,v\)</span>中的后来者为<span class="math inline">\(v\)</span>，为什么当时我们选择<span class="math inline">\(v\)</span>而不是<span class="math inline">\(x\)</span>加入<span class="math inline">\(S\)</span>呢？肯定是因为当时<span class="math inline">\(d(v,S)\ge d(x,S)\)</span>。而由<span class="math inline">\(d(v,S)\)</span>的定义可知，<span class="math inline">\(d(v,S)\le w_{uv}\)</span>，且由于随着<span class="math inline">\(S\)</span>的变大，<span class="math inline">\(d(x,S)\)</span>不增，因此我们解的代价（即现在的<span class="math inline">\(d(x,S)\)</span>）一定也是不大于当时的<span class="math inline">\(d(v,S)\)</span>。将这些不等式串联起来，便得到： <span class="math display">\[
d(x,S) \le w_{uv} \le 2\cdot \mathrm{OPT}
\]</span> 也就是说这个算法的近似比为<span class="math inline">\(2\)</span>。</p>
<h1 id="近似算法2hochbaum-shmoys">近似算法2（Hochbaum &amp; Shmoys）</h1>
<h2 id="算法-1">算法</h2>
<p>我们不妨<strong>假设我们已经知道了最优解的代价</strong><span class="math inline">\(\mathrm{OPT}\)</span>，那么我们要怎么做呢？</p>
<ol type="1">
<li>我们选取任意顶点<span class="math inline">\(u_1\)</span>加入中心，并以为中心画一个半径为的球，钦定球内的所有点归<span class="math inline">\(u_1\)</span>。</li>
<li>我们接着选取一个在这个球以外的一个顶点<span class="math inline">\(u_2\)</span>加入中心，并以<span class="math inline">\(u_2\)</span>为中心画一个半径为<span class="math inline">\(2\cdot \mathrm{OPT}\)</span>的球，钦定球里面的点归<span class="math inline">\(u_2\)</span>。</li>
<li>我们接着选取一个在<span class="math inline">\(u_1\)</span>和<span class="math inline">\(u_2\)</span>的球外的点<span class="math inline">\(u_3\)</span>作为中心……</li>
<li>重复上述步骤，直至图上的所有点都归一个至多<span class="math inline">\(2\cdot \mathrm{OPT}\)</span>远处的中心管。</li>
</ol>
<p>画在图上大概是这样的：</p>
<p><img src="/2021/07/25/PACT0630/HS.jpg" class=""></p>
<p>可以看到，可能会有点同时处在多个中心的“势力范围”之内，但这并不重要，我们只需要确保每个点离最近的一个中心至多<span class="math inline">\(2\cdot \mathrm{OPT}\)</span>那么远就行了。</p>
<h2 id="分析-1">分析</h2>
<p>我们接下来证明这是一个<span class="math inline">\(2\)</span>近似算法。算法本身的流程确保了<span class="math inline">\(2\)</span>的近似比，因此唯一需要证明的就是这个算法产生的中心不超过要求的<span class="math inline">\(k\)</span>个。</p>
<p>不妨反证：如果产生了超过<span class="math inline">\(k\)</span>个中心呢？</p>
<p><img src="/2021/07/25/PACT0630/Analysis2.jpg" class=""></p>
<p>那么根据抽屉原理，至少有两个中心在最优解中的最近点是相同的（这和我们分析第一个算法时的逻辑是完全相同的），由三角不等式，这两个中心之间的距离<span class="math inline">\(\le 2\cdot \mathrm{OPT}\)</span>。但是根据算法，中心之间两两距离应该大于<span class="math inline">\(2\cdot \mathrm{OPT}\)</span>，这就产生了矛盾。</p>
<p>因此必定不会有超过<span class="math inline">\(k\)</span>个中心，证毕。</p>
<p>还剩下来一个问题：这个算法假定我们知道<span class="math inline">\(\mathrm{OPT}\)</span>，但是实际上我们不知道啊！</p>
<p>但是我们知道<span class="math inline">\(\mathrm{OPT}\)</span><em>一定是某一条边的边权</em>，因此我们只需要按边权从小到大<strong>枚举每一条边，把边权当做<span class="math inline">\(\mathrm{OPT}\)</span>试试看</strong>，如果产生超过<span class="math inline">\(k\)</span>个中心那必然不是<span class="math inline">\(\mathrm{OPT}\)</span>（这是我们推论的逆否），而反之则可能就是<span class="math inline">\(\mathrm{OPT}\)</span>（但无论如何，事实上是<span class="math inline">\(\mathrm{OPT}\)</span>的那条边一定是没有问题的）。因为我们在这里只在意是否是多项式时间复杂度而不在意复杂度本身，而枚举边自然是多项式时间的，因此没有任何问题（当然，在实现过程中可以考虑使用二分，但这就是后话了）。</p>
<h1 id="近似比可以更好吗">近似比可以更好吗？</h1>
<p><strong>定理：</strong>如果存在一个多项式时间的，近似比<span class="math inline">\(&lt;2\)</span>的<span class="math inline">\(k\)</span>中心问题的近似算法，那么<span class="math inline">\(\mathsf{P}=\mathsf{NP}\)</span>。</p>
<p><strong>证明：</strong>考虑<em>最小支配集问题</em>的判定形式：</p>
<p><strong>输入：</strong>无向图<span class="math inline">\(G=(V,E)\)</span>以及正整数<span class="math inline">\(k\)</span>。</p>
<p><strong>判定：</strong>是否存在一个大小为<span class="math inline">\(k\)</span>的支配集？支配集定义为一个点集<span class="math inline">\(S\subseteq V\)</span>，使得<span class="math inline">\(\forall u\in V\)</span>，要么<span class="math inline">\(u\in S\)</span>或者<span class="math inline">\(u\)</span>的邻居<span class="math inline">\(\in S\)</span>。</p>
<p>最小支配集问题是NPC的。我们接下来将其规约到<span class="math inline">\(k\)</span>中心问题（也是判定形式）：</p>
<p><strong>输入：</strong>完全图<span class="math inline">\(G&#39;\)</span>，正整数<span class="math inline">\(k,b\)</span>。</p>
<p><strong>判定：</strong>是否存在一个代价<span class="math inline">\(\le b\)</span>的<span class="math inline">\(k\)</span>中心的方案？</p>
<p>如何规约？不难想到，我们可以让<span class="math inline">\(G\)</span>与<span class="math inline">\(G&#39;\)</span>用相同的点集，而对于所有在<span class="math inline">\(G\)</span>中的边，其在<span class="math inline">\(G&#39;\)</span>中的边权为<span class="math inline">\(1\)</span>。而对于所有不在<span class="math inline">\(G\)</span>中的边，其在<span class="math inline">\(G&#39;\)</span>中的边权为<span class="math inline">\(2\)</span>（为什么是<span class="math inline">\(2\)</span>？直觉上我们会首先想到<span class="math inline">\(\infty\)</span>，但是这样就不满足三角不等式了，因此改成<span class="math inline">\(2\)</span>）。令两个问题当中的<span class="math inline">\(k\)</span>相等，且<span class="math inline">\(b=1\)</span>，我们就完成了规约。</p>
<p>为什么？</p>
<p>在这样的规约下，一个在<span class="math inline">\(G\)</span>中的支配集必然对应一个<span class="math inline">\(G&#39;\)</span>当中代价为<span class="math inline">\(1\)</span>的相同大小的<span class="math inline">\(k\)</span>中心，反之亦然。</p>
<p>也就是说，如果我们可以解决这个规约后的<span class="math inline">\(k\)</span>中心问题，那么我们就能解决原来的最小支配集问题了。</p>
<p>这个时候就可以看出为什么近似比<span class="math inline">\(&lt;2\)</span>的近似算法牛逼了：</p>
<ol type="1">
<li>如果<span class="math inline">\(G\)</span>当中有符合要求的支配集，那么<span class="math inline">\(k\)</span>中心的<span class="math inline">\(\mathrm{OPT}=1\)</span>，而由于近似比<span class="math inline">\(&lt;2\)</span>且边权只有<span class="math inline">\(1,2\)</span>，因此即使是近似算法也会次次给出<span class="math inline">\(1\)</span>。</li>
<li>如果<span class="math inline">\(G\)</span>当中没有符合要求的支配集，那么<span class="math inline">\(k\)</span>中心的<span class="math inline">\(\mathrm{OPT} = 2\)</span>，而由于近似比<span class="math inline">\(&lt;2\)</span>且边权只有<span class="math inline">\(1,2\)</span>，因此即使是近似算法也只能给出<span class="math inline">\(2\)</span>。</li>
</ol>
<p>如此说来，即使是近似算法，通过判断输出代价是<span class="math inline">\(1\)</span>还是<span class="math inline">\(2\)</span>我们就能判断<span class="math inline">\(G\)</span>中有没有大小<span class="math inline">\(k\)</span>的支配集。而这个近似算法是多项式时间的，因此我们可以用多项式时间解决支配集问题这么一个NPC问题，即<span class="math inline">\(P=NP\)</span>。</p>
<p>刚刚用到的这个技巧被称为“gap reduction”。</p>
<p>整个定理的言下之意就是如果你也相信<span class="math inline">\(\mathsf{P}\neq \mathsf{NP}\)</span>，那么就可以洗洗睡了~</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/NTT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/NTT/" class="post-title-link" itemprop="url">NTT笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2019-02-03 22:58:48" itemprop="dateModified" datetime="2019-02-03T22:58:48-05:00">2019-02-03</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>NTT的思想与FFT类似，但是避免了浮点数运算带来的精度问题。</p>
<h1 id="原根">原根</h1>
<p><strong>定义：</strong>设<span class="math inline">\(m &gt; 1\)</span>且<span class="math inline">\(\gcd(a, m) = 1\)</span>，使得<span class="math inline">\(a^d \equiv 1 \pmod m\)</span>的最小<span class="math inline">\(d\)</span>称为<span class="math inline">\(a\)</span>模<span class="math inline">\(m\)</span>的<strong>阶</strong>，记作<span class="math inline">\(d = \delta_m(a)\)</span>。</p>
<p><strong>定理：</strong>显然，对于所有<span class="math inline">\(a^d \equiv 1 \pmod m\)</span>，都有<span class="math inline">\(\delta_m(a) \mid d\)</span>。</p>
<p>同时根据欧拉定理我们有 <span class="math display">\[
a^{\varphi(m)} \equiv 1 \pmod m
\]</span> 因此有<span class="math inline">\(\delta_m(a) \mid \varphi(m)\)</span>。</p>
<p><strong>定义：</strong>若<span class="math inline">\(\delta_m(g) = \varphi(m)\)</span>则称<span class="math inline">\(g\)</span>为模<span class="math inline">\(m\)</span>意义下的<strong>原根</strong>。</p>
<p><span class="math inline">\(m​\)</span>存在原根当且仅当<span class="math inline">\(m = 2,4,p^n, 2p^n​\)</span>，其中<span class="math inline">\(p​\)</span>为奇素数，<span class="math inline">\(n \in \mathbb{Z}​\)</span>。</p>
<p><strong>原根的意义：</strong>如果<span class="math inline">\(m\)</span>存在原根<span class="math inline">\(g\)</span>，那<span class="math inline">\(g^0, g^1, g^2, \cdots, g^{\varphi(m) - 1}\)</span>恰能表示所有<span class="math inline">\(\varphi(m)\)</span>个与<span class="math inline">\(m\)</span>互素的数，且构成<span class="math inline">\(m\)</span>的简化剩余系。</p>
<p><strong>原根的计算方法：</strong>原根只有<span class="math inline">\(\varphi(\varphi(m))\)</span>个，因此只要枚举即可。</p>
<h1 id="ntt">NTT</h1>
<p>NTT中使用单位原根代替单位复数根进行计算，单位原根定义为： <span class="math display">\[
g_n = g^{\varphi(p) / n} = g^{(p - 1)/n}
\]</span> 其中<span class="math inline">\(g\)</span>为模素数<span class="math inline">\(p\)</span>的原根。</p>
<p>显然<span class="math inline">\(g_n\)</span>有与单位负数根类似的性质： <span class="math display">\[
g_n^n = g^{p - 1} \equiv 1 \pmod p
\]</span> 又因为<span class="math inline">\(\left(g_n^{n / 2}\right)^2 \equiv 1 \pmod p\)</span>以及一些二次剩余的知识，<span class="math inline">\(g_n^{n / 2} \bmod p\)</span>只可能是<span class="math inline">\(\pm 1\)</span>，又因为原根的性质 <span class="math display">\[
g_n^{n / 2} \equiv -1 \pmod p
\]</span> 同时，观察<span class="math inline">\(g_n\)</span>的定义，易证<span class="math inline">\(g_{2n}^{2k} = g_n^k\)</span>（折半引理），原根具备所有FFT中利用的单位复数根的性质，因此也可以使用单位原根进行FFT，得到的算法就是NTT（Number Theoretic Transform），NTT适用于整数序列的变换，且精度与数值稳定性较FFT更优。</p>
<p>代码：</p>
<pre class="line-numbers"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;
const int MOD = 998244353;
const int N = 270000;
const int G = 3, INVG = 332748118;
typedef long long ll;
int n, m; 
ll a[N], b[N];

ll qpow(ll x, ll y) &#123;
    ll ret = 1;
    for (; y; y &gt;&gt;= 1) &#123;
        if (y &amp; 1) ret = ret * x % MOD;
        x = x * x % MOD;
    &#125;
    return ret;
&#125;

void ntt(int len, ll *x, int dir = 1) &#123;
    static ll X[N];
    for (int i = 0, k = 0; i &lt; len; i++) &#123;
        X[i] = x[k];
        int y = len &gt;&gt; 1;
        while (y &amp; k) k ^= y, y &gt;&gt;= 1;
        k |= y;
    &#125;
    for (int s = 2; s &lt;= len; s &lt;&lt;= 1) &#123;
        ll w_ = qpow(G, (MOD - 1) / s);
        if (dir == -1) w_ = qpow(w_, MOD - 2);
        for (int l = 0; l &lt; len; l += s) &#123;
            int mid = l + (s &gt;&gt; 1);
            ll w = 1;
            for (int i = 0; i &lt; s &gt;&gt; 1; i++) &#123;
                ll t = w * X[mid + i] % MOD;
                X[mid + i] = (X[l + i] - t) % MOD;
                X[l + i] = (X[l + i] + t) % MOD;
                w = w * w_ % MOD;
            &#125;
        &#125;
    &#125;
    copy(X, X + len, x);
&#125;

int main() &#123;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 0; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]);
    for (int i = 0; i &lt;= m; i++) scanf(&quot;%lld&quot;, &amp;b[i]);
    int sz = 1; while (sz &lt; n + m + 1) sz &lt;&lt;= 1;
    ntt(sz, a); ntt(sz, b);
    for (int i = 0; i &lt; sz; i++) printf(&quot;%lld %lld\n&quot;, a[i], b[i]);
    for (int i = 0; i &lt; sz; i++) a[i] = a[i] * b[i] % MOD;
    ntt(sz, a, -1); ll inv = qpow(sz, MOD - 2);
    for (int i = 0; i &lt; n + m + 1; i++)
        printf(&quot;%lld &quot;, (a[i] * inv % MOD + MOD) % MOD);
    puts(&quot;&quot;);
    return 0;
&#125; </code></pre>
<h1 id="常用的ntt素数">常用的NTT素数</h1>
<p>NTT所用的素数应该满足什么条件呢？观察<span class="math inline">\(g_n\)</span>的定义显然我们期望对于一定范围内的<span class="math inline">\(k\)</span>（比如说<span class="math inline">\(2^k \le 2\times 10^5\)</span>）都最好有<span class="math inline">\(2^k \mid p-1\)</span>。即<span class="math inline">\(p = a\times 2^k +1\)</span>的形式。</p>
<p>常见的NTT素数为：</p>
<ol type="1">
<li><span class="math inline">\(998244353 = 7\times 17\times 2^{23} + 1​\)</span></li>
<li><span class="math inline">\(1004535809 = 479 \times 2^{21} + 1\)</span></li>
<li><span class="math inline">\(469762049 = 7 \times 2^{26} + 1\)</span></li>
<li><span class="math inline">\(2281701377 = 17 \times 2^{27} + 1\)</span></li>
<li><span class="math inline">\(167772161 = 5 \times 2^{25} + 1\)</span></li>
</ol>
<p>这些素数的原根都包含<span class="math inline">\(3\)</span>。</p>
<h1 id="任意模数ntt">任意模数NTT</h1>
<p>有些时候题目要求任意模数的NTT变换，这个时候我们可以选取三个上述列表中模数分别进行NTT，然后通过CRT进行合并。具体上来说，对于一个数<span class="math inline">\(x\)</span>，若有： <span class="math display">\[
\begin{aligned}
x &amp;\equiv b_1 &amp;\pmod{p_1} \\
x &amp;\equiv b_2 &amp;\pmod{p_2} \\
x &amp;\equiv b_3 &amp;\pmod{p_3} 
\end{aligned}
\]</span> 我们考虑两两合并，先求解<span class="math inline">\(b_1 + k_1p_1 \equiv b_2 \pmod {p_2}​\)</span>，不难得到<span class="math inline">\(k_1 = p_1^{-1}(b_2 - b_1)​\)</span>（逆元在模<span class="math inline">\(p_2​\)</span>意义下）。</p>
<p>令<span class="math inline">\(x&#39; = b_1 + k_1p_1\)</span>，再求解<span class="math inline">\(x = x&#39; + k_2p_1p_2 \equiv b_3 \pmod {p_3}\)</span>，此时有<span class="math inline">\(k_2 = (p_1p_2)^{-1}(b_3 - x&#39;)\)</span>（逆元在模<span class="math inline">\(p_3\)</span>意义下）。</p>
<p>在计算的最后再对于指定的模数取模即可。</p>
<p>代码：</p>
<pre class="line-numbers"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;
typedef long long ll;
const ll G = 3;
const ll MOD1 = 998244353, MOD2 = 1004535809, MOD3 = 469762049;
const int N = 270000;
int n, m, P;

int qpow(int x, int y, int mod) &#123;
    int ret = 1;
    for (; y; y &gt;&gt;= 1) &#123;
        if (y &amp; 1) ret = (ll)ret * x % mod;
        x = (ll)x * x % mod;
    &#125;
    return ret;
&#125;

struct mint &#123;
    int m1, m2, m3;
    mint() &#123;&#125;
    mint(int x) : m1(x % MOD1), m2(x % MOD2), m3(x % MOD3) &#123;&#125;
    mint(int m1, int m2, int m3) : m1(m1), m2(m2), m3(m3) &#123;&#125;
    mint reduce() &#123; 
        return mint(m1 + (m1 &gt;&gt; 31 &amp; MOD1), // m1 &gt;&gt; 31 是符号位
                    m2 + (m2 &gt;&gt; 31 &amp; MOD2), 
                    m3 + (m3 &gt;&gt; 31 &amp; MOD3));
    &#125;
    mint operator +(const mint &amp;x) const &#123;
        return mint(m1 + x.m1 - MOD1, 
                    m2 + x.m2 - MOD2, 
                    m3 + x.m3 - MOD3).reduce();
    &#125;
    mint operator -(const mint &amp;x) const &#123;
        return mint(m1 - x.m1, m2 - x.m2, m3 - x.m3).reduce();
    &#125;
    mint operator *(const mint &amp;x) const &#123;
        return mint((ll)m1 * x.m1 % MOD1, 
                    (ll)m2 * x.m2 % MOD2, 
                    (ll)m3 * x.m3 % MOD3);
    &#125;
    mint inv() &#123;
        return mint(qpow(m1, MOD1 - 2, MOD1), 
                    qpow(m2, MOD2 - 2, MOD2), 
                    qpow(m3, MOD3 - 2, MOD3));
    &#125;
    int get() &#123;
        const int INV_1 = qpow(MOD1, MOD2 - 2, MOD2);
        const int INV_2 = qpow((ll)MOD1 * MOD2 % MOD3, MOD3 - 2, MOD3);
        ll x = (ll)(m2 - m1 + MOD2) % MOD2 * INV_1 % MOD2 * MOD1 + m1;
        return ((ll)(m3 - x % MOD3 + MOD3) % MOD3 * INV_2 % MOD3 
                * ((ll)MOD1 * MOD2 % P) % P + x) % P;
    &#125;
    static mint unit(int s) &#123;
        return mint(qpow(G, (MOD1 - 1) / s, MOD1), 
                    qpow(G, (MOD2 - 1) / s, MOD2), 
                    qpow(G, (MOD3 - 1) / s, MOD3));
    &#125;
&#125; a[N], b[N];

void ntt(int len, mint *x, int dir = 1) &#123;
    static mint X[N];
    for (int i = 0, k = 0; i &lt; len; i++) &#123;
        X[i] = x[k];
        int y = len &gt;&gt; 1;
        while (y &amp; k) k ^= y, y &gt;&gt;= 1;
        k |= y;
    &#125;

    for (int s = 2; s &lt;= len; s &lt;&lt;= 1) &#123;
        mint w_ = mint::unit(s);
        if (dir == -1) w_ = w_.inv();
        for (int l = 0; l &lt; len; l += s) &#123;
            int mid = l + (s &gt;&gt; 1);
            mint w = 1;
            for (int i = 0; i &lt; s &gt;&gt; 1; i++) &#123;
                mint t = w * X[mid + i];
                X[mid + i] = X[l + i] - t;
                X[l + i] = X[l + i] + t;
                w = w * w_;
            &#125;
        &#125;
    &#125;
    if (dir == -1) &#123;
        mint inv = mint(len, len, len).inv();
        for (int i = 0; i &lt; len; i++) X[i] = X[i] * inv;
    &#125;
    copy(X, X + len, x);
&#125;

int main() &#123;
    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;P);
    for (int i = 0; i &lt;= n; i++) &#123; int tmp; scanf(&quot;%d&quot;, &amp;tmp); a[i] = tmp; &#125;
    for (int i = 0; i &lt;= m; i++) &#123; int tmp; scanf(&quot;%d&quot;, &amp;tmp); b[i] = tmp; &#125;
    int sz = 1; while (sz &lt; n + m + 1) sz &lt;&lt;= 1;
    ntt(sz, a); ntt(sz, b);
    for (int i = 0; i &lt; sz; i++) a[i] = a[i] * b[i];
    ntt(sz, a, -1);
    for (int i = 0; i &lt; n + m + 1; i++) printf(&quot;%d &quot;, a[i].get());
    puts(&quot;&quot;);
    return 0;
&#125;</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/NOI%202020/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/NOI%202020/" class="post-title-link" itemprop="url">蒟蒻的NOI 2020退役记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-08-20 04:18:18" itemprop="dateModified" datetime="2020-08-20T04:18:18-04:00">2020-08-20</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="day--1">Day -1</h1>
<p>在中午太阳晒得最狠的时候到了学校。宿舍爬楼累死人，也不知道为啥学校楼要建那么高。幸好宿舍里的空调给力，好评。</p>
<p>宿舍的环境还行。个人觉得比当年WC2018的要好。</p>
<p>信号出奇地差，必须在直接靠窗的地方才有4G，不然连2G也别想收到，听宿管和小卖部阿姨说当初就是设计成这个样子的。差评。</p>
<p>插座很多好评。</p>
<p>但是还是没有桌子，无论用什么姿势看电脑都贼难受。同寝室的jtl带了一个床上架的桌子，看了直呼内行。床板贼硬，差评。</p>
<p>伙食还可以，豆浆我觉得挺好喝的，就是湖南菜多多少少带点辣个人不是很能接受，而且菜很细碎的样子。</p>
<p>睡前随随便便背了点笔试题。</p>
<h1 id="day-0">Day 0</h1>
<p>早上迷迷糊糊地去参加了开幕式。听到dzd说有剩饭扣1分大惊。其他就没啥印象了=_=。</p>
<p>结束后拱火mr押题，mr说看到才艺表演一个跳舞的转来转去暗示会考平衡树，一本正经胡说八道.jpg。</p>
<p>感觉周围大佬都贼多，互相之间也都认识，我一个蒟蒻在当中不知所措。自己看来对于在竞赛圈内的信息闭塞的可以。</p>
<p>中午又背了一会笔试题，然后下午就去试机了。笔试没有想象中的难，但是确实是有超纲的，纠结了很久。幸好最后还是满分飘过了。唯一值得吐槽的或许是CCF十年不变的远古测评系统。</p>
<p>随后在试机场上敲了一波LCT和FFT。看到jtl在写MTT有想敲三模数的冲动但是最后的合并调了好一会才勉强调出来，于是就很慌。</p>
<p>晚上寝室里大家都在欢快地打板子。对面两个人都在打带花树，然后惊奇地发现带花树的代码似乎也没有想象中那么长。三个人讨论了一下觉得似乎有概率考分块的样子，但是笑一笑也就过去了。我自己把各种字符串的算法全部过了一遍。</p>
<h1 id="day-1">Day 1</h1>
<p>看到T1愣了好一会，愣是没有第一时间看出DP。不知道为什么当时满脑子都是Tarjan和缩点然后沿着这个方向陷入了死胡同。于是先敲了一个DFS，觉得自己要完蛋。</p>
<p>看了T2又愣了一会，先敲了个暴力，然后觉得<span class="math inline">\(m\)</span>比较小的情况可以动态维护链并+容斥解决。先放着。</p>
<p>看到T3深切地感受到这或许是个数据结构毒瘤？先敲了一个二维树状数组的暴力。当时脑子大概是坏掉了不是枚举矩形直接算而是枚举点算贡献。总之暴力复杂度似乎<span class="math inline">\(\mathcal O(nm\log^2 n)\)</span>非常差。然后认真思考了一下部分分，发现可以莫队。于是基于二维树状数组写了一个<span class="math inline">\(\mathcal O\left(n\sqrt m \log^2 n\right)\)</span>的算法。然后觉得<span class="math inline">\(\mathcal O(\log ^2n)\)</span>的二维数点不妥，改成了<span class="math inline">\(\mathcal O(\log n)\)</span>的可持久化线段树，于是暴力和莫队的复杂度都少了一个<span class="math inline">\(\log\)</span>。再一看发现莫队我可以用树状数组干嘛要二维数点，于是莫队的常数又降下来一点。瞄了一眼后面觉得应该可以用<span class="math inline">\(\mathcal O(n^{7/4})\)</span>的四维莫队，可惜当初没认真学高维莫队不知道块大小咋算了，于是作罢。最后敲了一个莫队和暴力的对拍放着。</p>
<p>回到T2开始敲树剖和容斥，写了一个<span class="math inline">\(\mathcal O\left(m2^m\log^2n\right)\)</span>的算法。和暴力结合在一起觉得至少能拿<span class="math inline">\(32\)</span>分，常数小一点也可以冲冲<span class="math inline">\(40\)</span>样子。</p>
<p>然后回到T1，突然发现这不就一个裸的DP吗，直骂自己前面傻逼。于是花5分钟敲完朴素DP，然后再花10分钟敲完环的部分分。</p>
<p>然后发现边权至多为<span class="math inline">\(5\)</span>，意识到正解显然是用max-plus algebra下的矩阵快速幂进行优化，于是开始敲。此时离考试结束还有60分钟，心中贼慌。等到敲完离考试结束还有30分钟，心态爆炸，然后死活调不出来。只能把这个正解例程写在程序里作为最后之选。离交卷还有5分钟的时候不改了。检查其他两题的程序无误后就开始坐着怀疑自己前三个小时脑子到底在想什么……</p>
<p>出考场觉得自己已经成为了时代的眼泪（笑）。</p>
<p>下午三点去查分。听jtl说这次CCF准时出分没有咕简直是奇迹。结果就是<span class="math inline">\(50+32+40=122\)</span>。和预想的完全一致。这个时候就很后悔。如果当初早点看出矩阵快速幂把T1的正解调出来就好了。这个分觉得铁牌已经在向我招手。</p>
<p>晚上讲题。T1的确是快速幂正解。T2的正解是线段树合并维护树形DP这个之前也在寝室里有了大概的想法，但是一看这个DP的状态设计果然神仙。出题人怒斥了我们打<span class="math inline">\(32\)</span>分树剖暴力的，说是什么数据结构学傻了……然后说写个虚树不就<span class="math inline">\(40\)</span>了吗。我下面听着就很无语：我也想打虚树，但是我不会啊…… T3的出题人原来就是各种OJ上人们一直吐槽的lxl。这个题目的内部名称似乎叫“第十三分块”？正解似乎是先建一个树套树然后再分治再分块……讲到一半就lost了，内心大骂出题人毒瘤。</p>
<p>回寝室后所有人都是颓废的状态，gyc在打Splay的板子。剩下我们两个人开始摸鱼。</p>
<h1 id="day-2">Day 2</h1>
<p>T1一看给人一种网络流的既视感，然后发现图建不出来。退而求其次试图写出线性规划进行代数化建图，发现线性规划必须使用Big M的办法才能建出来，而且直观一看integrity gap大的离谱是不可能建图的。因为是求可行解也不知道目标函数咋写，所以也不能从对偶下手，只能作罢。敲了一个非常粗暴的DFS暴力枚举每道菜用哪两个原材料分别用多少，发现这个DFS在最坏情况下跑得巨慢无比——难不成我暴力骗分都不成？</p>
<p>这个时候有了一个乱搞的intuition，就是枚举原料的排列然后按照排列来确定所用的原料。然后发现过不了样例，于是作罢。</p>
<p>之后稍微改进了一点暴力，只枚举每道菜用哪两个原材料，最后时候用多少最后用网络流来判。这下终于拿到了<span class="math inline">\(15\)</span>分的暴力。顺便基于这个敲了一个随机化，但是似乎表现也不佳的样子。</p>
<p>T2题面长度属实劝退。读完题面之后觉得似乎不是很可做。看了样例之后有了一点暴力的想法，写了一个复杂度为<span class="math inline">\(\mathcal O\left(2^{2^{h_{\text{max}}-1}}\right)\)</span>的算法。简单来说就是把输入的树补成最大树高然后枚举能否扩张成最大树高下的所有可能的二叉树形态。觉得除了<span class="math inline">\(12\)</span>分纯暴力还可以拿<span class="math inline">\(h_{\text{max}}=4\)</span>的分？之后就不会了。</p>
<p>T3一看给我整懵了。可真就暴力不会写呗。直觉上似乎可以写Dijkstra然后在转移的时候排除掉当前路径下的割边。但是很快意识到Dijkstra的本质是DP而这个转移方案是有后效性的。事实上也是如此，样例都没有过。然后试验性地写了一个不可行的判定方法：求出最短路，如果把最短路去掉之后全图不连通，则不可行——也不知道这样对不对。</p>
<p>5个小时就在三个题目的来回懵逼当中度过。</p>
<p>这次CCF出分直接咕了将近两个小时。我们很明智地从一开始就待在寝室里，那些下去等分的就苦逼了。分数出来是<span class="math inline">\(15+12+5=32\)</span>、也差不多是我预想的这个水平，T2树高为<span class="math inline">\(4\)</span>的点我还是超时了，大概还是没有判同构去重的原因？</p>
<p>下午去听讲题。T1正解的思路源于<span class="math inline">\(m=n-1\)</span>的思考，其他的情况都是向<span class="math inline">\(m=n-1\)</span>情况的规约，感觉是非常巧妙的。T2的最优算法居然是线性的？有点听蒙了。听到T3讲解的时候才意识到T3当中的图叫做弦图，而正解源于对于弦图性质的思考，最后用过两次类Dijkstra来解决，感觉是非常非常神奇，不明觉厉，自愧不如。</p>
<p>讲的时候就出榜了，一看果然Cu，心情复杂，但是一开始也没有期望，所以也没有太沮丧。感觉心态真正崩盘的大概是jtl，人家Cu第一……差一分就Ag了。但是看榜还是有<span class="math inline">\(500\)</span>分以上的，觉得这些人真的很厉害。我或许不比他们笨，但是他们确实历练的比我这种多多了。我这种常年边缘划水的OIer果然不能和这些人比。</p>
<h1 id="day-3">Day 3</h1>
<p>看着手中的铜牌，意识到自己划水的OI之路至少到此为止暂时地画上了句号，颇有些不真实感。</p>
<p>我一直在想，如果D1T1的正解我调出来了，我就是Ag了，会不会好一点呢？但是这终究也只是一个幻想而已罢了。一是比赛不能重来，二是我似乎也不知道缓存矩阵乘方的套路所以真写快速幂有可能复杂度还是会炸的样子。</p>
<p>一如既往，自己复习的算法完美地和考试算法错开了。没有LCT，没有FFT，没有字符串。我深切意识到OI果然还是靠平时积累的，这种比赛临时抱佛脚很大概率是不靠谱的。</p>
<p>还是要谢谢NOI最后给了我一个意识到自己有多菜的机会。还有那么多我没有学的啊~</p>
<p>大概在没有竞赛压力之后我还是会对这些算法认真地研究一番的吧。觉得自己的心态是一个很奇妙的东西。在被父母逼着学竞赛的时候总觉得这些算法很烦，但是意识到自己远离竞赛之后，反而又觉得它们有趣起来了。</p>
<p>网上看过很多这样的游记，一般到最后作者不是Au就是进队了，这种好事终究不会发生在我身上。</p>
<p>唉。这就退役了。</p>
<p>写于Day 3从长沙回上海的火车上。自己的思路一如既往地混乱。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/Nim%E6%B8%B8%E6%88%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/Nim%E6%B8%B8%E6%88%8F/" class="post-title-link" itemprop="url">Nim博弈与阶梯博弈</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-09-06 08:52:10" itemprop="dateModified" datetime="2018-09-06T08:52:10-04:00">2018-09-06</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>觉得博弈论这种东西，知道结论代码巨短无比，不知道结论当场去世……</p>
<h1 id="nim-博弈">Nim 博弈</h1>
<h2 id="问题表述">问题表述</h2>
<p>有<span class="math inline">\(n\)</span>堆石子，第<span class="math inline">\(i\)</span>堆石子有<span class="math inline">\(a_i\)</span>个，两个玩家轮流操作，每个玩家每轮可以选择一堆石子，取走至少一个石子（也可以把一堆取光，但不能不取）。不能操作者判负。已知每方均采取最优策略，问先手还是后手必胜？</p>
<h2 id="解法">解法</h2>
<p><strong>定理：</strong>Nim博弈先手必胜当且仅当<span class="math inline">\(\bigoplus_{i = 1}^n a_i \neq 0\)</span>。</p>
<p><strong>证明：</strong>设<span class="math inline">\(\bigoplus_{i = 1}^n a_i = x \neq 0\)</span>，且<span class="math inline">\(x\)</span>的最高位为<span class="math inline">\(j\)</span>，由异或的性质，显然存在一个<span class="math inline">\(a_i\)</span>的第<span class="math inline">\(j\)</span>位为<span class="math inline">\(1\)</span>，且<span class="math inline">\(a_i \oplus x &lt; a_i\)</span>，我们选择第<span class="math inline">\(i\)</span>堆，令<span class="math inline">\(a_i = a_i \oplus x\)</span>，由异或的相消性，此时<span class="math inline">\(\bigoplus_{i = 1}^n a_i = 0\)</span>，我们把这样一个局面留给了后手，而后手无论怎么操作异或和都会变成非零。而不能操作的局面，即全零的局面的异或和同样为<span class="math inline">\(0\)</span>，又因为我们每次都可以那样地把锅推给对方，因此先手必胜。</p>
<h1 id="阶梯博弈">阶梯博弈</h1>
<h2 id="问题表述-1">问题表述</h2>
<p>有<span class="math inline">\(n\)</span>阶阶梯从左到右从低到高排开，记地面为第<span class="math inline">\(0\)</span>级，第<span class="math inline">\(i\)</span>个阶梯上有<span class="math inline">\(a_i\)</span>个石子，两个玩家轮流操作，每个玩家每轮可以选择一个阶梯，将其中的至少一个石子转移到左边的阶梯（或者地面）上。不能操作者判负。已知每方均采取最优策略，问先手还是后手必胜？</p>
<h2 id="解法-1">解法</h2>
<p><strong>定理：</strong>阶梯博弈等价于奇数阶的Nim博弈。</p>
<p><strong>证明：</strong>如果上一步对方从一个偶数阶的阶梯移动若干个石子到奇数阶，那么我们就原封不动地在这一步把这些石子再移到左边的偶数阶上去，因此偶数阶的石子的移动不造成影响。而既然偶数阶不造成影响，那么从奇数阶转移到偶数阶的操作等价于从奇数阶取走了若干石子（如果我们不看偶数阶），这样最后偶数阶的石子会全部到地面上，而奇数阶无法操作者自然就输了，证毕。</p>
<p><strong>例题：</strong>POJ 1704</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/Nginx%20Proxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/Nginx%20Proxy/" class="post-title-link" itemprop="url">Nginx带子路径的反向代理配置文件的正确写法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2019-12-16 09:09:50" itemprop="dateModified" datetime="2019-12-16T09:09:50-05:00">2019-12-16</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近折腾服务器把Aria2、H5AI、Jellyfin、Jupyter等集合到一个端口访问（因为开端口映射实在是一件麻烦事），于是需要经常用到Nginx的反向代理。之前的配置文件的效果一直都不是最完美，瑕疵体现在redirect之后就会忽略到子路径导致404。在网上多方搜索之后我终于找到了一个总体靠谱的写法（感觉Nginx的流行度还是比不上Apache），记下来留自己备用。</p>
<pre class="line-numbers"><code class="language-nginx">location /SUB_PATH &#123;
    return 302 $scheme://$host:$port/SUB_PATH/;
&#125;
location /SUB_PATH/ &#123;
    proxy_pass xxxxx;
    proxy_pass_request_headers on;
    proxy_redirect ~^/(.*) $scheme://$host:$port/SUB_PATH/$1;        
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $http_host;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $http_connection;
    # proxy_buffering off; 
&#125;</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/Minecraft%20ILP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/Minecraft%20ILP/" class="post-title-link" itemprop="url">Designing Computational Redstone Circuits Automatically in Minecraft with Integer Programming: Preliminary Thoughts and Tests</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-25 04:05:54" itemprop="dateModified" datetime="2020-11-25T04:05:54-05:00">2020-11-25</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>UNFINISHED ARTICLE -- WORK IN PROGRESS</strong></p>
<p><strong>UNFINISHED ARTICLE -- WORK IN PROGRESS</strong></p>
<p><strong>UNFINISHED ARTICLE -- WORK IN PROGRESS</strong></p>
<p>This was a project I worked on two months ago, but it wasn't until now that I have the time to write it down and share it on my blog.</p>
<h1 id="intro">Intro</h1>
<p>Redstone has been a core element in the game Minecraft for quite some years. It is presumably the most untrivial one as well: while anyone could master nearly all Minecraft mechanics through experiences, it takes not only experience but also ingenuity to design a good redstone circuit. Few of us are bold enough to claim "I master redstone", even after playing Minecraft for a decade.</p>
<p>So here comes the question: <strong>Can the design of redstone circuits, the core of Minecraft automations, be automated?</strong> and <strong>If so, how?</strong> (appreciate how meta this is :)</p>
<p>Theoretically, the answer is "yes...but". Minecraft has a finite world, and each position has a finite number of possible blockstates. We can write a program to enumerate all possible placements of blocks until we find some placement corresponding to the desired redstone circuit. However, this needs exponential time and we may need to wait for a century before it could give us, for instance, a decent piston door. Moreover, if a circuit involves manipulation of entities (which could have infinite many states), then we are easily screwed.</p>
<p>Well, perhaps it is difficult to let a program design any redstone circuit. But there is indeed a subset of redstone circuits whose design can very likely be automated -- <strong>computational redstone circuits</strong>, aka. logic gates, calculators, CPUs etc. Why? Because software that design their real world electronic counterparts are readily available -- they are called "EDA".</p>
<p>As a high school student I, of course, know little about the inner workings of real-world EDA applications (and there doesn't seem to be a lot of resources out there). I am convinced that this problem is NPC (further articulated below), so designing an efficient polytime combinatorial algorithm doesn't seem plausible. That said, what about reducing this problem to some other NPC problems which we can solve relatively quickly with optimized algorithms / heuristics -- say, ILP? This is what I am trying to do here.</p>
<h1 id="formulating-the-problem">Formulating the problem</h1>
<p>"Designing computational redstone circuit automatically" is a vague idea, so it is necessary that we know what this truly means.</p>
<h2 id="whats-the-input">What's the input?</h2>
<p>The input should describe the intended functionality of a circuit. Recall how we usually describe a circuit: we draw a <strong>circuit diagram</strong>. I here characterize a redstone circuit diagram by the assumptions and constraints below:</p>
<ol type="1">
<li>A circuit contains two parts: <strong>wires and components</strong>.</li>
<li>Components are the <strong>primitives</strong> of a circuit. E.g. A torch or a wire junction.</li>
<li>A component has <strong>interfaces</strong>, either <strong>in or out</strong>, as where the component receives signals from and sends signals to.</li>
<li>A wire connects <strong>an</strong> out-interface from a component ("source") to <strong>an</strong> in-interface of another component ("target").</li>
<li>Wires are <strong>directed</strong>.</li>
<li>Components are <strong>independent</strong>. i.e. they do not interfere with other components in any way other than being connected by wires from interfaces.</li>
</ol>
<p>A circuit diagram can be represented in a directed graph, with components as vertices and wires as edges. Source/target interfaces as extra information stored on edges.</p>
<h2 id="whats-the-output">What's the output?</h2>
<p>We want our program to tell us how the circuit we described in the input can be built in the Minecraft world. Therefore, we could define the the output to be a set of position - blockstate pairs, (which, in implementation, can be stored in a schematic file).</p>
<p>However, we don't want to jump straight from a circuit diagram to a detailed Minecraft schematic because that means taking interference between components, quasi connectivity, update order -- basically everything that makes redstone engineering complex -- into consideration in the first place.</p>
<p>Instead, we could first build our circuit in an <strong>ideal world</strong>, in which we forget about all those factors above, and then convert the ideal placement into an actual Minecraft schematic.</p>
<p>What's an idea world?</p>
<ol type="1">
<li>A circuit consists of multiple ideal blocks.</li>
<li>A component fully occupies a set of ideal blocks, some of which are its interfaces. How many and which blocks a certain type of component occupies depend on its size in Minecraft and how we plan to convert the ideal placement to a real schematic.</li>
<li>A wire is a chain of blocks, where any adjacent two share a face. The first block is always the source interface and the last is always the target interface.</li>
<li><strong>Exclusiveness: </strong>All components and all wires (ignoring their first and last block) mustn't overlap.</li>
<li><strong>Mutual Independence: </strong>Unless both blocks are occupied by the same component / wire, anything in two adjacent cells do not interfere with each other.</li>
<li>Wire junctions are special components and are exceptions to rule 2 and 3. A wire junction always have three interfaces (1 in &amp; 2 outs, or 2 ins &amp; 1 out). Multiple junctions can overlap and they can overlap with an interface of some component.</li>
<li>There are times when we want to fix the location of some components in the input. These components are usually just placeholders that mark the position of IO. (We don't want to produce a circuit with an unreachable input/output in the center of everything else, right?)</li>
</ol>
<h2 id="the-objective">The Objective</h2>
<ol type="1">
<li>The circuit represented by the output must have the same functionality as described by the input circuit diagram.</li>
<li>The delay of the circuit should be minimized.</li>
</ol>
<h2 id="example-the-and-gate">Example: the AND gate</h2>
<p>Let's see how we design a simple AND gate.</p>
<p>Suppose the only primitive components we have are NOT gate (torch), wire junction, and IO placeholder. The circuit diagram of AND gate is:</p>
<p><img src="/2021/07/25/Minecraft%20ILP/ANDCD.svg" class=""></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/Manjaro-VM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/Manjaro-VM/" class="post-title-link" itemprop="url">用LaTeX实时记数学笔记？！</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-02 01:50:04" itemprop="dateModified" datetime="2020-03-02T01:50:04-05:00">2020-03-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我几个月前看到国外有人<a target="_blank" rel="noopener" href="https://castel.dev/post/lecture-notes-1/">分享</a>用LaTeX实时记1700页数学笔记的感受，当时就被惊艳到了，心生向往。这次因为疫情待在家里上在线课程，总算是给了我一个带电脑进课堂的机会。于是我也仿照原作者的做法尝试了用记LaTeX笔记，这篇文章就来写一写我配置环境时遇到的坑和使用感受。</p>
<h1 id="系统选择">系统选择</h1>
<p>原文的作者采用的是Ubuntu发行版+bspwm作为桌面管理器，但是bspwm太小众，网上的资料很少。而且实测装在Ubuntu上默认的配置在视觉上不协调（还要自己去装一个像样的状态栏，总之就是太烦了）。相比之下i3作为另一个Tiling Window Manager比bspwm资料多多了，也比较适合我这种小白。权衡之下我选用Manjaro + i3。在Virtual Box下安装。</p>
<h1 id="配置镜像">配置镜像</h1>
<p>这一步不是必须的，因为Manjaro的默认源在国内的速度也还可以接受（~400kBps）。但是换了交大的源之后可以到10MBps：</p>
<pre class="line-numbers shell"><code class="language-none">sudo pacman -Syy
sudo pacman-mirrors -i -c China -m rank
sudo pacman -Syyu</code></pre>
<p>然后编辑<code>/etc/pacman.conf</code>加上ArchLinuxCN的交大镜像：</p>
<pre class="line-numbers"><code class="language-ini">[archlinuxcn]
SigLevel = Optional TrustedOnly
Server = https://mirrors.sjtug.sjtu.edu.cn/archlinux-cn/$arch</code></pre>
<p>最后导入一下密钥环，镜像就配置完了：</p>
<pre class="line-numbers shell"><code class="language-none">sudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring</code></pre>
<h1 id="安装virtual-box-ga">安装Virtual Box GA</h1>
<p>Manjaro默认对于虚拟机的支持不是很好。我不选择在VMWare上装Manjaro的主要原因也是因为我没有找到VMWare下自动分辨率比较简单的解决方案。在Virtual Box下只要装Virtual Box Guest Addition就可以了，美滋滋。</p>
<p>先安装基本的编译套件：</p>
<pre class="line-numbers shell"><code class="language-none">sudo pacman -S gcc make</code></pre>
<p>然后查看一下Linux内核版本：</p>
<pre class="line-numbers shell"><code class="language-none">uname -r</code></pre>
<p>是5.4，因此安装5.4的headers：</p>
<pre class="line-numbers shell"><code class="language-none">sudo pacman -S linux54-headers</code></pre>
<p>之后在Virtual Box菜单下插入GA的iso文件。我最初是手动挂载的（因为找不到i3里面怎么开文件管理器），就是<code>sudo blkid</code>看一下设备然后<code>mount</code>（如果出现不支持<code>iso9660</code>直接重启）。后来意识到文件管理器的名字是<code>pcmanfm</code>，再发现默认可以直接<code>mod + F3</code>打开文件管理器，于是就可以在上面直接操作了。<code>cd</code>进去运行<code>autorun.sh</code>跑完重启。就发现可以自动适应外部分辨率以及共享剪贴板了，非常方便。</p>
<h1 id="配置键位">配置键位</h1>
<p>默认Manjaro配置的<code>mod</code>键是<code>super</code>，也就是Win键。但是实测Win键在虚拟机环境下会有小问题（例如Win + L总是会被Windows先拦截导致锁屏）。所以我到<code>~/.i3/config</code>里面把<code>mod</code>键改成了<code>alt</code>。我还把i3默认的<code>jkl:</code>键位改成了和Vim相一致的<code>hjkl</code>键位。</p>
<h1 id="中文相关">中文相关</h1>
<p>Manjaro默认的中文渲染很有问题（装系统的时候居然没有中文字体！）。因此需要手动配置中文的渲染。</p>
<p>我基本上是按照<a target="_blank" rel="noopener" href="https://wiki.archlinux.org/index.php/Font_Configuration/Chinese_(简体中文)">Arch Wiki</a>上的Android类字体配置的。但是Arch Wiki上没有配置给终端用的等宽字体，需要个人发挥一下。我最喜欢的等宽字体是Sarasa Gothic（因为有中文）（去除中文我现在最喜欢的是Jetbrains Mono）。我发现ArchLinuxCN的源上已经有这款字体了，于是直接安装：</p>
<pre class="line-numbers shell"><code class="language-none">sudo pacman -S ttf-sarasa-gothic</code></pre>
<p>然后修改<code>~/.Xresources</code></p>
<pre class="line-numbers"><code class="language-ini">URxvt.font: xft:Sarasa Term SC:size=12</code></pre>
<p>重启一下就好了（其实不用重启，<code>xrdb ~/.Xresources</code>也行？）</p>
<p>接着是输入法。我原来准备装搜狗的，但是搜狗因为各种奇奇怪怪的原因（比如说字体找不到，比如说默认装<code>fcitx</code>的时候没有<code>qt4</code>的支持需要额外安装）不能用，在各种坑之后我决定不用它改用sunpinyin+cloud pinyin的组合，试用下来也是相当令人满意的：</p>
<pre class="line-numbers shell"><code class="language-none">sudo pacman -S fcitx-im
sudo pacman -S fcitx-configtool
sudo pacman -S fcitx-sunpinyin fcitx-cloudpinyin</code></pre>
<p>安装后在<code>~/.xprofile</code>里面加上下列几行启用fcitx</p>
<pre class="line-numbers shell"><code class="language-none">export GTK_IM_MODULE=fcitx
export QT_IM_MODULE=fcitx
export XMODIFIERS=&quot;@im=fcitx&quot;
fcitx -d</code></pre>
<p>最后一行是我自己加上的，因为似乎由于一些原因fcitx它开机不自启……</p>
<h1 id="配置tex">配置TeX</h1>
<p>终于可以开始进入正题了，首先安装TeXLive：</p>
<pre class="line-numbers shell"><code class="language-none">sudo pacman -S texlive-most texlive-langchinese</code></pre>
<p>接着安装Vim Plug，在<code>~/.vimrc</code>里面写入自动安装脚本（手动安装亦可）以及一些基本的配置：</p>
<pre class="line-numbers"><code class="language-vim">set number
set tabstop=4
set softtabstop=4
set shiftwidth=4
set smartindent

syntax on

if empty(glob(&#39;~/.vim/autoload/plug.vim&#39;))
    silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
        \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif</code></pre>
<p>接着安装所必要的VimTeX插件以及UltiSnips插件并进行相关的配置：</p>
<pre class="line-numbers"><code class="language-vim">call plug#begin(&#39;~/.vim/plugged&#39;)

Plug &#39;lervag/vimtex&#39;
let g:tex_flavor=&#39;latex&#39;
let g:vimtex_view_method=&#39;zathura&#39;
let g:vimtex_quickfix_mode=0
set conceallevel=1
let g:tex_conceal=&#39;abdmg&#39;

Plug &#39;sirver/ultisnips&#39;
let g:UltiSnipsExpandTrigger=&#39;&lt;tab&gt;&#39;
let g:UltiSnipsJumpForwardTrigger=&#39;&lt;tab&gt;&#39;
let g:UltiSnipsJumpBackwardTrigger=&#39;&lt;s-tab&gt;&#39;
let g:UltiSnipsSnippetDirectories=[&#39;mysnippets&#39;]

call plug#end()</code></pre>
<p>安装Zathura作为PDF阅读器：</p>
<pre class="line-numbers shell"><code class="language-none">sudo pacman -S zathura zathura-pdf-mupdf</code></pre>
<p>我查到Manjaro i3终端默认的背景色是<code>#222D31</code>，因此在<code>~/.config/zathura/zathurarc</code>里面写入</p>
<pre class="line-numbers"><code class="language-none">set default-bg &quot;#222D31&quot;
set recolor &quot;true&quot;
set recolor-lightcolor &quot;#222D31&quot;
set recolor-darkcolor &quot;#FFFFFF&quot;</code></pre>
<p>这样Zathura打开白色的pdf文档的时候就会自动重新着色，完成了色调上的统一。</p>
<p>Vimtex默认使用<code>latexmk</code>编译，<code>latexmk</code>默认调用<code>pdflatex</code>。因为要用中文我们希望它调用<code>xelatex</code>，于是在<code>~/.latexmkrc</code>里面加上</p>
<pre class="line-numbers"><code class="language-none">$pdf_mode = 1;
$pdflatex = &#39;xelatex --shell-escape %O %S&#39;;</code></pre>
<p>现在随便打开一个tex文档，打出<code>\ll</code>，预览就冒出来了，非常方便。</p>
<h1 id="配置snippets">配置Snippets</h1>
<p>我基本上复制了作者原博客上的大部分snippets的定义。再加上了一些我觉得比较常用的：</p>
<pre class="line-numbers"><code class="language-none">snippet exm &quot;example&quot; bA
\begin&#123;example&#125;
$1
\end&#123;example&#125;
$0
endsnippet

snippet sln &quot;solution&quot; bA
\begin&#123;solution&#125;
$1
\end&#123;solution&#125;
$0
endsnippet

snippet -&gt; &quot;arrow&quot; A
\Rightarrow
endsnippet

snippet sc &quot;since&quot; wA
\because
endsnippet

snippet tf &quot;therefore&quot; wA
\therefore
endsnippet

snippet tx &quot;text&quot; wA
\text&#123;$1&#125;$0
endsnippet

snippet par &quot;()&quot; wA
\left($1\right)$0
endsnippet

snippet pbk &quot;[]&quot; wA
\left[$1\right]$0
endsnippet

snippet pbr &quot;&#123;&#125;&quot; wA
\left\\&#123;$1\right\\&#125;$0
endsnippet

snippet pabs &quot;||&quot; wA
\left|$1\right|$0
endsnippet

snippet enum &quot;enumerate&quot; bwA
\begin&#123;enumerate&#125;
$1
\end&#123;enumerate&#125;
$0
endsnippet

snippet ml &quot;multiline math&quot; bwA
\begin&#123;gather*&#125;
$1
\end&#123;gather*&#125;
$0
endsnippet</code></pre>
<p>笔记源文件的preamable定义如下，使用<code>fleqn</code>选项对所有方程进行左对齐，并定义<code>example</code>和<code>solution</code>环境方便记例题和解答：</p>
<pre class="line-numbers"><code class="language-latex">\documentclass[fleqn]&#123;ctexart&#125;

\usepackage&#123;amsthm&#125;
\usepackage&#123;amsmath&#125;
\usepackage&#123;amssymb&#125;
\usepackage&#123;tikz&#125;

\newtheorem*&#123;solution&#125;&#123;解&#125;
\newtheorem&#123;example&#125;&#123;例&#125;[subsection]

\begin&#123;document&#125;
    \maketitle
    ...
\end&#123;document&#125;</code></pre>
<p>最后的效果如下：</p>
<p><img src="https://s2.ax1x.com/2020/03/02/3RRrp6.png" alt="3RRrp6.png" /></p>
<p>成果：</p>
<p><img src="https://s2.ax1x.com/2020/03/02/3Rojqf.png" alt="3Rojqf.png" /></p>
<p>对比手写版：</p>
<p><img src="https://s2.ax1x.com/2020/03/02/3Ro6PJ.jpg" alt="3Ro6PJ.jpg" /></p>
<p>是不是看起来还不错？</p>
<h1 id="使用感受">使用感受</h1>
<h2 id="优点">优点</h2>
<ul>
<li>格式内容分离，便于重新排版与整理</li>
<li>字体统一美观（自己手写的字实在是太丑了哇）</li>
<li>例题的自动编号很赞！</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li><p>Vim原来就有两个常用的模式，输入法的使用又增加了一个模式。来回shift切换打断了编辑的流畅性，降低了效率。尤其是很多时候输入法还没切回英文就<code>jj</code>一下或者切片段，结果还要删掉，按shift，然后重新打，有的时候着实糟心。</p></li>
<li><p>Snippets多固然增加了效率，但是也增加了记忆的负担。对于我这种新手来说，过多的snippets只是把打LaTeX的时间转换成回忆用哪个snippet比较好的时间，一下子增加太多snippets也会降低效率。</p></li>
<li><p>错字的存在。搜狗输入法对于偶尔的打错具有自动修正的功能，但是无论是谷歌拼音还是sunpinyin在这方面都不行，加上很多时候这些输入法的选词并不智能，一个个看过来选词其实也是非常耗费时间的。</p></li>
<li><p>还是错字，例如“已知”错打成“一直”，英文可以配置spell checker做实时的纠正，这在原文当中也有提到，但是中文目前在这方面还缺乏支持。我听说百度有这方面的接口，但是不知道对于数学笔记专业性这么强的语料效果怎么样。Vim插件我是肯定没找到。</p></li>
<li><p>笔记的结构比较松散，在笔记本上我们可以拿箭头划来划去，有旁注也可以轻松插入，但是这在LaTeX当中绝非易事。很多时候数学笔记的格式很容易让人陷入纠结，比如说我乱打的一段</p>
<blockquote>
<p>设<span class="math inline">\(y=kx+b,\quad (k\neq 0)\)</span></p>
<p><span class="math inline">\(\Rightarrow x=\frac{y-b}{k}\)</span>又因为已知<span class="math inline">\(k=\tan \alpha\)</span>...</p>
</blockquote>
<p>这种格式要怎么排版呢？</p>
<ol type="1">
<li>是整个作为一个大的display style math，中文文字作为<code>\text&#123;&#125;</code>镶嵌其中？</li>
<li>还是一行一个display-style math?</li>
<li>还是有中文字的行用inline math，然后纯数学符号的行用display math?</li>
<li>要不要用<code>gather*</code>这种环境？</li>
</ol>
<p>又比如说如下这段：</p>
<blockquote>
<p><span class="math inline">\(\begin{cases}x=1 \\y=2\end{cases}\)</span>或<span class="math inline">\(\begin{cases}x=2 \\y=1\end{cases}\)</span></p>
</blockquote>
<p>手写起来非常简单，但是LaTeX代码呢？</p>
<pre class="line-numbers"><code class="language-latex">$\begin&#123;cases&#125; x=1 \\ y=2 \end&#123;cases&#125;$
或
$\begin&#123;cases&#125; x=2 \\ y=1 \end&#123;cases&#125;$</code></pre>
<p>一下子复杂了不少，更别说为了中间的“或”字需要输入法切换。这是snippets也难以挽救的低效。</p></li>
<li><p>我还没有试过画图。但是这一定是一个天坑。</p></li>
<li><p>如果编译失败那几乎是当场去世（悲）</p></li>
</ul>
<h1 id="总结">总结</h1>
<p>就我个人体验而言，用LaTeX记笔记虽然能够达到非常高的排版质量，但是并没有传说中的那么高效（尤其是在使用中文的背景之下）。用LaTeX整理笔记自然是极好的，但是用LaTeX在课堂上实时记笔记绝对属于一大作死行为（更别说你也不知道老师收不收LaTeX记得笔记对不？）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://alan20210202.github.io/2021/07/25/LU/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="Chengyuan Ma">
      <meta itemprop="description" content="不务正业高中生一枚">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chengyuan Ma's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/25/LU/" class="post-title-link" itemprop="url">LU分解笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 03:11:40" itemprop="dateCreated datePublished" datetime="2021-07-25T03:11:40-04:00">2021-07-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2019-12-21 01:19:16" itemprop="dateModified" datetime="2019-12-21T01:19:16-05:00">2019-12-21</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="矩阵向量相乘的意义">矩阵向量相乘的意义</h1>
<p>这部分和LU分解没有多大关系，但是GS的书里一直强调这种理解，想必是极有用的。</p>
<p>当矩阵左乘一个列向量，其结果等同于矩阵每一列以列向量为权的线性组合，例如 <span class="math display">\[
\begin{pmatrix}
    1&amp;2&amp;3\\
    4&amp;5&amp;6\\
    7&amp;8&amp;9\\
\end{pmatrix}
\begin{pmatrix}
1\\
2\\
3
\end{pmatrix}
=
1\begin{pmatrix}
1\\4\\7
\end{pmatrix}
+2\begin{pmatrix}
2\\5\\8
\end{pmatrix}
+3\begin{pmatrix}
3\\6\\9
\end{pmatrix}
\]</span> 类似地，当矩阵右乘一个行向量，其结果等于矩阵每一行以行向量为权的线性组合，例如 <span class="math display">\[
\begin{pmatrix}
1&amp;2&amp;3
\end{pmatrix}
\begin{pmatrix}
    1&amp;2&amp;3\\
    4&amp;5&amp;6\\
    7&amp;8&amp;9\\
\end{pmatrix}
=\begin{matrix}
1\begin{pmatrix}
1&amp;2&amp;3
\end{pmatrix}\\
+\\
2\begin{pmatrix}
4&amp;5&amp;6
\end{pmatrix}\\+\\
3\begin{pmatrix}
7&amp;8&amp;9
\end{pmatrix}
\end{matrix}
\]</span> 多列，多行的情况也可以以此类推。</p>
<h1 id="初等行变换的矩阵表示">初等行变换的矩阵表示</h1>
<p>注意到初等行变换可以使用矩阵进行表示，例如在一个<span class="math inline">\(3\times 3\)</span>的矩阵当中把第<span class="math inline">\(1\)</span>行的<span class="math inline">\(3\)</span>倍加到第二行就可以表示为： <span class="math display">\[
\begin{pmatrix}
1&amp;0&amp;0 \\
3&amp;1&amp;0 \\
0&amp;0&amp;1
\end{pmatrix}
\begin{pmatrix}
1&amp;2&amp;3 \\
4&amp;5&amp;6 \\
7&amp;8&amp;9
\end{pmatrix}
=\begin{pmatrix}
1&amp;2&amp;3 \\
7&amp;11&amp;15 \\
7&amp;8&amp;9
\end{pmatrix}
\]</span> <strong>注意行变换的矩阵是左乘的，右乘就是列变换了！</strong></p>
<p>具体来说，如果你把第<span class="math inline">\(i\)</span>行的<span class="math inline">\(k\)</span>倍加到第<span class="math inline">\(j\)</span>行上，那么这个变换对应的矩阵就是在以单位矩阵为基础上<span class="math inline">\(a_{j,i}=k\)</span>。</p>
<p>初等行变换的矩阵常用符号<span class="math inline">\(E\)</span>表示。</p>
<p>由于初等行变换的意义，很容易就可以看出其逆矩阵就是把对应的元素取反，加上的我们就减回去： <span class="math display">\[
E=\begin{pmatrix}
1&amp;0&amp;0 \\
3&amp;1&amp;0 \\
0&amp;0&amp;1
\end{pmatrix}\Rightarrow 
E^{-1}=\begin{pmatrix}
1&amp;0&amp;0 \\
-3&amp;1&amp;0 \\
0&amp;0&amp;1
\end{pmatrix}
\]</span></p>
<h1 id="矩阵的lu分解">矩阵的LU分解</h1>
<p>在学习初等行变换的矩阵表示之后再回头考虑我们对着<span class="math inline">\(n\times n\)</span>矩阵<span class="math inline">\(A\)</span>做消元得到上三角阵<span class="math inline">\(U\)</span>的过程，我们就会发现，<strong>在消元过程不涉及交换两行的时候，</strong>消元过程可以表示为： <span class="math display">\[
E_{n,n-1}\cdots E_{31}E_{21}A=U
\]</span> 其中<span class="math inline">\(E_{21}\)</span>表示我们把<span class="math inline">\(a_{21}\)</span>消为<span class="math inline">\(0\)</span>所运用的行变换。</p>
<p>注意到在消元的时候我们是按照<span class="math inline">\(E_{21}, E_{31},\cdots\)</span>这个顺序消过来的，但是因为行变换是左乘，因此上式当中从左到右序号是反的。</p>
如果<span class="math inline">\(A\)</span>确实可以顺顺利利地消成<span class="math inline">\(U\)</span>，那说明<span class="math inline">\(E_{n,n-1}\cdots E_{31}E_{21}\)</span>是可逆的，即： $$
<span class="math display">\[\begin{aligned}
A&amp;=(E_{n,n-1}\cdots E_{31}E_{21})^{-1}U\\ 
&amp;=E_{21}^{-1}E_{31}^{-1}\cdots E_{n,n-1}^{-1}U

\end{aligned}\]</span>
<p><span class="math display">\[
不妨令$L=E_{21}^{-1}E_{31}^{-1}\cdots E_{n,n-1}^{-1}$，则矩阵$A$可以写作：
\]</span> A=LU $$ 这就被称为矩阵<span class="math inline">\(A\)</span>的<span class="math inline">\(LU\)</span>分解。</p>
<p>其中<span class="math inline">\(U\)</span>是上三角阵无疑，而<span class="math inline">\(L\)</span>，其字母暗示我们这是一个<strong>下三角阵</strong>。</p>
<p>不仅如此，比如说对于<span class="math inline">\(3\)</span>阶方阵消元共三步： <span class="math display">\[
E_{21}^{-1} = \begin{pmatrix}
1&amp;0&amp;0\\
a&amp;1&amp;0\\
0&amp;0&amp;1
\end{pmatrix}
,
E_{31}^{-1} = \begin{pmatrix}
1&amp;0&amp;0\\
0&amp;1&amp;0\\
b&amp;0&amp;1
\end{pmatrix}
,
E_{32}^{-1} = \begin{pmatrix}
1&amp;0&amp;0\\
0&amp;1&amp;0\\
0&amp;c&amp;1
\end{pmatrix}
\]</span> 计算<span class="math inline">\(L\)</span>可得 <span class="math display">\[
L=\begin{pmatrix}
1&amp;0&amp;0\\
a&amp;1&amp;0\\
0&amp;0&amp;1
\end{pmatrix}\begin{pmatrix}
1&amp;0&amp;0\\
0&amp;1&amp;0\\
b&amp;0&amp;1
\end{pmatrix}\begin{pmatrix}
1&amp;0&amp;0\\
0&amp;1&amp;0\\
0&amp;c&amp;1
\end{pmatrix}=\begin{pmatrix}
1&amp;0&amp;0\\
a&amp;1&amp;0\\
b&amp;c&amp;1
\end{pmatrix}
\]</span> <span class="math inline">\(L\)</span>在形式上就是把<strong>所有行变换矩阵“拼起来“</strong>！矩阵乘法平常都会把矩阵里面的数字形式破坏掉，这次为什么那么奇妙呢？</p>
<p><strong>从消元的角度，可以这么理解：</strong></p>
<p>我们能够把两个行变换矩阵“拼”起来，当且仅当一个变换的结果不会改变另一个变换的源。</p>
<p>什么意思？如果<span class="math inline">\(E_1\)</span>把第<span class="math inline">\(2\)</span>行的<span class="math inline">\(3\)</span>倍加到第<span class="math inline">\(2\)</span>行，<span class="math inline">\(E_2\)</span>把第<span class="math inline">\(1\)</span>行的<span class="math inline">\(2\)</span>倍加到第<span class="math inline">\(2\)</span>行。</p>
<p>如果我们先做<span class="math inline">\(E_1\)</span>再做<span class="math inline">\(E_2\)</span>即<span class="math inline">\(E_2E_1\)</span>，那么这个时候我们是可以直接拼起来的。因为先做的<span class="math inline">\(E_1\)</span>没有改变<span class="math inline">\(E_2\)</span>所依赖的第<span class="math inline">\(2\)</span>行。但是先做<span class="math inline">\(E_2\)</span>再做<span class="math inline">\(E_1\)</span>即<span class="math inline">\(E_1E_2\)</span>就不能直接拼起来，因为先做的<span class="math inline">\(E_2\)</span>把<span class="math inline">\(E_1\)</span>所依赖的第<span class="math inline">\(2\)</span>行改掉了。</p>
<p>然后我们发现在<span class="math inline">\(LU\)</span>分解里面我们是先改第<span class="math inline">\(n\)</span>行，再改第<span class="math inline">\(n-1\)</span>行这样从下到上地变换上去的。改变第<span class="math inline">\(n\)</span>行的变换只会依赖于前<span class="math inline">\(n-1\)</span>行，因此出不了问题。</p>
<p><strong>从纯计算的角度，可以这么解释：</strong></p>
<p>考虑矩阵乘法<span class="math inline">\(L=EL&#39;\)</span>，其中<span class="math inline">\(E\)</span>是一个行变换矩阵且假设其中<span class="math inline">\(E_{ik}=a\)</span>，<span class="math inline">\(L&#39;\)</span>是下三角阵。</p>
则考虑<span class="math inline">\(L\)</span>第<span class="math inline">\(i\)</span>行第<span class="math inline">\(j\)</span>列的值<span class="math inline">\(L_{ij}\)</span>（除了第<span class="math inline">\(i\)</span>行，结果的其他行显然等于<span class="math inline">\(L&#39;\)</span>），必然是<span class="math inline">\(E\)</span>的行向量与<span class="math inline">\(L&#39;\)</span>列向量之点乘： $$ L_{ij}=
<span class="math display">\[\begin{pmatrix}
0 \\
\vdots \\
a\\
\vdots \\
\color{red}1\\
\vdots\\
0
\end{pmatrix}
\cdot
\begin{pmatrix}
0 \\
\vdots \\

\color{blue}1 \\
\vdots \\
b \\
c \\
\vdots \\
\end{pmatrix}\]</span>
<p>$$</p>
<p>由于三角阵主对角线上都是<span class="math inline">\(1\)</span>，在上式中左边向量里面的<span class="math inline">\(\color{red}1\)</span>就是从上往下数第<span class="math inline">\(i\)</span>个，右边向量里面的<span class="math inline">\(\color{blue}1\)</span>就是从上往下数第<span class="math inline">\(j\)</span>个。因为是下三角阵<span class="math inline">\(\color{red}1\)</span>的下面都是<span class="math inline">\(0\)</span>，<span class="math inline">\(\color{blue}1\)</span>的上面也都是<span class="math inline">\(0\)</span>。接下来讨论<span class="math inline">\(\color{red}1\)</span>和<span class="math inline">\(\color{blue} 1\)</span>的位置关系。</p>
<ul>
<li><span class="math inline">\(i&lt;j\)</span>时，<span class="math inline">\(\color{red}1\)</span>在<span class="math inline">\(\color{blue}1\)</span>的上面。右侧<span class="math inline">\(\color{blue} 1\)</span>下面非零的元素对着左边的都是<span class="math inline">\(0\)</span>，左侧<span class="math inline">\(\color{red}1\)</span>上面的非零<span class="math inline">\(a\)</span>对到右边也是<span class="math inline">\(0\)</span>，因此<span class="math inline">\(L_{ij}=0\)</span>。</li>
<li><span class="math inline">\(i=j\)</span>时，<span class="math inline">\(\color{red} 1\)</span>正对着<span class="math inline">\(\color{blue}1\)</span>，因此<span class="math inline">\(L_{ij}=1\times 1=1\)</span>。</li>
<li><span class="math inline">\(i&gt;j\)</span>时，<span class="math inline">\(\color{red} 1\)</span>在<span class="math inline">\(\color{blue}1\)</span>的下面。<span class="math inline">\(a\)</span>是左侧从上往下数第<span class="math inline">\(k\)</span>个。
<ul>
<li><span class="math inline">\(j&gt;k\)</span>时，<span class="math inline">\(\color{blue}1\)</span>在<span class="math inline">\(a\)</span>下面，<span class="math inline">\(a\)</span>对着<span class="math inline">\(0\)</span>。<span class="math inline">\(L_{ij}=L&#39;_{ij}\)</span>。</li>
<li><span class="math inline">\(j=k\)</span>时，<span class="math inline">\(a\)</span>对着<span class="math inline">\(\color{blue}1\)</span>，<span class="math inline">\(\color{red}1\)</span>对着<span class="math inline">\(L&#39;_{ij}，\)</span><span class="math inline">\(L_{ij}=a+L&#39;_{ij}\)</span>。</li>
<li><span class="math inline">\(j&lt;k\)</span>时，<span class="math inline">\(a\)</span>对着<span class="math inline">\(L&#39;_{kj}\)</span>，<span class="math inline">\(\color{red}1\)</span>对着<span class="math inline">\(L&#39;_{ij}\)</span>。<span class="math inline">\(L_{ij}=aL&#39;_{kj}+L&#39;_{ij}\)</span>。</li>
</ul></li>
</ul>
<p>显然，当我们向左边一个一个行变换矩阵乘过来的时候，<span class="math inline">\(L&#39;_{ij}=0\)</span>，且<span class="math inline">\(L&#39;_{kj}=0\quad \forall j&lt;k\)</span>。于是乎 <span class="math display">\[
L_{ij} = \begin{cases}
0, &amp; i&lt;j\\
1, &amp; i=j\\
L&#39;_{ij}, &amp;k&lt;j&lt;i \\
a, &amp; j=k\\
0, &amp; j&lt;k\\
\end{cases}
\]</span> 这就是把<span class="math inline">\(a\)</span>直接放到<span class="math inline">\(L&#39;\)</span>的对应位置里面。结合数学归纳法，可以导出<span class="math inline">\(LU\)</span>分解的结果确实就是几个行变换矩阵“拼起来”。</p>
<h1 id="矩阵的ldu分解">矩阵的LDU分解</h1>
<p>注意到在<span class="math inline">\(A=LU\)</span>当中，我们虽然保证了<span class="math inline">\(L\)</span>的主对角线是上<span class="math inline">\(1\)</span>，但是<span class="math inline">\(U\)</span>的主对角线上就未必了。</p>
<p>假设<span class="math inline">\(U\)</span>的主对角线上的数是<span class="math inline">\(d_1,d_2,\cdots,d_n\)</span>，那么不妨令： <span class="math display">\[
U=DU&#39;
\]</span> 其中 <span class="math display">\[
D=\begin{pmatrix}
d_1&amp;0&amp;\cdots&amp;0\\
0&amp;d_2&amp;\cdots&amp;0\\
\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\
0&amp;0&amp;\cdots&amp;d_n\\
\end{pmatrix}
\]</span> 而<span class="math inline">\(U&#39;\)</span>是<span class="math inline">\(U\)</span>每一行分别除以<span class="math inline">\(d_1,d_2,\cdots,d_n\)</span>的结果。</p>
<p>这样一来分解就变成了 <span class="math display">\[
A=LDU&#39;
\]</span></p>
<p>这种分解就被称作矩阵<span class="math inline">\(A\)</span>的<span class="math inline">\(LDU\)</span>分解。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chengyuan Ma</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js" integrity="sha512-YBk7HhgDZvBxmtOfUdvX0z8IH2d10Hp3aEygaMNhtF8fSOvBZ16D/1bXZTJV6ndk/L/DlXxYStP8jrF77v2MIg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/line-numbers/prism-line-numbers.min.js" integrity="sha512-br8H6OngKoLht57WKRU5jz3Vr0vF+Tw4G6yhNN2F3dSDheq4JiaasROPJB1wy7PxPk7kV/+5AIbmoZLxxx7Zow==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-bash.min.js" integrity="sha512-JvRd44DHaJAv/o3wxi/dxhz2TO/jwwX8V5/LTr3gj6QMQ6qNNGXk/psoingLDuc5yZmccOq7XhpVaelIZE4tsQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-c.min.js" integrity="sha512-T6Lco61aWqCKSznWkd38lf159pD0+EwZ9UCEv6ARAvaWFiy/UHtYgOmlasT8lq5Ck17ZNHzbe5eHUablTGRXxw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cmake.min.js" integrity="sha512-M99z3be36IUB5pA3DWoJvjSYaZA9BiUqf1jXzVcjntASBZFNI53oDRzdJqGzH5voybcAx5Sg8F5QyryE6afD3g==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cpp.min.js" integrity="sha512-hxZJ6OUEpUl9/o4C1gMGvrAbeqDaldBiZbs08c/V8NcU7YImBFlqJAc7Uzjf3bh2W8Wx26/dVDyPk9cUMQY0Mw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-go.min.js" integrity="sha512-SgF1uayJ2/8TV+MhLasqygnm++vYRXswmrR2ZAmUCL4pXtf+6KzUgXPpn10Y6xca658sxOQEOsoP3MChfhke5A==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-java.min.js" integrity="sha512-PWHY6Vao4E9K4LsGBYCY0ttDeiWZwuUozTbJvSy9UFHRz2J4Bl7rcWML3wEnJTVuCJhSwGne/8My5gTo/gnbpg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-json.min.js" integrity="sha512-IC7rV8RslChgByOdUFC6ePqOGn+OwJhnKC3S5AezM8DAiOdGhJMwgsIvBChsa2yuxxoPbH2+W/kjNUM1cc+jUQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-kotlin.min.js" integrity="sha512-aTozTdtORp/xxS/dhRRDfmv/p1eyEMTje96MplkSOqdbKGGvOYIlogoGdtsh/BD91vaqKoAw9M7O/DodqqudIQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-julia.min.js" integrity="sha512-eTGeKQdDzC2rPAUVfM2Fa36s9B9wp138NEhzZqJpRSdJQ66BwLUot25r2YQveCRU5uYNVfX3gckDkl4byfBIWw==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-latex.min.js" integrity="sha512-6D3l3Fy8g/hr6AeK2g1rcVZHyFjCqiqgUrwy0mBZTGFd8UwVcUDhzQeIIv3eYeXDecGPTtBOS9ctyRzJyUgypQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-rust.min.js" integrity="sha512-kgT7r2HlCEO4b+Rp3nJvm+/EMBwGMvv1WMdWkb3eNgnS91llMli8Y3T1CgnD8Hifqx50Q3XLUQXDd7PzKQQtUA==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-python.min.js" integrity="sha512-wK9tQmDrstGtZqTKcyVf3h457QGMlNriKs+fHmEkiCizrq0LVovfT3v1smeT1DlQetHhdRkkX1JSuZg5LoNHJg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-nginx.min.js" integrity="sha512-/MNzg8GlnVrAau/TZClh1jxgHNX0HDgidbGnHS5x1OtbKiNoK3e0XNd1oV16xmmeDHjisa3GKLArUau+43GZ4A==" crossorigin="anonymous"></script>
<script type = "text/javascript">
    document.addEventListener('pjax:complete', function() {
        if (typeof Prism !== 'undefined') {
            Prism.highlightAll();
        }
    });
</script>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  






  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    <div class="pjax">

  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



    </div>
</body>
</html>
